@tangler ex1 = examples/ex1.flx
@title coroutines
@h1 A low level example.
I will show a simple low level example of coroutines, it will be a 
simple pipeline consisting of a source, a transducer, a limiter, and a sink.

First we have our source, which just write all the integers starting from 0
down the channel @{out}. The type @{%>int} is an output channel endpoint
for @{int}.

@tangle ex1
proc source (out: %>int) () {
  var i = 0;
  while true do 
    write (out,i); 
    ++i; 
  done
}
@

Now we have a simple sink, which just prints everything it reads:
@tangle ex1
proc sink (inp: %<int) () {
  while true do 
    var i = read inp;
    println$ i;
  done
}
@
You should note the extra unit parameter @{()}. After the input is bound, the resulting
procedure will have type
@felix
unit -> unit
@
which is the type required to spawn fibre from a coroutine.

Now we have a transducer which writes the square of every integer it reads.
@tangle ex1
proc squarer (inp: %<int, out: %>int) () {
  while true do 
    var i = read inp;
    write (out, i * i);
  done
}
@

You should notice the previous three components were all infinite loops.
Since we don't want our demo to run forever we will throw in a limiter chip:
@tangle ex1
proc limiter (var limit: int) (inp: %<int, out: %>int) () {
  while limit > 0 do
    var i = read inp;
    write (out, i);
    --limit;
  done
};
@
This procedure drops through, but it cannot return control, because
there is nowhere to return it to, so it has, in effect, committed
suicide implicitly.

Now we need have four components so we need three channels to connect them:
@tangle ex1
proc run_pipeline() {
  // make channels
  var i1,o1 = mk_ioschannel_pair[int](); 
  var i2,o2 = mk_ioschannel_pair[int](); 
  var i3,o3 = mk_ioschannel_pair[int](); 

  // make coroutines by binding the channels
  var d1 = source(o1);
  var d2 = squarer(i1,o2);
  var d3 = limiter 8 (i2,o3);
  var d4 = sink (i3);

  // spawn coroutines as fibres
  spawn_fthread d1;
  spawn_fthread d2;
  spawn_fthread d3;
  spawn_fthread d4;
 
  // exit
}
run_pipeline();
@



@h1 The concept of fibration
A <em>coroutine system</em> is a collection of processes called <em>fibres</em>
with these properties:
<ul>
<li>Exactly one process can be <em>running</em> at once, the others are said to be <em>suspended</em></li>
<li>Control cannot be pre-empted, but is yielded voluntarily</li>
</ul>
In our system, there are four principle operations which yield control:
<ol>
<li><em>spawn</em> a new fibre</li>
<li><em>read</em> from a channel</li>
<li><em>write</em> to a channel</li>
<li>Commit <em>suicide</em>
</ol>
A fibre of control can be in one of five states:
<ol>
<li>Running</em>
<li>Active (but not running)</li>
<li>Waiting on read</li>
<li>Waiting on write</ii>
<li>Dead</li>
</ol>
In our system, all the resources associated by an <em>unreachable</em> dead
fibre are automatically reaped by the garbage collector so that in fact
the fibre is not technically dead because it no longer exists.

A <em>channel</em> is an object associated with which 
set of fibres all waiting to read or all waiting to write.

When a write operation is performed on a channel by the running fibre,
if there are fibres on the channel which are waiting to read
then one is selected, the data to be written is tranfered from the writer to the reader,
the fibre is removed from association with the channel,
and both the running and reader fibre are made active.
Otherwise if there is no readers waiting on the channel, the writer is 
suspended and put on the channel.

When a read operation is performed on a channel by the running fibre,
if there are fibres on the channel which are waiting to write
then one is selected, the data to be written is transfered from the writer to the reader, 
fibre, the fibre is removed from association with the channel,
and both the running and reader fibre are made active.
Otherwise if there is no writers waiting on the channel, the writer is 
suspended and put on the channel.

When a fibre commits suicide, it is removed as the running fibre.

When a new fibre is spawned, both the spawner and spawnee are made active.

When there is no running fibre, then if an active fibre exists,
an active fibre is selected and promoted to running state
and the thread of control begins executing it.

When there is no running fibre, and no active fibres,
the whole system terminates. Any fibres waiting on I/O become dead

The description above is a complete account of the abstract semantics
known as <em>Communicating Sequential Coroutines</em> or CSC, it is a
sub system obtain from Tony Hoare's <em>Communicating Sequenmtial Processes</em>
or CSP, in which concurrency is replaced by an indeterminate total ordering.

To be precise in CSC all events are totally ordered, however the exact ordering
is not determinate. This is because a scheduler running the system is free
to pick any active fibre to run when one is needed.

In the Felix implementation, a spawned fibre runs immediately
if the @{spawn_fthread} procedure is used to launch it, or the
running fibre continues instead, of @{schedule_fthread} is used instead.

In addition, I/O transfers always result in the reader proceeding,
to give it a chance to actually fetch the data before the write
might modify it.


@h2 next
stuff
@felix 
blah
@
stuff
@h1 high
blam
@h2 med1
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
@h2 med2
stuff
@h2 med3
stuff <em>inline html works</em>
but we have @{micros} for inline code as well.
<a href= https://www.itkservices2.com/nem_review_1.2>See ITK stuff</a>
@h3 low
level 3 stuff
@felix 
blah
@
stuff


