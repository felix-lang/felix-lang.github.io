@tangler ex1 = examples/ex1.flx
@tangler ex2 = examples/ex2.flx
@title coroutines
@h1 A low level example.
I will show a simple low level example of coroutines, it will be a 
simple pipeline consisting of a source, a transducer, a limiter, and a sink.

First we have our source, which just write all the integers starting from 0
down the channel @{out}. The type @{%>int} is an output channel endpoint
for @{int}.

@tangle ex1
proc source (out: %>int) () {
  var i = 0;
  while true do 
    write (out,i); 
    ++i; 
  done
}
@

Now we have a simple sink, which just prints everything it reads:
@tangle ex1
proc sink (inp: %<int) () {
  while true do 
    var i = read inp;
    println$ i;
  done
}
@
You should note the extra unit parameter @{()}. After the input is bound, the resulting
procedure will have type
@felix
unit -> unit
@
which is the type required to spawn fibre from a coroutine.

Now we have a transducer which writes the square of every integer it reads.
@tangle ex1
proc squarer (inp: %<int, out: %>int) () {
  while true do 
    var i = read inp;
    write (out, i * i);
  done
}
@

You should notice the previous three components were all infinite loops.
Since we don't want our demo to run forever we will throw in a limiter chip:
@tangle ex1
proc limiter (var limit: int) (inp: %<int, out: %>int) () {
  while limit > 0 do
    var i = read inp;
    write (out, i);
    --limit;
  done
}
@
This procedure drops through, but it cannot return control, because
there is nowhere to return it to, so it has, in effect, committed
suicide implicitly.

Now we need have four components so we need three channels to connect them:
@tangle ex1
proc run_pipeline() {
  // make channels
  var i1,o1 = mk_ioschannel_pair[int](); 
  var i2,o2 = mk_ioschannel_pair[int](); 
  var i3,o3 = mk_ioschannel_pair[int](); 

  // make coroutines by binding the channels
  var d1 = source(o1);
  var d2 = squarer(i1,o2);
  var d3 = limiter 8 (i2,o3);
  var d4 = sink (i3);

  // spawn coroutines as fibres
  spawn_fthread d1;
  spawn_fthread d2;
  spawn_fthread d3;
  spawn_fthread d4;
 
  // exit
}
run_pipeline();
@

Here is the complete program: <a href="https://github.com/felix-lang/felix-lang.github.io/blob/main/examples/ex1.flx">ex1.flx</a>
@h1 Using the chip DSSL
The code above involves a bit of boilerplate so I'm going to show you how to do the
same job using the <em>chip</em> DSSL. A DSSL is a unique feature of Felix which allows
the <em>user</em> to define an extension to the existing language, which has an application
in a specific domain. Unlike DSLs or domain specific languages, Felix has DSSLs or domain
specific <em>sub-</em>languages.

Let me show you: first our source:
@tangle ex2
chip source
  connector io
   pin out: %>int
{
  var i = 0;
  while true do 
    write (io.out,i); 
    ++i; 
  done
}
@
This is the same as before except that the channel name now has the form @{connector.pin} 
and so we put @{io.out} as the channel name. There is no magic here, the connector name
is the name of the parameter, and the pin names are fields of a record, so the parameter
actually has a record type.

Now here is the sink:
@tangle ex2
chip sink 
  connector io
    pin inp: %<int
{
  while true do 
    var i = read io.inp;
    println$ i;
  done
}
@
Now here is the transducer and limiter
@tangle ex2
chip squarer 
  connector io
    pin inp: %<int
    pin out: %>int
{
  while true do 
    var i = read io.inp;
    write (io.out, i * i);
  done
}
chip limiter (var limit: int) 
  connector io
    pin inp: %<int
    pin out: %>int
{
  while limit > 0 do
    var i = read io.inp;
    write (io.out, i);
    --limit;
  done
};
@
Now to connect these things we say this:
@tangle ex2
proc run_pipeline1() {
  device limit8  = limiter 8;
  circuit
    connect source.out, squarer.inp
    connect squarer.out, limit8.inp
    connect limit8.out, sink.inp
  endcircuit
}
run_pipeline1();
@
The @{circuit} statement connects all the chips into a circuit and runs it.
The most important feature here is that the chips are <em>anonymous</em>.
Note the @{connect} clause does not need to use the connector name,
it uses the first connector. This particular feature is implemented in the
compiler itself to allow I/O direction checking and exhaustion checking.
You cannot leave any pin disconnected.

The @{circuit} feature is very general. For pipelines there is an even easer
syntax:

@tangle ex2
proc run_pipeline2() { 
  (source |-> squarer |-> limiter 8 |-> sink)();
}
run_pipeline2();
@
For any functional programmers around, a pipeline is semantically identical
to a Monad.

@h1 The concept of fibration
A <em>coroutine system</em> is a collection of processes called <em>fibres</em>
with these properties:
<ul>
<li>Exactly one process can be <em>running</em> at once, the others are said to be <em>suspended</em></li>
<li>Control cannot be pre-empted, but is yielded voluntarily</li>
</ul>
In our system, there are four principle operations which yield control:
<ol>
<li><em>spawn</em> a new fibre</li>
<li><em>read</em> from a channel</li>
<li><em>write</em> to a channel</li>
<li>Commit <em>suicide</em>
</ol>
A fibre of control can be in one of five states:
<ol>
<li>Running</em>
<li>Active (but not running)</li>
<li>Waiting on read</li>
<li>Waiting on write</ii>
<li>Dead</li>
</ol>
In our system, all the resources associated by an <em>unreachable</em> dead
fibre are automatically reaped by the garbage collector so that in fact
the fibre is not technically dead because it no longer exists.

A <em>channel</em> is an object associated with which 
set of fibres all waiting to read or all waiting to write.

When a write operation is performed on a channel by the running fibre,
if there are fibres on the channel which are waiting to read
then one is selected, the data to be written is tranfered from the writer to the reader,
the fibre is removed from association with the channel,
and both the running and reader fibre are made active.
Otherwise if there is no readers waiting on the channel, the writer is 
suspended and put on the channel.

When a read operation is performed on a channel by the running fibre,
if there are fibres on the channel which are waiting to write
then one is selected, the data to be written is transfered from the writer to the reader, 
fibre, the fibre is removed from association with the channel,
and both the running and reader fibre are made active.
Otherwise if there is no writers waiting on the channel, the writer is 
suspended and put on the channel.

When a fibre commits suicide, it is removed as the running fibre.

When a new fibre is spawned, both the spawner and spawnee are made active.

When there is no running fibre, then if an active fibre exists,
an active fibre is selected and promoted to running state
and the thread of control begins executing it.

When there is no running fibre, and no active fibres,
the whole system terminates. Any fibres waiting on I/O become dead

The description above is a complete account of the abstract semantics
known as <em>Communicating Sequential Coroutines</em> or CSC, it is a
sub system obtain from Tony Hoare's <em>Communicating Sequenmtial Processes</em>
or CSP, in which concurrency is replaced by an indeterminate total ordering.

To be precise in CSC all events are totally ordered, however the exact ordering
is not determinate. This is because a scheduler running the system is free
to pick any active fibre to run when one is needed.

In the Felix implementation, a spawned fibre runs immediately
if the @{spawn_fthread} procedure is used to launch it, or the
running fibre continues instead, of @{schedule_fthread} is used instead.

In addition, I/O transfers always result in the reader proceeding,
to give it a chance to actually fetch the data before the write
might modify it.


@h2 next
stuff
@felix 
blah
@
stuff
@h1 high
blam
@h2 med1
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
@h2 med2
stuff
@h2 med3
stuff <em>inline html works</em>
but we have @{micros} for inline code as well.
<a href= https://www.itkservices2.com/nem_review_1.2>See ITK stuff</a>
@h3 low
level 3 stuff
@felix 
blah
@
stuff


