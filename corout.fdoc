@title coroutines
@h1 The concept of fibration
A <em>coroutine system</em> is a collection of processes called <em>fibres</em>
with these properties:
<ul>
<li>Exactly one process can be <em>running</em> at once, the others are said to be <em>suspended</em></li>
<li>Control cannot be pre-empted, but is yielded voluntarily</li>
</ul>
In our system, there are four principle operations:
<ol>
<li><em>spawn</em> a new fibre</li>
<li><em>read</em> from a channel</li>
<li><em>write</em> to a channel</li>
<li>Commit <em>suicide</em>
</ol>
A fibre of control can be in one of five states:
<ol>
<li>Running</em>
<li>Active (but not running)</li>
<li>Waiting on read</li>
<li>Waiting on write</ii>
<li>Dead</li>
</ol>
In our system, all the resources associated by an <em>unreachable</em> dead
fibre are automatically reaped by the garbage collector so that in fact
the fibre is not technically dead because it no longer exists.

A <em>channel</em> is an object associated with which 
set of fibres all waiting to read or all waiting to write.

When a write operation is performed on a channel by the running fibre,
if there are fibres on the channel which are waiting to read
then one is selected, the data to be written is tranfered from the writer to the reader,
the fibre is removed from association with the channel,
and both the running and reader fibre are made active.

When a read operation is performed on a channel by the running fibre,
if there are fibres on the channel which are waiting to write
then one is selected, the data to be written is transfered from the writer to the reader, 
fibre, the fibre is removed from association with the channel,
and both the running and reader fibre are made active.

When a fibre commits suicide, it is removed as the running fibre.

When a new fibre is spawned, both the spawner and spawnee are made active.

When there is no running fibre, then if an active fibre exists,
an active fibre is selected and promoted to running state
and the thread of control begins executing it.

When there is no running fibre, and no active fibres,
the whole system terminates. Any fibres waiting on I/O become dead

The description above is a complete account of the abstract semantics
known as <em>Communicating Sequential Coroutines</em> or CSC, it is a
sub system obtain from Tony Hoare's <em>Communicating Sequenmtial Processes</em>
or CSP, in which concurrency is replaced by an indeterminate total ordering.

To be precise in CSC all events are totally ordered, however the exact ordering
is not determinate. This is because a scheduler running the system is free
to pick any active fibre to run when one is needed.

In the Felix implementation, a spawned fibre runs immediately
if the @{spawn_fthread} procedure is used to launch it, or the
running fibre continues instead, of @{schedule_fthread} is used instead.

In addition, I/O transfers always result in the reader proceeding,
to give it a chance to actually fetch the data before the write
might modify it.


@h2 next
stuff
@felix 
blah
@
stuff
@h1 high
blam
@h2 med1
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
stuff
@h2 med2
stuff
@h2 med3
stuff <em>inline html works</em>
but we have @{micros} for inline code as well.
<a href= https://www.itkservices2.com/nem_review_1.2>See ITK stuff</a>
@h3 low
level 3 stuff
@felix 
blah
@
stuff


