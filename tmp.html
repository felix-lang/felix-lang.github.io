
<html><head>
<style type="text/css">
body {margin:3%; }
h1 {color:gray; font-size:120%;}
h2 {color:gray; font-size:105%;}
h3 {font-size:100%;}
h4 {font-size:95%;}
h5 {font-size:95%;}
span.fstring {color:darkblue; font-style:italic; }
span.comment {font-family:arial; color:blue; font-style:italic; }
span.doccomment {font-family:arial; color:green; font-style:italic; }
span.big_keyword {color:#FF1010; }
span.small_keyword {color:#802040; }
span.qualifier {color:#A02020; }
span.library {color:#A02000; }
span.ctor {color:#406020; }
span.hack {color:#66DD00; }
span.preproc {color:#005500; }
span.embedded_c{background-color:#DDDDDD; }
span.fpc_fieldname {color:#DD0000; }
span.lineno {color:#101010; background-color:#E0E0E0; font-size:80%; font-family:"courier",monospace; font-style:normal; }
pre.flxbg {background-color:#A0FFA0; color:black; padding:2px; box-shadow:5px 5px 2px #807080; }
pre.uncheckedflxbg {background-color:#D0D0D0; color:black; padding:2px; box-shadow:5px 5px 2px #807080; }
pre.cppbg {background-color:#80FF80; color:black; }
pre.prefmtbg {background-color:#D0D0D0; color:black; }
pre.expected {background-color:#E0FF80; color:black; }
pre.input {background-color:#E08080; color:black; }
pre.inclusion {background-color:#D070D0; color:black; }
code.inclusion {background-color:#D070D0; color:black; }
.obsolete { background-color:#FFEFEF; font-size: small; color:black; }
.future { background-color:#FF8080; font-size: small; color:black; }
.implementation_detail { background-color:#E0E0E0; font-size: small; color:black;  }
.bug { background-color:#FFE0E0; font-size: small; color:black; }
.fixed{ background-color:#FFE0E0; font-size: small; color:black; }
.done { background-color:#FFE0E0; font-size: small; color:black; }
.caveat { background-color:#FF8080; color:black; }
</style>
<title>I/O</title></head><body>
<style>
body {margin:3%; font-family: sans-serif; }
h1 {color:black; font-size:120%; border-bottom: 2px solid #ddd; padding: 0 0 3px 0;}
h2 {color:#202020; font-size:105%;}
h3 {font-size:100%;}
h4 {font-size:95%;}
h5 {font-size:95%;}
span.fstring {color:darkblue; font-style:italic; }
span.comment {font-family:arial; color:blue; font-style:italic; }
span.doccomment {font-family:arial; color:green; font-style:italic; }
span.big_keyword {color:#FF1010; }
span.small_keyword {color:#802040; }
span.qualifier {color:#A02020; }
span.library {color:#A02000; }
span.ctor {color:#406020; }
span.hack {color:#66DD00; }
span.preproc {color:#005500; }
span.embedded_c{background-color:#DDDDDD; }
span.fpc_fieldname {color:#DD0000; }
span.lineno {color:#101010; background-color:#E0E0E0; font-size:80%; font-family:"courier",monospace; font-style:normal; }
pre { border: 1px solid #ccc; color: black; box-shadow:3px 3px 2px rgba(0,0,0,0.1); padding:2px; }
pre.flxbg {background-color:#C2FDC2; box-shadow:3px 3px 2px rgba(0,0,0,0.1) }
pre.uncheckedflxbg {background-color:#eee; box-shadow:3px 3px 2px rgba(0,0,0,0.1); }
pre.cppbg {background-color:#C2FDC2; }
pre.prefmtbg {background-color:#F1F1F1; }
pre.expected {background-color:hsla(74,94%,88%,1); }
pre.input {background-color:hsla(20,94%,88%,1); }
pre.inclusion {
    font-family: Arial;
    font-weight: normal;
    font-size: 0.9em;
    color: #555;
    border: none;
    box-shadow: none;
    text-align: right;
    margin: -7px 11px -12px 0;
    padding: 0;
    background-color:#fafafa;
}
code.inclusion {background-color:#D070D0; color:black; }
.obsolete { background-color:#FFEFEF; font-size: small; color:black; }
.future { background-color:#FF8080; font-size: small; color:black; }
.implementation_detail { background-color:#E0E0E0; font-size: small; color:black;  }
.bug { background-color:#FFE0E0; font-size: small; color:black; }
.fixed{ background-color:#FFE0E0; font-size: small; color:black; }
.done { background-color:#FFE0E0; font-size: small; color:black; }
.caveat { background-color:hsla(0,100%,91%,1); color:black; padding: 0.6em; }
.container {
  position: fixed;
  top:0px;
  left:0px;
  height : 100%;
  width: 100%;
  background-color: grey;
  margin: 0px;
  padding: 0px;
  border-width: 0px;
  color: #404040;
}
.maincontent {
  padding:4px;
  padding-left:8px;
  line-height:1.3em;
  color:#404040; background-color:#fafafa;
}
.maincontent h1 { margin-left:-8px; position: relative; font-family: georgia, serif; font-size: 1.8em; font-weight: normal; }
.maincontent h2 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent h3 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent h4 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent code { color:#902030; }
.toppanel {
  position:absolute; left:0px; top:0px; height:20px; right:0px;
  background-color: #e0e0e0;
}
.bottompanel {
  position:absolute; left:0px; top:22px; bottom:0px; right:0px;
  background-color: #fafafa;
  font-size:14px;
}
.leftpanel {
  position:absolute; left:0px; top:0px; bottom:0px; width: 150px;
  background-color: #eaeaea; overflow: auto;
}
.rightpanel {
  position:absolute; right: 0px; left:160px; top:0px; bottom: 0px;
  background-color: #fafafa; overflow: auto;
}
.divider {
  position:absolute; left: 150px; top:0px; bottom:0px;
  background-color: black; width:2px;
  box-shadow: 0 0 8px #000;
}

#panemover {
    position:absolute;
    left: 150px;
    width : 10px;
    top: 0px;
    bottom: 0px;
    opacity: 0.3;
    cursor:col-resize;
}

div.m {
    margin: 0px;
    padding:0px;
    border-width:2px;
    border-color: green;
}

div.m1 {
    background-color: #86E870;
    border-style:outset;
    border-color:#ccc;
    border-width:2px 0;
    font-size:90%;
    padding: 1px 0 2px 10px;
}

div.m2 {
    background-color: #70C070;
    padding-left:15px;
    padding-top:2px;
    border-style:outset;
    border-color:green;
    border-width:0 0 1px 0;
    font-size:80%;
}

div.m1:hover, div.m2:hover {
    background-color: white;
}

#leftmargintoc a {
    text-decoration: none;
    color: #404040;
}
</style>

<style>
div.m {
    margin: 0px;
    padding:0px;
    border-width:2px;
    border-color: green;
}

div.m1 {
    background-color: #86E870;
    border-style:outset;
    border-color:#ccc;
    border-width:2px 0;
    font-size:90%;
    padding: 1px 0 2px 10px;
}

div.m2 {
    background-color: #70C070;
    padding-left:15px;
    padding-top:2px;
    border-style:outset;
    border-color:green;
    border-width:0 0 1px 0;
    font-size:80%;
}

div.m1:hover, div.m2:hover {
    background-color: white;
}

#leftmargintoc a {
    text-decoration: none;
    color: #404040;
}


</style>

    <script async="true">
      function dragStart(e, left, right){
        document.getElementById("panemover").style.width="70%";
        document.getElementById("panemover").style.left="50px";
        mousedown = true;
        x = e.clientX
        dragOffsetLeft =
          document.getElementById(left).getBoundingClientRect().right -
          document.getElementById(left).getBoundingClientRect().left -
          x
        ;
        dragOffsetDivider= document.getElementById("divider").getBoundingClientRect().left - x;
        dragOffsetRight = document.getElementById(right).getBoundingClientRect().left - x;
      }
      function dragRelease(){
        document.getElementById('panemover').style.width = '10px';
        document.getElementById('panemover').style.left = document.getElementById('divider').offsetLeft + 'px';
        mousedown = false;
      }
      function drag(e, left, right){
        if(!mousedown){return}
        x = e.clientX
        tmpLeft = dragOffsetLeft + x
        tmpDivider= dragOffsetDivider + x
        tmpRight = dragOffsetRight + x
        document.getElementById(left).style.width= tmpLeft + 'px';
        document.getElementById("divider").style.left= tmpDivider + 'px';
        document.getElementById(right).style.left = tmpRight + 'px';
      };
    </script>

<script type="text/javascript">

  function mexpand(id)
  {
    var n = document.getElementById(id).style;
    n.display = "block";
  }

  function mcollapse(id)
  {
    var n = document.getElementById(id).style;
    n.display = "none";
  }

  var counter_max = 0;
  function mshow(id,loc)
  {
    var i;
    for(i=1; i<=counter_max; ++i)
      mcollapse("menu"+String(i));
    mexpand(id);
    window.location.replace(loc);
  }
</script>

<script type="text/javascript">

function expand(but,id)
{
  var n = document.getElementById(id).style;
  var button = document.getElementById(but);
  button.src = "/share/src/web/images/minus.gif";
  button.alt = "-";
  n.display = "block";
}
function collapse(but,id)
{
  var n = document.getElementById(id).style;
  var button = document.getElementById(but);
  button.src = "/share/src/web/images/plus.gif";
  button.alt = "+";
  n.display = "none";
}
function toggle(button,id)
{
  var n = document.getElementById(id).style;
  if (n.display == "none")
  {
    button.src = "/share/src/web/images/minus.gif";
    button.alt = "-";
    n.display = "block";
  }
  else
  {
    button.src = "/share/src/web/images/plus.gif";
    button.alt = "+";
    n.display = "none";
  }
}
var allbuttons = [
"Core RTL support",
"Standard Library Synopsis",
"Simple Text I/O",
"Ansi Terminal",
"Stream I/O",
"TCP/IP Sockets",
"Posix sockets",
"Windows sockets",
"Host sockets",
"Demux: Felix Event notification service",
"Faio: Felix Asynchronous I/O service",
"Posix Faio",
"Win32 Faio"
];
function expand_all(dummy)
{
  for (i in allbuttons)
  {
    expand(allbuttons[i], allbuttons[i]+"_d");
  }
}
function collapse_all(dummy)
{
  for (i in allbuttons)
  {
    collapse(allbuttons[i], allbuttons[i]+"_d");
  }
}
</script>

<script>
function mouseover(id)
{
  var elt = document.getElementById(id);
  elt.style.display="none";
  var elt2 = document.getElementById(id+"_mo");
  elt2.style.display="inline";
}

function mouseout(id)
{
  var elt = document.getElementById(id+"_mo");
  elt.style.display="none";
  var elt2 = document.getElementById(id);
  elt2.style.display="inline";
}

</script>
<script> function nop(dummy) {} </script>
    <div class="container">
      <div class="toppanel">
    <!--Main Content top navbar-->
<span style="position:relative; bottom:6px"
  onmouseover="mouseover('expand')"
  onmouseout="mouseout('expand')"
  onclick="expand_all('expand')"
  ><span id="expand"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:blue;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Expand</text></svg></span><span id="expand_mo" style="display:none"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:red;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Expand</text></svg></span></span><span style="position:relative; bottom:6px"
  onmouseover="mouseover('collapse')"
  onmouseout="mouseout('collapse')"
  onclick="collapse_all('collapse')"
  ><span id="collapse"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:blue;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Collapse</text></svg></span><span id="collapse_mo" style="display:none"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:red;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Collapse</text></svg></span></span>    <!--Main Content top navbar End-->

      </div> <!-- toppanel end -->
      <div class="bottompanel">
        <span id="divider" class="divider"></span>

        <span id="left" class="leftpanel" >
          <div class="menucontent">
  <!--Left Margin Toc-->
  <div id="leftmargintoc">
    <!--Left Margin Toc Main Contents-->
      <div class=m1 onclick="mshow('menu1','#Core RTL support_h')"> <a href="#Core_RTL_support_h">Core RTL support</a></div>
      <div class=sm id=menu1>
      </div>
      <div class=m1 onclick="mshow('menu2','#Standard Library Synopsis_h')"> <a href="#Standard_Library_Synopsis_h">Standard Library Synopsis</a></div>
      <div class=sm id=menu2>
      </div>
      <div class=m1 onclick="mshow('menu3','#Simple Text I/O_h')"> <a href="#Simple_Text_I/O_h">Simple Text I/O</a></div>
      <div class=sm id=menu3>
      </div>
      <div class=m1 onclick="mshow('menu4','#Ansi Terminal_h')"> <a href="#Ansi_Terminal_h">Ansi Terminal</a></div>
      <div class=sm id=menu4>
      </div>
      <div class=m1 onclick="mshow('menu5','#Stream I/O_h')"> <a href="#Stream_I/O_h">Stream I/O</a></div>
      <div class=sm id=menu5>
      </div>
      <div class=m1 onclick="mshow('menu6','#TCP/IP Sockets_h')"> <a href="#TCP/IP_Sockets_h">TCP/IP Sockets</a></div>
      <div class=sm id=menu6>
      </div>
      <div class=m1 onclick="mshow('menu7','#Posix sockets_h')"> <a href="#Posix_sockets_h">Posix sockets</a></div>
      <div class=sm id=menu7>
      </div>
      <div class=m1 onclick="mshow('menu8','#Windows sockets_h')"> <a href="#Windows_sockets_h">Windows sockets</a></div>
      <div class=sm id=menu8>
      </div>
      <div class=m1 onclick="mshow('menu9','#Host sockets_h')"> <a href="#Host_sockets_h">Host sockets</a></div>
      <div class=sm id=menu9>
      </div>
      <div class=m1 onclick="mshow('menu10','#Demux: Felix Event notification service_h')"> <a href="#Demux:_Felix_Event_notification_service_h">Demux: Felix Event notification service</a></div>
      <div class=sm id=menu10>
      </div>
      <div class=m1 onclick="mshow('menu11','#Faio: Felix Asynchronous I/O service_h')"> <a href="#Faio:_Felix_Asynchronous_I/O_service_h">Faio: Felix Asynchronous I/O service</a></div>
      <div class=sm id=menu11>
      </div>
      <div class=m1 onclick="mshow('menu12','#Posix Faio_h')"> <a href="#Posix_Faio_h">Posix Faio</a></div>
      <div class=sm id=menu12>
      </div>
      <div class=m1 onclick="mshow('menu13','#Win32 Faio_h')"> <a href="#Win32_Faio_h">Win32 Faio</a></div>
      <div class=sm id=menu13>
      </div>
    <script>counter_max=13;</script>
  </div>
  <!--End Left Margin Toc-->

          </div> <!-- leftpanel contents end -->
        </span> <!-- leftpanel end -->

        <span id="right" class="rightpanel">
          <div class="maincontent">
<!--Main Content Body-->
<h1 id='Core_RTL_support_h'><img src='/share/src/web/images/minus.gif' id='Core RTL support' onclick='toggle(this,"Core_RTL_support_d")' alt='+'/> 1 Core RTL support</h1><div id='Core_RTL_support_d' style='display:block'>
<p>Basic routines built on C <code>FILE*</code> and C++ <code>iostreams</code>.
Provides portability, and some conveniences regarding
line handling and string handling.
</p><p>These routines all use binary I/O but are designed
specifically for basic text I/O. Error handling
is minimal, these are mainly for simple jobs and
debugging.
</p><pre class='inclusion'>
share/lib/rtl/flx_ioutil.hpp</pre>
<p><pre class='cppbg'>#<span class="preproc">ifndef</span> FLX_IOUTIL
#<span class="preproc">define</span> FLX_IOUTIL
#<span class="preproc">include</span> <span class="fstring">&lt;string&gt;</span>
#<span class="preproc">include</span> <span class="fstring">&lt;cstdio&gt;</span>
#<span class="preproc">include</span> <span class="fstring">"flx_rtl_config.hpp"</span>

<span class="big_keyword">namespace</span> flx { <span class="big_keyword">namespace</span> rtl { <span class="big_keyword">namespace</span> ioutil {
  RTL_EXTERN ::<span class="small_keyword">std</span>::string load_file (::<span class="small_keyword">std</span>::string);
  RTL_EXTERN ::<span class="small_keyword">std</span>::string load_text_file (::<span class="small_keyword">std</span>::string);

  RTL_EXTERN ::<span class="small_keyword">std</span>::string load_file (::<span class="small_keyword">std</span>::FILE *);
  RTL_EXTERN <span class="qualifier">int</span> flx_fileno(::<span class="small_keyword">std</span>::FILE*);
  RTL_EXTERN bool flx_isatty(::<span class="small_keyword">std</span>::FILE*);
  RTL_EXTERN bool flx_isstdin(::<span class="small_keyword">std</span>::FILE*);
  RTL_EXTERN bool flx_isconsole(::<span class="small_keyword">std</span>::FILE*);
  RTL_EXTERN ::<span class="small_keyword">std</span>::string raw_readln(::<span class="small_keyword">std</span>::FILE*);
  RTL_EXTERN ::<span class="small_keyword">std</span>::string raw_read(::<span class="small_keyword">std</span>::FILE*, ::<span class="small_keyword">std</span>::size_t);
  RTL_EXTERN ::<span class="small_keyword">std</span>::string echo_readln(::<span class="small_keyword">std</span>::FILE*);
  RTL_EXTERN ::<span class="small_keyword">std</span>::string readln(::<span class="small_keyword">std</span>::FILE*);
  RTL_EXTERN <span class="qualifier">void</span> write (::<span class="small_keyword">std</span>::FILE *, ::<span class="small_keyword">std</span>::string);
  RTL_EXTERN <span class="qualifier">void</span> writeln (::<span class="small_keyword">std</span>::FILE *, ::<span class="small_keyword">std</span>::string);

  RTL_EXTERN ::<span class="small_keyword">std</span>::string load_file (::<span class="small_keyword">std</span>::istream*);
  RTL_EXTERN ::<span class="small_keyword">std</span>::string readln(::<span class="small_keyword">std</span>::istream*);
  RTL_EXTERN <span class="qualifier">void</span> write (::<span class="small_keyword">std</span>::ostream*, ::<span class="small_keyword">std</span>::string);
  RTL_EXTERN <span class="qualifier">void</span> writeln (::<span class="small_keyword">std</span>::ostream*, ::<span class="small_keyword">std</span>::string);
}}}
#<span class="preproc">endif</span>
</pre></p><pre class='inclusion'>
share/src/rtl/flx_ioutil.cpp</pre>
<p><pre class='cppbg'>
#<span class="preproc">include</span> <span class="fstring">&lt;cstdio&gt;</span>
#<span class="preproc">include</span> <span class="fstring">&lt;cstring&gt;</span>
#<span class="preproc">include</span> <span class="fstring">&lt;string&gt;</span>
#<span class="preproc">include</span> <span class="fstring">&lt;iostream&gt;</span>
#<span class="preproc">include</span> <span class="fstring">&lt;cassert&gt;</span>
#<span class="preproc">include</span> <span class="fstring">"flx_ioutil.hpp"</span>

#<span class="small_keyword">if</span> FLX_WIN32
#<span class="preproc">include</span> <span class="fstring">&lt;io.h&gt;</span>
#<span class="preproc">else</span>
#<span class="preproc">include</span> <span class="fstring">&lt;unistd.h&gt;</span>
#<span class="preproc">endif</span>

<span class="big_keyword">namespace</span> flx { <span class="big_keyword">namespace</span> rtl { <span class="big_keyword">namespace</span> ioutil {
  using <span class="big_keyword">namespace</span> <span class="small_keyword">std</span>;


#<span class="small_keyword">if</span> FLX_WIN32
  <span class="qualifier">int</span> flx_fileno (FILE *f) { <span class="small_keyword">return</span> _fileno (f); }
  bool flx_isatty(<span class="qualifier">int</span> fd) { <span class="small_keyword">return</span> 1 == _isatty (fd); }
#<span class="preproc">else</span>
  <span class="qualifier">int</span> flx_fileno (FILE *f) { <span class="small_keyword">return</span> fileno (f); }
  bool flx_isatty(<span class="qualifier">int</span> fd) { <span class="small_keyword">return</span> 1 == isatty (fd); }
#<span class="preproc">endif</span>

  bool flx_isatty (FILE *f) 
  {
    <span class="small_keyword">return</span> 1 == flx_isatty (flx_fileno (f));
  }

  bool flx_isstdin (FILE *f)
  {
    <span class="small_keyword">return</span> flx_fileno (f) == 0;
  }

  bool flx_isconsole (FILE *f)
  {
    <span class="small_keyword">return</span> flx_isstdin (f) &amp;&amp; flx_isatty(f);
  }


<span class="comment">/* small buffer for testing, should be much large in production version **</span>/
#<span class="preproc">define</span> MYBUFSIZ 51200

  string load_file (string f)
  {
    <span class="qualifier">char</span> <span class="qualifier">const</span> *fname = f.c_str();

    FILE *fi = fopen(fname,<span class="fstring">"rb"</span>); <span class="comment">// note: binary mode!
</span>
    <span class="small_keyword">if</span> (fi)
    {
      string x = <span class="fstring">""</span>;
      <span class="qualifier">char</span> buffer[MYBUFSIZ];
      <span class="small_keyword">while</span> (!feof(fi)) {
        ::<span class="small_keyword">std</span>::size_t n = fread(buffer,1,MYBUFSIZ,fi);
        <span class="small_keyword">if</span>(n&gt;0) x += string(buffer,n);
        else break;
      }
      fclose(fi);
      <span class="small_keyword">return</span> x;
    }
    else <span class="small_keyword">return</span> <span class="fstring">""</span>;
  }

  string load_text_file (string f)
  {
    <span class="qualifier">char</span> <span class="qualifier">const</span> *fname = f.c_str();

    FILE *fi = fopen(fname,<span class="fstring">"rt"</span>); <span class="comment">// note: text mode
</span>
    <span class="small_keyword">if</span> (fi)
    {
      string x = <span class="fstring">""</span>;
      <span class="qualifier">char</span> buffer[MYBUFSIZ];
      <span class="small_keyword">while</span> (!feof(fi)) {
        ::<span class="small_keyword">std</span>::size_t n = fread(buffer,1,MYBUFSIZ,fi);
        <span class="small_keyword">if</span>(n&gt;0) x += string(buffer,n);
        else break;
      }
      fclose(fi);
      <span class="small_keyword">return</span> x;
    }
    else <span class="small_keyword">return</span> <span class="fstring">""</span>;
  }


<span class="comment">// C FILE IO
</span>
  string load_file (FILE *fi) <span class="comment">// note does NOT close file! (would screw up popen)
</span>  {
    <span class="small_keyword">if</span> (fi)
    {
      string x = <span class="fstring">""</span>;
      <span class="qualifier">char</span> buffer[MYBUFSIZ];
      <span class="small_keyword">while</span> (!feof(fi)) {
        ::<span class="small_keyword">std</span>::size_t n = fread(buffer,1,MYBUFSIZ,fi);
        <span class="small_keyword">if</span>(n&gt;0) x = x + string(buffer,n);
        else break;
      }
      <span class="small_keyword">return</span> x;
    }
    else <span class="small_keyword">return</span> <span class="fstring">""</span>;
  }

  <span class="comment">// includes newline if present
</span>  <span class="comment">// null string indicates end of file
</span>  string raw_readln (FILE *fi)
  {
    <span class="small_keyword">if</span>(fi)
    {
      string x = <span class="fstring">""</span>;
      <span class="qualifier">char</span> buffer[MYBUFSIZ+1];
      buffer[MYBUFSIZ]=<span class="fstring">'\0'</span>;
next:
      bool eof = fgets(buffer, MYBUFSIZ, fi) == 0;
      <span class="small_keyword">if</span>(eof) <span class="small_keyword">return</span> x;
      x += string(buffer);
      <span class="small_keyword">if</span>(x[x.size()-1]==<span class="fstring">'\n'</span>) <span class="small_keyword">return</span> x;
      <span class="small_keyword">goto</span> next;
    }
    else <span class="small_keyword">return</span> <span class="fstring">""</span>;
  }

  <span class="comment">// read up to n bytes
</span>  string raw_read (FILE *fi, ::<span class="small_keyword">std</span>::size_t n)
  {
    <span class="qualifier">void</span> *buffer = <span class="small_keyword">std</span>::malloc(n);
    ::<span class="small_keyword">std</span>::size_t m = fread (buffer, 1, n, fi);
    string s((<span class="qualifier">char</span> <span class="qualifier">const</span>*)buffer,m);
    free(buffer);
    <span class="small_keyword">return</span> s;
  }

  string echo_readln (FILE *f)
  {
    string result = raw_readln (f);
    printf (<span class="fstring">"%s"</span>,result.c_str());
    <span class="small_keyword">return</span> result;
  }

  string readln (FILE *f) { 
    bool doecho = flx_isstdin(f) &amp;&amp; !flx_isatty (f);
    <span class="small_keyword">if</span> (doecho)
       <span class="small_keyword">return</span> echo_readln(f);
    else
       <span class="small_keyword">return</span> raw_readln (f);
  }

  <span class="qualifier">void</span> write (FILE *fi, string s)
  {
    fwrite(s.data(),s.size(),1,fi);
  }

  <span class="qualifier">static</span> <span class="qualifier">const</span> <span class="qualifier">char</span> eol[] = { <span class="fstring">'\n'</span> };

  <span class="qualifier">void</span> writeln (FILE *fi, string s)
  {
    fwrite(s.data(),s.size(),1,fi);
    fwrite(eol,sizeof(eol),1,fi);
  }

<span class="comment">// C++ file IO
</span>
  string load_file (istream *fi) <span class="comment">// note does NOT close file! (would screw up popen)
</span>  {
    <span class="small_keyword">if</span> (fi)
    {
      string x = <span class="fstring">""</span>;
      <span class="qualifier">char</span> buffer[MYBUFSIZ];
more:
      fi-&gt;read(buffer,MYBUFSIZ);
      <span class="qualifier">int</span> n = fi-&gt;gcount();
      <span class="small_keyword">if</span>(n&gt;0) x = x + string(buffer,n);
      <span class="small_keyword">if</span> (n == MYBUFSIZ)<span class="small_keyword">goto</span> more;
      <span class="small_keyword">return</span> x;
    }
    else <span class="small_keyword">return</span> <span class="fstring">""</span>;
  }

  <span class="comment">// includes newline if present
</span>  <span class="comment">// null string indicates end of file
</span>  string readln (istream *fi)
  {
    <span class="small_keyword">if</span>(fi)
    {
      ::<span class="small_keyword">std</span>::string x = <span class="fstring">""</span>;
      ::<span class="small_keyword">std</span>::getline(*fi,x);
      <span class="small_keyword">if</span> (fi-&gt;fail()) <span class="small_keyword">return</span> x; 
      else <span class="small_keyword">return</span> x+<span class="fstring">"\n"</span>;
    }
    else <span class="small_keyword">return</span> <span class="fstring">""</span>;
  }

  <span class="qualifier">void</span> write (ostream *fi, string s)
  {
    fi-&gt;write(s.data(),s.size());
  }

  <span class="qualifier">void</span> writeln (ostream *fi, string s)
  {
    fi-&gt;write(s.data(),s.size());
    fi-&gt;write(eol,sizeof(eol));
  }
}}}
</pre></p><pre class='inclusion'>
$PWD/src/config/flx_ioutil.fpc</pre>
<p><pre class="prefmtbg">Name: flx_ioutil
Description: I/O support
includes: '"flx_ioutil.hpp"'
Requires: flx
</pre></p></div><h1 id='Standard_Library_Synopsis_h'><img src='/share/src/web/images/minus.gif' id='Standard Library Synopsis' onclick='toggle(this,"Standard_Library_Synopsis_d")' alt='+'/> 2 Standard Library Synopsis</h1><div id='Standard_Library_Synopsis_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/io/__init__.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Include a Felix file">include</span> <span class="fstring">"std/io/textio"</span>;
<span class="lineno" id=line3></span>  <span class="big_keyword" title="Include a Felix file">include</span> <span class="fstring">"std/io/demux"</span>;
<span class="lineno" id=line4></span>  <span class="big_keyword" title="Include a Felix file">include</span> <span class="fstring">"std/io/faio"</span>;
<span class="lineno" id=line5></span>  <span class="big_keyword" title="Include a Felix file">include</span> <span class="fstring">"std/io/socket"</span>;
<span class="lineno" id=line6></span>  <span class="big_keyword" title="Include a Felix file">include</span> <span class="fstring">"std/io/iostream"</span>;
<span class="lineno" id=line7></span>  <span class="big_keyword" title="Include a Felix file">include</span> <span class="fstring">"std/io/ansi_terminal"</span>;
<span class="lineno" id=line8></span>  <span class="big_keyword" title="Include a Felix file">include</span> <span class="fstring">"std/io/filename"</span>;
<span class="lineno" id=line9></span>  <span class="big_keyword" title="Include a Felix file">include</span> <span class="fstring">"std/io/filestat"</span>;
<span class="lineno" id=line10></span>  <span class="big_keyword" title="Include a Felix file">include</span> <span class="fstring">"std/io/directory"</span>;
<span class="lineno" id=line11></span>  <span class="big_keyword" title="Include a Felix file">include</span> <span class="fstring">"std/io/filesystem"</span>;
<span class="lineno" id=line12></span>  
</pre></p></div><h1 id='Simple_Text_I/O_h'><img src='/share/src/web/images/minus.gif' id='Simple Text I/O' onclick='toggle(this,"Simple_Text_I/O_d")' alt='+'/> 3 Simple Text I/O</h1><div id='Simple_Text_I/O_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/io/textio.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="doccomment">These classes provide simple I/O for text, primarily intended for</span>
<span class="lineno" id=line3></span>  <span class="doccomment">naive use, debugging etc. This is because there is no error</span>
<span class="lineno" id=line4></span>  <span class="doccomment">handling. This simplifies usage at the expense of correctness,</span>
<span class="lineno" id=line5></span>  <span class="doccomment">and so these routines should not be used in production code.</span>
<span class="lineno" id=line6></span>  
<span class="lineno" id=line7></span>  <span class="doccomment">Abstract input file.</span>
<span class="lineno" id=line8></span>  <span class="big_keyword" title="Define a type class">class</span> Input_file[input_file]
<span class="lineno" id=line9></span>  {
<span class="lineno" id=line10></span>    <span class="doccomment">Open file for reading.</span>
<span class="lineno" id=line11></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> raw_fopen_input: <span class="library" title="binding of C++ string type">string</span> -&gt; input_file; 
<span class="lineno" id=line12></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> raw_fopen_input_text: <span class="library" title="binding of C++ string type">string</span> -&gt; input_file; 
<span class="lineno" id=line13></span>  
<span class="lineno" id=line14></span>    <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> fopen_input_text (f:<span class="library" title="binding of C++ string type">string</span>) : input_file =
<span class="lineno" id=line15></span>    {
<span class="lineno" id=line16></span>      <span class="small_keyword" title="conditional">if</span> Env::getenv <span class="fstring">"FLX_FILE_MONITOR"</span> != <span class="fstring">""</span> <span class="small_keyword" title="call a procedure">call</span>
<span class="lineno" id=line17></span>        eprintln$ <span class="fstring">"[Open_input_text] "</span> + f
<span class="lineno" id=line18></span>      ;
<span class="lineno" id=line19></span>      <span class="small_keyword" title="return">return</span> raw_fopen_input_text f;
<span class="lineno" id=line20></span>    }
<span class="lineno" id=line21></span>  
<span class="lineno" id=line22></span>    <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> fopen_input (f:<span class="library" title="binding of C++ string type">string</span>) : input_file =
<span class="lineno" id=line23></span>    {
<span class="lineno" id=line24></span>      <span class="small_keyword" title="conditional">if</span> Env::getenv <span class="fstring">"FLX_FILE_MONITOR"</span> != <span class="fstring">""</span> <span class="small_keyword" title="call a procedure">call</span>
<span class="lineno" id=line25></span>        eprintln$ <span class="fstring">"[Open_input] "</span> + f
<span class="lineno" id=line26></span>      ;
<span class="lineno" id=line27></span>      <span class="small_keyword" title="return">return</span> raw_fopen_input f;
<span class="lineno" id=line28></span>    }
<span class="lineno" id=line29></span>  
<span class="lineno" id=line30></span>    <span class="doccomment">Check if the file was opened correctly.</span>
<span class="lineno" id=line31></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> valid : input_file -&gt; bool;
<span class="lineno" id=line32></span>   
<span class="lineno" id=line33></span>    <span class="doccomment">Close file.</span>
<span class="lineno" id=line34></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> fclose: input_file;
<span class="lineno" id=line35></span>  
<span class="lineno" id=line36></span>    <span class="doccomment">Load the rest of an open file.</span>
<span class="lineno" id=line37></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> load: input_file -&gt; <span class="library" title="binding of C++ string type">string</span>;
<span class="lineno" id=line38></span>  
<span class="lineno" id=line39></span>    <span class="doccomment">Read one line with the trailing end-line mark included.</span>
<span class="lineno" id=line40></span>    <span class="doccomment">Empty string indicates end of file.</span>
<span class="lineno" id=line41></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> <span class="library" title="Read a string from a stream including trailing newline">readln</span>: input_file -&gt; <span class="library" title="binding of C++ string type">string</span>;
<span class="lineno" id=line42></span>  
<span class="lineno" id=line43></span>    <span class="comment">// read up to n bytes from file</span>
<span class="lineno" id=line44></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> read: input_file * <span class="library" title="binding of C size_t type">size</span> -&gt; <span class="library" title="binding of C++ string type">string</span>;
<span class="lineno" id=line45></span>  
<span class="lineno" id=line46></span>    <span class="doccomment">Read line excluding end of line marks.</span>
<span class="lineno" id=line47></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> iterator(f:input_file) (): <span class="library" title="option type: Some x or None">opt</span>[<span class="library" title="binding of C++ string type">string</span>] =&gt; 
<span class="lineno" id=line48></span>      <span class="small_keyword" title="match statement or expression">match</span> <span class="library" title="Read a string from a stream including trailing newline">readln</span> f <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line49></span>      | <span class="fstring">""</span> =&gt; None[<span class="library" title="binding of C++ string type">string</span>]
<span class="lineno" id=line50></span>      | text =&gt; text.rstrip.Some
<span class="lineno" id=line51></span>      <span class="small_keyword" title="end a match statement or expression">endmatch</span>
<span class="lineno" id=line52></span>    ;
<span class="lineno" id=line53></span>  
<span class="lineno" id=line54></span>    <span class="comment">/*
<span class="lineno" id=line55></span>    instance Iterable[input_file, string] {
<span class="lineno" id=line56></span>       gen iterator (f:input_file) () =&gt; Input_file[input_file]::iterator f ();
<span class="lineno" id=line57></span>    }
<span class="lineno" id=line58></span>    */</span>
<span class="lineno" id=line59></span>  
<span class="lineno" id=line60></span>    <span class="doccomment">Check for end of file.</span>
<span class="lineno" id=line61></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> feof : input_file -&gt; bool;
<span class="lineno" id=line62></span>  }
<span class="lineno" id=line63></span>  
<span class="lineno" id=line64></span>  <span class="doccomment">Abstract output file.</span>
<span class="lineno" id=line65></span>  <span class="big_keyword" title="Define a type class">class</span> Output_file[output_file]
<span class="lineno" id=line66></span>  {
<span class="lineno" id=line67></span>    <span class="doccomment">Open file for writing.</span>
<span class="lineno" id=line68></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> raw_fopen_output: <span class="library" title="binding of C++ string type">string</span> -&gt; output_file;
<span class="lineno" id=line69></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> raw_fopen_output_text: <span class="library" title="binding of C++ string type">string</span> -&gt; output_file;
<span class="lineno" id=line70></span>  
<span class="lineno" id=line71></span>    <span class="doccomment">Open file for writing in append-only mode.</span>
<span class="lineno" id=line72></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> raw_fopen_append: <span class="library" title="binding of C++ string type">string</span> -&gt; output_file;
<span class="lineno" id=line73></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> raw_fopen_append_text: <span class="library" title="binding of C++ string type">string</span> -&gt; output_file;
<span class="lineno" id=line74></span>  
<span class="lineno" id=line75></span>    <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> fopen_output(f:<span class="library" title="binding of C++ string type">string</span>) : output_file =
<span class="lineno" id=line76></span>    {
<span class="lineno" id=line77></span>      <span class="small_keyword" title="conditional">if</span> Env::getenv <span class="fstring">"FLX_FILE_MONITOR"</span> != <span class="fstring">""</span> <span class="small_keyword" title="call a procedure">call</span>
<span class="lineno" id=line78></span>        eprintln$ <span class="fstring">"[Open_output] "</span> + f
<span class="lineno" id=line79></span>      ;
<span class="lineno" id=line80></span>      <span class="small_keyword" title="return">return</span> raw_fopen_output f;
<span class="lineno" id=line81></span>    }
<span class="lineno" id=line82></span>  
<span class="lineno" id=line83></span>    <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> fopen_output_text(f:<span class="library" title="binding of C++ string type">string</span>) : output_file =
<span class="lineno" id=line84></span>    {
<span class="lineno" id=line85></span>      <span class="small_keyword" title="conditional">if</span> Env::getenv <span class="fstring">"FLX_FILE_MONITOR"</span> != <span class="fstring">""</span> <span class="small_keyword" title="call a procedure">call</span>
<span class="lineno" id=line86></span>        eprintln$ <span class="fstring">"[Open_output_text] "</span> + f
<span class="lineno" id=line87></span>      ;
<span class="lineno" id=line88></span>      <span class="small_keyword" title="return">return</span> raw_fopen_output_text f;
<span class="lineno" id=line89></span>    }
<span class="lineno" id=line90></span>  
<span class="lineno" id=line91></span>    <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> fopen_append(f:<span class="library" title="binding of C++ string type">string</span>) : output_file =
<span class="lineno" id=line92></span>    {
<span class="lineno" id=line93></span>      <span class="small_keyword" title="conditional">if</span> Env::getenv <span class="fstring">"FLX_FILE_MONITOR"</span> != <span class="fstring">""</span> <span class="small_keyword" title="call a procedure">call</span>
<span class="lineno" id=line94></span>        eprintln$ <span class="fstring">"[Open_append] "</span> + f
<span class="lineno" id=line95></span>      ;
<span class="lineno" id=line96></span>      <span class="small_keyword" title="return">return</span> raw_fopen_append f;
<span class="lineno" id=line97></span>    }
<span class="lineno" id=line98></span>  
<span class="lineno" id=line99></span>    <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> fopen_output_append_text(f:<span class="library" title="binding of C++ string type">string</span>) : output_file =
<span class="lineno" id=line100></span>    {
<span class="lineno" id=line101></span>      <span class="small_keyword" title="conditional">if</span> Env::getenv <span class="fstring">"FLX_FILE_MONITOR"</span> != <span class="fstring">""</span> <span class="small_keyword" title="call a procedure">call</span>
<span class="lineno" id=line102></span>        eprintln$ <span class="fstring">"[Open_output_append_text] "</span> + f
<span class="lineno" id=line103></span>      ;
<span class="lineno" id=line104></span>      <span class="small_keyword" title="return">return</span> raw_fopen_append_text f;
<span class="lineno" id=line105></span>    }
<span class="lineno" id=line106></span>  
<span class="lineno" id=line107></span>    <span class="doccomment">Check if the file was opened correctly.</span>
<span class="lineno" id=line108></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> valid : output_file -&gt; bool;
<span class="lineno" id=line109></span>   
<span class="lineno" id=line110></span>    <span class="doccomment">Close file.</span>
<span class="lineno" id=line111></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> fclose: output_file;
<span class="lineno" id=line112></span>  
<span class="lineno" id=line113></span>    <span class="doccomment">Write one line adding the trailing end line mark.</span>
<span class="lineno" id=line114></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> writeln : output_file * <span class="library" title="binding of C++ string type">string</span>;
<span class="lineno" id=line115></span>  
<span class="lineno" id=line116></span>    <span class="doccomment">Write a string.</span>
<span class="lineno" id=line117></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> <span class="library" title="Print a string to a stream">write</span> : output_file * <span class="library" title="binding of C++ string type">string</span>;
<span class="lineno" id=line118></span>  
<span class="lineno" id=line119></span>    <span class="doccomment">Write a byte.</span>
<span class="lineno" id=line120></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> <span class="library" title="Print a string to a stream">write</span> : output_file * <span class="library" title="binding of C unsigned char type">utiny</span>;
<span class="lineno" id=line121></span>  
<span class="lineno" id=line122></span>    <span class="doccomment">Write a char.</span>
<span class="lineno" id=line123></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> <span class="library" title="Print a string to a stream">write</span> : output_file * <span class="library" title="binding of C char type">char</span>;
<span class="lineno" id=line124></span>  
<span class="lineno" id=line125></span>    <span class="doccomment">Flush the buffers.</span>
<span class="lineno" id=line126></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> fflush: output_file;
<span class="lineno" id=line127></span>  
<span class="lineno" id=line128></span>    <span class="doccomment">Save string to file</span>
<span class="lineno" id=line129></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> save (fn:<span class="library" title="binding of C++ string type">string</span>, d:<span class="library" title="binding of C++ string type">string</span>) 
<span class="lineno" id=line130></span>    {
<span class="lineno" id=line131></span>      <span class="small_keyword" title="conditional">if</span> Env::getenv <span class="fstring">"FLX_FILE_MONITOR"</span> != <span class="fstring">""</span> <span class="small_keyword" title="call a procedure">call</span>
<span class="lineno" id=line132></span>        eprintln$ <span class="fstring">"[save] "</span> + fn
<span class="lineno" id=line133></span>      ;
<span class="lineno" id=line134></span>      <span class="big_keyword" title="Define a mutable variable">var</span> f = fopen_output fn;
<span class="lineno" id=line135></span>      <span class="library" title="Print a string to a stream">write</span>$ f,d;
<span class="lineno" id=line136></span>      fclose f;
<span class="lineno" id=line137></span>    }
<span class="lineno" id=line138></span>  
<span class="lineno" id=line139></span>    <span class="comment">// save list of strings to file</span>
<span class="lineno" id=line140></span>    <span class="comment">// adds a newline to each string in list</span>
<span class="lineno" id=line141></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> save (fn:<span class="library" title="binding of C++ string type">string</span>, lines:<span class="library" title="functional, singly linked list">list</span>[<span class="library" title="binding of C++ string type">string</span>]) 
<span class="lineno" id=line142></span>    {
<span class="lineno" id=line143></span>      <span class="small_keyword" title="conditional">if</span> Env::getenv <span class="fstring">"FLX_FILE_MONITOR"</span> != <span class="fstring">""</span> <span class="small_keyword" title="call a procedure">call</span>
<span class="lineno" id=line144></span>        eprintln$ <span class="fstring">"[save] "</span> + fn
<span class="lineno" id=line145></span>      ;
<span class="lineno" id=line146></span>      <span class="big_keyword" title="Define a mutable variable">var</span> f = fopen_output fn;
<span class="lineno" id=line147></span>      <span class="library" title="call procedure on each element of data structure">iter</span> (<span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> (s:<span class="library" title="binding of C++ string type">string</span>) { writeln$ f,s; }) lines;
<span class="lineno" id=line148></span>      fclose f;
<span class="lineno" id=line149></span>    }
<span class="lineno" id=line150></span>  
<span class="lineno" id=line151></span>    <span class="doccomment">Write a space.</span>
<span class="lineno" id=line152></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> space (s:output_file) { <span class="library" title="Print a string to a stream">write</span> (s, <span class="fstring">" "</span>); };
<span class="lineno" id=line153></span>  
<span class="lineno" id=line154></span>    <span class="doccomment">Write end of line mark.</span>
<span class="lineno" id=line155></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> endl (s:output_file) { <span class="library" title="Print a string to a stream">write</span> (s, <span class="fstring">"\n"</span>); };
<span class="lineno" id=line156></span>  
<span class="lineno" id=line157></span>    <span class="doccomment">Write data with conversion using Str::str.</span>
<span class="lineno" id=line158></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> fprint[T <span class="small_keyword" title="type-class constraint">with</span> Str[T]] (s:output_file, x:T) { <span class="library" title="Print a string to a stream">write</span> (s, <span class="library" title="Convert a value to a string">str</span> x); };
<span class="lineno" id=line159></span>  
<span class="lineno" id=line160></span>    <span class="doccomment">Write data with conversion using Str::str and end line mark.</span>
<span class="lineno" id=line161></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> fprintln[T <span class="small_keyword" title="type-class constraint">with</span> Str[T]] (s:output_file, x:T) { <span class="library" title="Print a string to a stream">write</span> (s, <span class="library" title="Convert a value to a string">str</span> x+<span class="fstring">"\n"</span>); };
<span class="lineno" id=line162></span>  }
<span class="lineno" id=line163></span>  
<span class="lineno" id=line164></span>  <span class="doccomment">C standard IO with FILE*.</span>
<span class="lineno" id=line165></span>  <span class="big_keyword" title="Open a module or class">open</span> <span class="big_keyword" title="Define a type class">class</span> Cstdio {
<span class="lineno" id=line166></span>  
<span class="lineno" id=line167></span>    <span class="doccomment">C file type.</span>
<span class="lineno" id=line168></span>    <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> FILE = <span class="fstring">"FILE*"</span> <span class="big_keyword" title="specify requirements">requires</span> C89_headers::stdio_h;
<span class="lineno" id=line169></span>  
<span class="lineno" id=line170></span>    <span class="qualifier" title="A Plain Old Data type, which needs no finalisation">pod</span> <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> ifile = <span class="fstring">"FILE*"</span> <span class="big_keyword" title="specify requirements">requires</span> C89_headers::stdio_h;
<span class="lineno" id=line171></span>    <span class="qualifier" title="A Plain Old Data type, which needs no finalisation">pod</span> <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> ofile = <span class="fstring">"FILE*"</span> <span class="big_keyword" title="specify requirements">requires</span> C89_headers::stdio_h;
<span class="lineno" id=line172></span>  
<span class="lineno" id=line173></span>    <span class="doccomment">Load file from filename.</span>
<span class="lineno" id=line174></span>    <span class="doccomment">Note: loaded in binary mode not text mode!</span>
<span class="lineno" id=line175></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> raw_load: <span class="library" title="binding of C++ string type">string</span> -&gt; <span class="library" title="binding of C++ string type">string</span> = <span class="fstring">"::flx::rtl::ioutil::load_file($1)"</span>
<span class="lineno" id=line176></span>      <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"flx_ioutil"</span>;
<span class="lineno" id=line177></span>  
<span class="lineno" id=line178></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> raw_load_text: <span class="library" title="binding of C++ string type">string</span> -&gt; <span class="library" title="binding of C++ string type">string</span> = <span class="fstring">"::flx::rtl::ioutil::load_text_file($1)"</span>
<span class="lineno" id=line179></span>      <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"flx_ioutil"</span>;
<span class="lineno" id=line180></span>  
<span class="lineno" id=line181></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> load(f:<span class="library" title="binding of C++ string type">string</span>) : <span class="library" title="binding of C++ string type">string</span> =
<span class="lineno" id=line182></span>    {
<span class="lineno" id=line183></span>      <span class="small_keyword" title="conditional">if</span> Env::getenv <span class="fstring">"FLX_FILE_MONITOR"</span> != <span class="fstring">""</span> <span class="small_keyword" title="call a procedure">call</span>
<span class="lineno" id=line184></span>        eprintln$ <span class="fstring">"[load] "</span> + f
<span class="lineno" id=line185></span>      ;
<span class="lineno" id=line186></span>      <span class="small_keyword" title="return">return</span> raw_load f;
<span class="lineno" id=line187></span>    }
<span class="lineno" id=line188></span>  
<span class="lineno" id=line189></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> load_text(f:<span class="library" title="binding of C++ string type">string</span>) : <span class="library" title="binding of C++ string type">string</span> =
<span class="lineno" id=line190></span>    {
<span class="lineno" id=line191></span>      <span class="small_keyword" title="conditional">if</span> Env::getenv <span class="fstring">"FLX_FILE_MONITOR"</span> != <span class="fstring">""</span> <span class="small_keyword" title="call a procedure">call</span>
<span class="lineno" id=line192></span>        eprintln$ <span class="fstring">"[load_text] "</span> + f
<span class="lineno" id=line193></span>      ;
<span class="lineno" id=line194></span>      <span class="small_keyword" title="return">return</span> raw_load_text f;
<span class="lineno" id=line195></span>    }
<span class="lineno" id=line196></span>  
<span class="lineno" id=line197></span>  
<span class="lineno" id=line198></span>  
<span class="lineno" id=line199></span>    <span class="doccomment">Standard input, can be redirected by flx_run.</span>
<span class="lineno" id=line200></span>    <span class="big_keyword" title="Bind a Felix symbol to a C expression">const</span> stdin: ifile = <span class="fstring">"ptf-&gt;flx_stdin"</span> <span class="big_keyword" title="specify requirements">requires</span> property <span class="fstring">"needs_ptf"</span>;
<span class="lineno" id=line201></span>  
<span class="lineno" id=line202></span>    <span class="doccomment">Standard output, can be redirected by flx_run.</span>
<span class="lineno" id=line203></span>    <span class="big_keyword" title="Bind a Felix symbol to a C expression">const</span> stdout: ofile = <span class="fstring">"ptf-&gt; flx_stdout"</span> <span class="big_keyword" title="specify requirements">requires</span> property <span class="fstring">"needs_ptf"</span>;
<span class="lineno" id=line204></span>  
<span class="lineno" id=line205></span>    <span class="doccomment">Standard error, can be redirected by flx_run.</span>
<span class="lineno" id=line206></span>    <span class="big_keyword" title="Bind a Felix symbol to a C expression">const</span> stderr: ofile = <span class="fstring">"ptf-&gt; flx_stderr"</span> <span class="big_keyword" title="specify requirements">requires</span> property <span class="fstring">"needs_ptf"</span>;
<span class="lineno" id=line207></span>  
<span class="lineno" id=line208></span>    <span class="doccomment">Standard input, redirected by shell.</span>
<span class="lineno" id=line209></span>    <span class="big_keyword" title="Bind a Felix symbol to a C expression">const</span> cstdin: ifile = <span class="fstring">"stdin"</span>;
<span class="lineno" id=line210></span>  
<span class="lineno" id=line211></span>    <span class="doccomment">Standard output, redirected by shell.</span>
<span class="lineno" id=line212></span>    <span class="big_keyword" title="Bind a Felix symbol to a C expression">const</span> cstdout: ofile = <span class="fstring">"stdout"</span>;
<span class="lineno" id=line213></span>  
<span class="lineno" id=line214></span>    <span class="doccomment">Standard error, redirected by shell.</span>
<span class="lineno" id=line215></span>    <span class="big_keyword" title="Bind a Felix symbol to a C expression">const</span> cstderr: ofile = <span class="fstring">"stderr"</span>;
<span class="lineno" id=line216></span>  
<span class="lineno" id=line217></span>    <span class="doccomment">C standard IO as instance of Input_file.</span>
<span class="lineno" id=line218></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> Input_file[ifile] {
<span class="lineno" id=line219></span>      <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"flx_ioutil"</span>;
<span class="lineno" id=line220></span>      <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> raw_fopen_input: <span class="library" title="binding of C++ string type">string</span> -&gt; ifile = <span class="fstring">'fopen($1.c_str(),"rb")'</span>;
<span class="lineno" id=line221></span>      <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> raw_fopen_input_text: <span class="library" title="binding of C++ string type">string</span> -&gt; ifile = <span class="fstring">'fopen($1.c_str(),"r")'</span>;
<span class="lineno" id=line222></span>      <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> valid : ifile -&gt; bool = <span class="fstring">"$1!=(FILE*)0"</span>;
<span class="lineno" id=line223></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> fclose: ifile = <span class="fstring">'(void)fclose($1);'</span>;
<span class="lineno" id=line224></span>      <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> load: ifile -&gt; <span class="library" title="binding of C++ string type">string</span> = <span class="fstring">"::flx::rtl::ioutil::load_file($1)"</span>;
<span class="lineno" id=line225></span>      <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> <span class="library" title="Read a string from a stream including trailing newline">readln</span>: ifile -&gt; <span class="library" title="binding of C++ string type">string</span> =<span class="fstring">"::flx::rtl::ioutil::readln($1)"</span>;
<span class="lineno" id=line226></span>      <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> read: ifile *<span class="library" title="binding of C size_t type">size</span> -&gt; <span class="library" title="binding of C++ string type">string</span> = <span class="fstring">"::flx::rtl::ioutil::raw_read($1,$2)"</span>;
<span class="lineno" id=line227></span>      <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> feof : ifile -&gt; bool = <span class="fstring">"feof($1)"</span>;
<span class="lineno" id=line228></span>    }
<span class="lineno" id=line229></span>  
<span class="lineno" id=line230></span>    <span class="doccomment">C standard IO as instance of Output_file.</span>
<span class="lineno" id=line231></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> Output_file[ofile] {
<span class="lineno" id=line232></span>      <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"flx_ioutil"</span>;
<span class="lineno" id=line233></span>      <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> raw_fopen_output: <span class="library" title="binding of C++ string type">string</span> -&gt; ofile = <span class="fstring">'fopen($1.c_str(),"wb")'</span>;
<span class="lineno" id=line234></span>      <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> raw_fopen_output_text: <span class="library" title="binding of C++ string type">string</span> -&gt; ofile = <span class="fstring">'fopen($1.c_str(),"w")'</span>;
<span class="lineno" id=line235></span>      <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> raw_fopen_append: <span class="library" title="binding of C++ string type">string</span> -&gt; ofile = <span class="fstring">'fopen($1.c_str(),"ab")'</span>;
<span class="lineno" id=line236></span>      <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> raw_fopen_append_text: <span class="library" title="binding of C++ string type">string</span> -&gt; ofile = <span class="fstring">'fopen($1.c_str(),"a")'</span>;
<span class="lineno" id=line237></span>      <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> valid : ofile -&gt; bool = <span class="fstring">"$1!=(FILE*)0"</span>;
<span class="lineno" id=line238></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> fclose: ofile = <span class="fstring">'(void)fclose($1);'</span>;
<span class="lineno" id=line239></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> writeln : ofile * <span class="library" title="binding of C++ string type">string</span> =<span class="fstring">"::flx::rtl::ioutil::writeln($1,$2);"</span>;
<span class="lineno" id=line240></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> <span class="library" title="Print a string to a stream">write</span> : ofile * <span class="library" title="binding of C++ string type">string</span> =<span class="fstring">"::flx::rtl::ioutil::write($1,$2);"</span>;
<span class="lineno" id=line241></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> <span class="library" title="Print a string to a stream">write</span> : ofile * <span class="library" title="binding of C unsigned char type">utiny</span> =<span class="fstring">"fwrite($2,1,1,$1);"</span>;
<span class="lineno" id=line242></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> <span class="library" title="Print a string to a stream">write</span> : ofile * <span class="library" title="binding of C char type">char</span> =<span class="fstring">"fwrite($2,1,1,$1);"</span>;
<span class="lineno" id=line243></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> fflush: ofile = <span class="fstring">"fflush($1);"</span>;
<span class="lineno" id=line244></span>    }
<span class="lineno" id=line245></span>  }
<span class="lineno" id=line246></span>  
<span class="lineno" id=line247></span>  <span class="big_keyword" title="Open a module or class">open</span> Input_file[Cstdio::ifile];
<span class="lineno" id=line248></span>  <span class="comment">// note we cannot open Iterable here because it would cause</span>
<span class="lineno" id=line249></span>  <span class="comment">// a conflict ;(</span>
<span class="lineno" id=line250></span>  
<span class="lineno" id=line251></span>  <span class="big_keyword" title="Open a module or class">open</span> Output_file[Cstdio::ofile];
<span class="lineno" id=line252></span>  <span class="doccomment">DEBUG OUTPUT UTIITIES! </span>
<span class="lineno" id=line253></span>  <span class="doccomment">DO NOT REQUIRE THREAD FRAME.</span>
<span class="lineno" id=line254></span>  <span class="doccomment">NOT REDIRECTABLE BY DRIVER.</span>
<span class="lineno" id=line255></span>  <span class="doccomment">(can be redirected by OS if OS can do it)</span>
<span class="lineno" id=line256></span>  
<span class="lineno" id=line257></span>  <span class="doccomment">Write string to output.</span>
<span class="lineno" id=line258></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> <span class="library" title="Print a string to standard output">print</span>  [T <span class="small_keyword" title="type-class constraint">with</span> Str[T]] (x:T) { fprint (cstdout, x); };
<span class="lineno" id=line259></span>  
<span class="lineno" id=line260></span>  <span class="doccomment">Write string to output with end of line. Also does a flush</span>
<span class="lineno" id=line261></span>  <span class="doccomment">to improve synchronisation with cstderr.</span>
<span class="lineno" id=line262></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> <span class="library" title="Print a string to standard output with newline appended">println</span>[T <span class="small_keyword" title="type-class constraint">with</span> Str[T]] (x:T) { fprintln (cstdout, x); fflush cstdout; };
<span class="lineno" id=line263></span>  
<span class="lineno" id=line264></span>  <span class="doccomment">Write end of line on output.</span>
<span class="lineno" id=line265></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> endl() { endl cstdout; }
<span class="lineno" id=line266></span>  
<span class="lineno" id=line267></span>  <span class="doccomment">Write space on cout.</span>
<span class="lineno" id=line268></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> space() { space cstdout; }
<span class="lineno" id=line269></span>  
<span class="lineno" id=line270></span>  <span class="doccomment">flush buffers of cout.</span>
<span class="lineno" id=line271></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> fflush() { fflush cstdout; }
<span class="lineno" id=line272></span>  
<span class="lineno" id=line273></span>  <span class="doccomment">Write string to cerr.</span>
<span class="lineno" id=line274></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> eprint  [T <span class="small_keyword" title="type-class constraint">with</span> Str[T]] (x:T) { fprint (cstderr, x); };
<span class="lineno" id=line275></span>  
<span class="lineno" id=line276></span>  <span class="doccomment">Write string to cerr with end of line.</span>
<span class="lineno" id=line277></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> eprintln[T <span class="small_keyword" title="type-class constraint">with</span> Str[T]] (x:T) { fprintln (cstderr, x); fflush cstderr; };
<span class="lineno" id=line278></span>  
<span class="lineno" id=line279></span>  <span class="doccomment">Write end of line on cerr.</span>
<span class="lineno" id=line280></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> eendl() { endl cstderr; }
<span class="lineno" id=line281></span>  
<span class="lineno" id=line282></span>  <span class="doccomment">Write space on cerr.</span>
<span class="lineno" id=line283></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> espace() { space cstderr; }
</pre></p></div><h1 id='Ansi_Terminal_h'><img src='/share/src/web/images/minus.gif' id='Ansi Terminal' onclick='toggle(this,"Ansi_Terminal_d")' alt='+'/> 4 Ansi Terminal</h1><div id='Ansi_Terminal_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/io/ansi_terminal.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="comment">// Author Mike Maul</span>
<span class="lineno" id=line3></span>  <span class="doccomment">#### Color output formatting for Ansi Terminals.</span>
<span class="lineno" id=line4></span>  <span class="big_keyword" title="Define a type class">class</span> AnsiTerminal
<span class="lineno" id=line5></span>  {
<span class="lineno" id=line6></span>    <span class="big_keyword" title="Bind a Felix symbol to a C expression">const</span> cc:<span class="library" title="binding of C char type">char</span> = <span class="fstring">"(char)27"</span>;
<span class="lineno" id=line7></span>  
<span class="lineno" id=line8></span>    <span class="comment">// No colour</span>
<span class="lineno" id=line9></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span>  NC_ () =&gt; cc + <span class="fstring">'[0m'</span>; 
<span class="lineno" id=line10></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span>  NC_(s:<span class="library" title="binding of C++ string type">string</span>) =&gt; NC_() + s;
<span class="lineno" id=line11></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> NC()     { <span class="library" title="Print a string to standard output">print</span>$ NC_(<span class="fstring">""</span>); }
<span class="lineno" id=line12></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> NC(s:<span class="library" title="binding of C++ string type">string</span>)     { <span class="library" title="Print a string to standard output">print</span>$ NC_(s); }
<span class="lineno" id=line13></span>  
<span class="lineno" id=line14></span>    <span class="comment">// Blue</span>
<span class="lineno" id=line15></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> blue_() =&gt; cc + <span class="fstring">'[1;34m'</span>;
<span class="lineno" id=line16></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> blue_(s:<span class="library" title="binding of C++ string type">string</span>) =&gt; blue_() + s + NC_();
<span class="lineno" id=line17></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> blue()   { <span class="library" title="Print a string to standard output">print</span>$ blue_(); }
<span class="lineno" id=line18></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> blue(s:<span class="library" title="binding of C++ string type">string</span>)   { <span class="library" title="Print a string to standard output">print</span>$ blue_(s); }
<span class="lineno" id=line19></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> BLUE_() =&gt; cc + <span class="fstring">'[1;34;1m'</span>;
<span class="lineno" id=line20></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> BLUE_(s:<span class="library" title="binding of C++ string type">string</span>) =&gt; BLUE_() + s + NC_();
<span class="lineno" id=line21></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> BLUE()   { <span class="library" title="Print a string to standard output">print</span>$ BLUE_(); }
<span class="lineno" id=line22></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> BLUE(s:<span class="library" title="binding of C++ string type">string</span>)   { <span class="library" title="Print a string to standard output">print</span>$ BLUE_(s); }
<span class="lineno" id=line23></span>  
<span class="lineno" id=line24></span>    <span class="comment">// Cyan</span>
<span class="lineno" id=line25></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> cyan_() =&gt; cc + <span class="fstring">'[0;36m'</span>;
<span class="lineno" id=line26></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> cyan_(s:<span class="library" title="binding of C++ string type">string</span>) =&gt; cyan_()+ s + NC_();
<span class="lineno" id=line27></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> cyan()   { <span class="library" title="Print a string to standard output">print</span>$ cyan_(); }
<span class="lineno" id=line28></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> cyan(s:<span class="library" title="binding of C++ string type">string</span>)   { <span class="library" title="Print a string to standard output">print</span>$ cyan_(s); }
<span class="lineno" id=line29></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> CYAN_() =&gt; cc + <span class="fstring">'[1;36;1m'</span>;
<span class="lineno" id=line30></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> CYAN_(s:<span class="library" title="binding of C++ string type">string</span>) =&gt; CYAN_() + s + NC_();
<span class="lineno" id=line31></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> CYAN()   { <span class="library" title="Print a string to standard output">print</span>$ CYAN_(); }
<span class="lineno" id=line32></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> CYAN(s:<span class="library" title="binding of C++ string type">string</span>)   { <span class="library" title="Print a string to standard output">print</span>$ CYAN_(s); }
<span class="lineno" id=line33></span>  
<span class="lineno" id=line34></span>    <span class="comment">// Green</span>
<span class="lineno" id=line35></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> green_() =&gt; cc + <span class="fstring">'[0;32m'</span>;
<span class="lineno" id=line36></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> green_(s:<span class="library" title="binding of C++ string type">string</span>) =&gt; green_() + s + NC_();
<span class="lineno" id=line37></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> green()  { <span class="library" title="Print a string to standard output">print</span>$ green_(); }
<span class="lineno" id=line38></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> green(s:<span class="library" title="binding of C++ string type">string</span>)   { <span class="library" title="Print a string to standard output">print</span>$ green_(s); }
<span class="lineno" id=line39></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> GREEN_() =&gt; cc + <span class="fstring">'[1;32;1m'</span>;
<span class="lineno" id=line40></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> GREEN_(s:<span class="library" title="binding of C++ string type">string</span>) =&gt; GREEN_() + s + NC_();
<span class="lineno" id=line41></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> GREEN()  { <span class="library" title="Print a string to standard output">print</span>$ GREEN_(); }
<span class="lineno" id=line42></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> GREEN(s:<span class="library" title="binding of C++ string type">string</span>)   { <span class="library" title="Print a string to standard output with newline appended">println</span>$ GREEN_(s); }
<span class="lineno" id=line43></span>  
<span class="lineno" id=line44></span>    <span class="comment">// Red</span>
<span class="lineno" id=line45></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> red_() =&gt; cc + <span class="fstring">'[0;31m'</span>;
<span class="lineno" id=line46></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> red_(s:<span class="library" title="binding of C++ string type">string</span>) =&gt; red_()+ s + NC_();
<span class="lineno" id=line47></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> red()   { <span class="library" title="Print a string to standard output">print</span>$ red_(); }
<span class="lineno" id=line48></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> red(s:<span class="library" title="binding of C++ string type">string</span>)   { <span class="library" title="Print a string to standard output">print</span>$ red_(s); }
<span class="lineno" id=line49></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> RED_() =&gt; cc + <span class="fstring">'[0;31;1m'</span>;
<span class="lineno" id=line50></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> RED_(s:<span class="library" title="binding of C++ string type">string</span>) =&gt; red_()+ s + NC_();
<span class="lineno" id=line51></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> RED()   { <span class="library" title="Print a string to standard output">print</span>$ red_(); }
<span class="lineno" id=line52></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> RED(s:<span class="library" title="binding of C++ string type">string</span>)   { <span class="library" title="Print a string to standard output">print</span>$ red_(s); }
<span class="lineno" id=line53></span>  
<span class="lineno" id=line54></span>    <span class="comment">// Yellow</span>
<span class="lineno" id=line55></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> yellow_() =&gt; cc + <span class="fstring">'[0;33m'</span>;
<span class="lineno" id=line56></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> yellow_(s:<span class="library" title="binding of C++ string type">string</span>) =&gt; yellow_() + s + NC_();
<span class="lineno" id=line57></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> yellow() { <span class="library" title="Print a string to standard output">print</span>$ yellow_(); }
<span class="lineno" id=line58></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> yellow(s:<span class="library" title="binding of C++ string type">string</span>)   { <span class="library" title="Print a string to standard output">print</span>$ yellow_(s); }
<span class="lineno" id=line59></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> YELLOW_() =&gt; cc + <span class="fstring">'[1;33;1m'</span>;
<span class="lineno" id=line60></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> YELLOW_(s:<span class="library" title="binding of C++ string type">string</span>) =&gt; YELLOW_() + s + NC_();
<span class="lineno" id=line61></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> YELLOW() { <span class="library" title="Print a string to standard output">print</span>$ YELLOW_(); }
<span class="lineno" id=line62></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> YELLOW(s:<span class="library" title="binding of C++ string type">string</span>)   { <span class="library" title="Print a string to standard output">print</span>$ YELLOW_(s); }
<span class="lineno" id=line63></span>  }
<span class="lineno" id=line64></span>  
<span class="lineno" id=line65></span>  
</pre></p></div><h1 id='Stream_I/O_h'><img src='/share/src/web/images/minus.gif' id='Stream I/O' onclick='toggle(this,"Stream_I/O_d")' alt='+'/> 5 Stream I/O</h1><div id='Stream_I/O_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/io/iostream.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Define a type class">class</span> IOStream {
<span class="lineno" id=line3></span>    <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"demux"</span>;
<span class="lineno" id=line4></span>    <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"faio"</span>;
<span class="lineno" id=line5></span>  
<span class="lineno" id=line6></span>    <span class="big_keyword" title="Open a module or class">open</span> Faio;
<span class="lineno" id=line7></span>  
<span class="lineno" id=line8></span>    <span class="small_keyword" title="conditional">if</span> PLAT_POSIX <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line9></span>      <span class="big_keyword" title="Open a module or class">open</span> Faio_posix;
<span class="lineno" id=line10></span>      <span class="big_keyword" title="Define an alias for a type expression">typedef</span> fd_t = FileSystem::posix_file;
<span class="lineno" id=line11></span>    <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line12></span>      <span class="big_keyword" title="Open a module or class">open</span> Faio_win32;
<span class="lineno" id=line13></span>      <span class="big_keyword" title="Define an alias for a type expression">typedef</span> fd_t = Faio_win32::fd_t;
<span class="lineno" id=line14></span>    <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line15></span>  
<span class="lineno" id=line16></span>    <span class="comment">// ---------------------------------------------------------------------------</span>
<span class="lineno" id=line17></span>  
<span class="lineno" id=line18></span>    publish <span class="fstring">"The interface for a readable stream of bytes."</span>
<span class="lineno" id=line19></span>    <span class="big_keyword" title="Define a type class">class</span> IByteStream[T] {
<span class="lineno" id=line20></span>      publish <span class="fstring">"Read N bytes from the stream into the address."</span>
<span class="lineno" id=line21></span>      <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> read: T * &amp;<span class="library" title="binding of C int type">int</span> * <span class="library" title="special binding of C void* type">address</span> * &amp;bool;
<span class="lineno" id=line22></span>    }
<span class="lineno" id=line23></span>  
<span class="lineno" id=line24></span>    publish <span class="fstring">"The interface for a writable stream of bytes."</span>
<span class="lineno" id=line25></span>    <span class="big_keyword" title="Define a type class">class</span> OByteStream[T] {
<span class="lineno" id=line26></span>      publish <span class="fstring">"Write N bytes from the address into the stream."</span>
<span class="lineno" id=line27></span>      <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> <span class="library" title="Print a string to a stream">write</span>: T * &amp;<span class="library" title="binding of C int type">int</span> * <span class="library" title="special binding of C void* type">address</span> * &amp;bool;
<span class="lineno" id=line28></span>    }
<span class="lineno" id=line29></span>  
<span class="lineno" id=line30></span>    publish <span class="fstring">"The interface for a readable and writable stream of bytes."</span>
<span class="lineno" id=line31></span>    <span class="big_keyword" title="Define a type class">class</span> IOByteStream[T] {
<span class="lineno" id=line32></span>      <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> IByteStream[T];
<span class="lineno" id=line33></span>      <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> OByteStream[T];
<span class="lineno" id=line34></span>    }
<span class="lineno" id=line35></span>  
<span class="lineno" id=line36></span>    publish <span class="fstring">"A readable stream that can have it's read channel closed."</span>
<span class="lineno" id=line37></span>    <span class="big_keyword" title="Define a type class">class</span> TerminalIByteStream[T] {
<span class="lineno" id=line38></span>      <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> IByteStream[T];
<span class="lineno" id=line39></span>  
<span class="lineno" id=line40></span>      publish <span class="fstring">"Close the input stream."</span>
<span class="lineno" id=line41></span>      <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> iclose: T;
<span class="lineno" id=line42></span>    }
<span class="lineno" id=line43></span>  
<span class="lineno" id=line44></span>    publish <span class="fstring">"A writable stream that can have it's write channel closed."</span>
<span class="lineno" id=line45></span>    <span class="big_keyword" title="Define a type class">class</span> TerminalOByteStream[T] {
<span class="lineno" id=line46></span>      <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> OByteStream[T];
<span class="lineno" id=line47></span>  
<span class="lineno" id=line48></span>      publish <span class="fstring">"Close the output stream."</span>
<span class="lineno" id=line49></span>      <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> oclose: T;
<span class="lineno" id=line50></span>    }
<span class="lineno" id=line51></span>  
<span class="lineno" id=line52></span>    publish <span class="fstring">"A writable stream that can have it's channels closed."</span>
<span class="lineno" id=line53></span>    <span class="big_keyword" title="Define a type class">class</span> TerminalIOByteStream[T] {
<span class="lineno" id=line54></span>      <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> TerminalIByteStream[T];
<span class="lineno" id=line55></span>      <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> TerminalOByteStream[T];
<span class="lineno" id=line56></span>  
<span class="lineno" id=line57></span>      publish <span class="fstring">"Close the stream."</span>
<span class="lineno" id=line58></span>      <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> ioclose: T;
<span class="lineno" id=line59></span>    }
<span class="lineno" id=line60></span>  
<span class="lineno" id=line61></span>    <span class="comment">// ---------------------------------------------------------------------------</span>
<span class="lineno" id=line62></span>  
<span class="lineno" id=line63></span>    variant devnull_t = DEVNULL;
<span class="lineno" id=line64></span>  
<span class="lineno" id=line65></span>    publish <span class="fstring">"devnull_t"</span>
<span class="lineno" id=line66></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> IByteStream[devnull_t]
<span class="lineno" id=line67></span>    {
<span class="lineno" id=line68></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> read(strm: devnull_t, <span class="library" title="number of elements in data structure">len</span>: &amp;<span class="library" title="binding of C int type">int</span>, buf: <span class="library" title="special binding of C void* type">address</span>, eof: &amp;bool) {
<span class="lineno" id=line69></span>        <span class="library" title="number of elements in data structure">len</span> &lt;- 0;
<span class="lineno" id=line70></span>        eof &lt;- <span class="library" title="truth value">true</span>;
<span class="lineno" id=line71></span>      }
<span class="lineno" id=line72></span>    }
<span class="lineno" id=line73></span>  
<span class="lineno" id=line74></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> OByteStream[devnull_t]
<span class="lineno" id=line75></span>    {
<span class="lineno" id=line76></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> <span class="library" title="Print a string to a stream">write</span>(strm: devnull_t, <span class="library" title="number of elements in data structure">len</span>: &amp;<span class="library" title="binding of C int type">int</span>, buf: <span class="library" title="special binding of C void* type">address</span>, eof: &amp;bool) {
<span class="lineno" id=line77></span>        eof &lt;- <span class="library" title="false value">false</span>;
<span class="lineno" id=line78></span>      }
<span class="lineno" id=line79></span>    }
<span class="lineno" id=line80></span>  
<span class="lineno" id=line81></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> IOByteStream[devnull_t] {}
<span class="lineno" id=line82></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> TerminalIByteStream[devnull_t] { <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> iclose (x:devnull_t) {} }
<span class="lineno" id=line83></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> TerminalOByteStream[devnull_t] { <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> oclose (x:devnull_t) {} }
<span class="lineno" id=line84></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> TerminalIOByteStream[devnull_t] { <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> ioclose (x:devnull_t) {} }
<span class="lineno" id=line85></span>  
<span class="lineno" id=line86></span>    <span class="comment">// ---------------------------------------------------------------------------</span>
<span class="lineno" id=line87></span>  
<span class="lineno" id=line88></span>    publish <span class="fstring">"fd_t -- native file handle (disk file)"</span>
<span class="lineno" id=line89></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> IByteStream[fd_t]
<span class="lineno" id=line90></span>    {
<span class="lineno" id=line91></span>      <span class="small_keyword" title="conditional">if</span> PLAT_POSIX <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line92></span>        <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> cread: fd_t * <span class="library" title="binding of C int type">int</span> * <span class="library" title="special binding of C void* type">address</span> -&gt; <span class="library" title="binding of C int type">int</span> = <span class="fstring">"read($1,$2,$3)"</span>;
<span class="lineno" id=line93></span>        <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> read(fd: fd_t, <span class="library" title="number of elements in data structure">len</span>: &amp;<span class="library" title="binding of C int type">int</span>, buf: <span class="library" title="special binding of C void* type">address</span>, eof: &amp;bool) {
<span class="lineno" id=line94></span>          <span class="big_keyword" title="Define a mutable variable">var</span> oldlen = *<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line95></span>          <span class="library" title="number of elements in data structure">len</span> &lt;- cread(fd, *<span class="library" title="number of elements in data structure">len</span>, buf);
<span class="lineno" id=line96></span>          eof &lt;- oldlen &lt; *<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line97></span>        }
<span class="lineno" id=line98></span>      <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line99></span>        <span class="comment">// int32 = DWORD</span>
<span class="lineno" id=line100></span>        <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> ReadFile: fd_t * <span class="library" title="special binding of C void* type">address</span> * <span class="library" title="binding of C int32_t type">int32</span> * &amp;<span class="library" title="binding of C int32_t type">int32</span> -&gt; bool =
<span class="lineno" id=line101></span>          <span class="fstring">"ReadFile($1,$2,$3,$4,NULL)"</span>
<span class="lineno" id=line102></span>        ;
<span class="lineno" id=line103></span>        <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> read(fd: fd_t, <span class="library" title="number of elements in data structure">len</span>: &amp;<span class="library" title="binding of C int type">int</span>, buf: <span class="library" title="special binding of C void* type">address</span>, eof: &amp;bool) {
<span class="lineno" id=line104></span>          <span class="big_keyword" title="Define a mutable variable">var</span> oldlen = *<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line105></span>          <span class="big_keyword" title="Define a mutable variable">var</span> readin: <span class="library" title="binding of C int32_t type">int32</span>;
<span class="lineno" id=line106></span>          <span class="big_keyword" title="Define a mutable variable">var</span> res = ReadFile(fd, buf, <span class="library" title="number of elements in data structure">len</span>*.<span class="library" title="binding of C int32_t type">int32</span>, &amp;readin);
<span class="lineno" id=line107></span>          <span class="library" title="number of elements in data structure">len</span> &lt;- readin.<span class="library" title="binding of C int type">int</span>;
<span class="lineno" id=line108></span>          eof &lt;- res <span class="small_keyword" title="logical disjunction">or</span> (oldlen &lt; *<span class="library" title="number of elements in data structure">len</span>);
<span class="lineno" id=line109></span>        }
<span class="lineno" id=line110></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line111></span>    }
<span class="lineno" id=line112></span>  
<span class="lineno" id=line113></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> OByteStream[fd_t]
<span class="lineno" id=line114></span>    {
<span class="lineno" id=line115></span>      <span class="small_keyword" title="conditional">if</span> PLAT_POSIX <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line116></span>        <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> cwrite: fd_t * <span class="library" title="binding of C int type">int</span> * <span class="library" title="special binding of C void* type">address</span> -&gt; <span class="library" title="binding of C int type">int</span> = <span class="fstring">"write($1,$2,$3)"</span>;
<span class="lineno" id=line117></span>        <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> <span class="library" title="Print a string to a stream">write</span>(fd: fd_t, <span class="library" title="number of elements in data structure">len</span>: &amp;<span class="library" title="binding of C int type">int</span>, buf: <span class="library" title="special binding of C void* type">address</span>, eof: &amp;bool) {
<span class="lineno" id=line118></span>          <span class="big_keyword" title="Define a mutable variable">var</span> oldlen = *<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line119></span>          <span class="library" title="number of elements in data structure">len</span> &lt;- cwrite(fd, *<span class="library" title="number of elements in data structure">len</span>, buf);
<span class="lineno" id=line120></span>          eof &lt;- oldlen &lt; *<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line121></span>        }
<span class="lineno" id=line122></span>      <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line123></span>        <span class="comment">// int32 = DWORD</span>
<span class="lineno" id=line124></span>        <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> WriteFile: fd_t * <span class="library" title="special binding of C void* type">address</span> * <span class="library" title="binding of C int32_t type">int32</span> * &amp;<span class="library" title="binding of C int32_t type">int32</span> -&gt; bool =
<span class="lineno" id=line125></span>          <span class="fstring">"WriteFile($1,$2,$3,$4,NULL)"</span>
<span class="lineno" id=line126></span>        ;
<span class="lineno" id=line127></span>        <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> <span class="library" title="Print a string to a stream">write</span>(fd: fd_t, <span class="library" title="number of elements in data structure">len</span>: &amp;<span class="library" title="binding of C int type">int</span>, buf: <span class="library" title="special binding of C void* type">address</span>, eof: &amp;bool) {
<span class="lineno" id=line128></span>          <span class="big_keyword" title="Define a mutable variable">var</span> oldlen = *<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line129></span>          <span class="big_keyword" title="Define a mutable variable">var</span> written: <span class="library" title="binding of C int32_t type">int32</span>;
<span class="lineno" id=line130></span>          <span class="big_keyword" title="Define a mutable variable">var</span> res = WriteFile(fd, buf, <span class="library" title="number of elements in data structure">len</span>*.<span class="library" title="binding of C int32_t type">int32</span>, &amp;written);
<span class="lineno" id=line131></span>          <span class="library" title="number of elements in data structure">len</span> &lt;- written.<span class="library" title="binding of C int type">int</span>;
<span class="lineno" id=line132></span>          eof &lt;- res <span class="small_keyword" title="logical disjunction">or</span> (oldlen &lt; *<span class="library" title="number of elements in data structure">len</span>);
<span class="lineno" id=line133></span>        }
<span class="lineno" id=line134></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line135></span>    }
<span class="lineno" id=line136></span>  
<span class="lineno" id=line137></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> IOByteStream[fd_t] {}
<span class="lineno" id=line138></span>  
<span class="lineno" id=line139></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> TerminalIByteStream[fd_t]
<span class="lineno" id=line140></span>    {
<span class="lineno" id=line141></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> iclose (fd: fd_t) {
<span class="lineno" id=line142></span>        <span class="small_keyword" title="conditional">if</span> PLAT_POSIX <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line143></span>          <span class="hack">C_hack</span>::ignore(FileSystem::close fd);
<span class="lineno" id=line144></span>        <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line145></span>          CloseFile fd;
<span class="lineno" id=line146></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line147></span>      }
<span class="lineno" id=line148></span>    }
<span class="lineno" id=line149></span>  
<span class="lineno" id=line150></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> TerminalOByteStream[fd_t]
<span class="lineno" id=line151></span>    {
<span class="lineno" id=line152></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> oclose (fd: fd_t) {
<span class="lineno" id=line153></span>        <span class="small_keyword" title="conditional">if</span> PLAT_POSIX <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line154></span>          <span class="hack">C_hack</span>::ignore(FileSystem::close fd);
<span class="lineno" id=line155></span>        <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line156></span>          CloseFile fd;
<span class="lineno" id=line157></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line158></span>      }
<span class="lineno" id=line159></span>    }
<span class="lineno" id=line160></span>  
<span class="lineno" id=line161></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> TerminalIOByteStream[fd_t]
<span class="lineno" id=line162></span>    {
<span class="lineno" id=line163></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> ioclose (fd: fd_t) {
<span class="lineno" id=line164></span>        <span class="small_keyword" title="conditional">if</span> PLAT_POSIX <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line165></span>          <span class="hack">C_hack</span>::ignore(FileSystem::close fd);
<span class="lineno" id=line166></span>        <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line167></span>          CloseFile fd;
<span class="lineno" id=line168></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line169></span>      }
<span class="lineno" id=line170></span>    }
<span class="lineno" id=line171></span>  
<span class="lineno" id=line172></span>    <span class="comment">// ---------------------------------------------------------------------------</span>
<span class="lineno" id=line173></span>  
<span class="lineno" id=line174></span>    publish <span class="fstring">"Read the input stream to the output stream."</span>
<span class="lineno" id=line175></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> cat[istr,ostr <span class="small_keyword" title="type-class constraint">with</span> IByteStream[istr], OByteStream[ostr]] (
<span class="lineno" id=line176></span>      istream: istr,
<span class="lineno" id=line177></span>      ostream: ostr,
<span class="lineno" id=line178></span>      buf: <span class="library" title="special binding of C void* type">address</span>,
<span class="lineno" id=line179></span>      bufsize: <span class="library" title="binding of C int type">int</span>)
<span class="lineno" id=line180></span>    {
<span class="lineno" id=line181></span>      <span class="big_keyword" title="Define a mutable variable">var</span> reof = <span class="library" title="false value">false</span>;
<span class="lineno" id=line182></span>      <span class="big_keyword" title="Define a mutable variable">var</span> weof = <span class="library" title="false value">false</span>;
<span class="lineno" id=line183></span>      <span class="big_keyword" title="Define a mutable variable">var</span> <span class="library" title="number of elements in data structure">len</span>: <span class="library" title="binding of C int type">int</span>;
<span class="lineno" id=line184></span>  
<span class="lineno" id=line185></span>      <span class="comment">// if we finish input, stop. if output eofs, don't keep hammering on it!</span>
<span class="lineno" id=line186></span>      <span class="small_keyword" title="while loop">while</span> <span class="small_keyword" title="logical negation">not</span> reof <span class="small_keyword" title="logical conjunction">and</span> <span class="small_keyword" title="logical negation">not</span> weof <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line187></span>        <span class="library" title="number of elements in data structure">len</span> = bufsize;
<span class="lineno" id=line188></span>        read (istream, &amp;<span class="library" title="number of elements in data structure">len</span>, buf, &amp;reof);
<span class="lineno" id=line189></span>        <span class="library" title="Print a string to a stream">write</span>(ostream, &amp;<span class="library" title="number of elements in data structure">len</span>, buf, &amp;weof);
<span class="lineno" id=line190></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line191></span>    }
<span class="lineno" id=line192></span>  
<span class="lineno" id=line193></span>    publish <span class="fstring">"Read the input stream to the output stream."</span>
<span class="lineno" id=line194></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> cat[istr,ostr <span class="small_keyword" title="type-class constraint">with</span> IByteStream[istr], OByteStream[ostr]] (
<span class="lineno" id=line195></span>      istream: istr,
<span class="lineno" id=line196></span>      ostream: ostr)
<span class="lineno" id=line197></span>    {
<span class="lineno" id=line198></span>      <span class="big_keyword" title="Define an immutable value">val</span> BUFSIZE = 100000;
<span class="lineno" id=line199></span>      <span class="big_keyword" title="Define a mutable variable">var</span> buf = Memory::malloc(BUFSIZE);
<span class="lineno" id=line200></span>  
<span class="lineno" id=line201></span>      <span class="comment">// that's some nice error checking</span>
<span class="lineno" id=line202></span>      cat (istream, ostream, buf, BUFSIZE);
<span class="lineno" id=line203></span>  
<span class="lineno" id=line204></span>      Memory::free (buf);
<span class="lineno" id=line205></span>    }
<span class="lineno" id=line206></span>  
<span class="lineno" id=line207></span>    publish <span class="fstring">"Read all the input streams to the output stream."</span>
<span class="lineno" id=line208></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> cat[istr,ostr <span class="small_keyword" title="type-class constraint">with</span> IByteStream[istr], OByteStream[ostr]] (
<span class="lineno" id=line209></span>      istreams: <span class="library" title="functional, singly linked list">list</span>[istr],
<span class="lineno" id=line210></span>      ostream: ostr,
<span class="lineno" id=line211></span>      buf: <span class="library" title="special binding of C void* type">address</span>,
<span class="lineno" id=line212></span>      bufsize: <span class="library" title="binding of C int type">int</span>)
<span class="lineno" id=line213></span>    {
<span class="lineno" id=line214></span>      List::<span class="library" title="call procedure on each element of data structure">iter</span> (<span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> (istream:istr) {
<span class="lineno" id=line215></span>        cat (istream, ostream, buf, bufsize);
<span class="lineno" id=line216></span>      }) istreams;
<span class="lineno" id=line217></span>    }
<span class="lineno" id=line218></span>  
<span class="lineno" id=line219></span>    publish <span class="fstring">"Compare the results of two streams."</span>
<span class="lineno" id=line220></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> stream_cmp[istr1,istr2 <span class="small_keyword" title="type-class constraint">with</span> IByteStream[istr1], IByteStream[istr2]] (
<span class="lineno" id=line221></span>      stream1: istr1,
<span class="lineno" id=line222></span>      stream2: istr2,
<span class="lineno" id=line223></span>      buf1: <span class="library" title="special binding of C void* type">address</span>,
<span class="lineno" id=line224></span>      buf2: <span class="library" title="special binding of C void* type">address</span>,
<span class="lineno" id=line225></span>      bufsize: <span class="library" title="binding of C int type">int</span>,
<span class="lineno" id=line226></span>      sign: &amp;<span class="library" title="binding of C int type">int</span>)
<span class="lineno" id=line227></span>    {
<span class="lineno" id=line228></span>      <span class="big_keyword" title="Define a mutable variable">var</span> eof1 = <span class="library" title="false value">false</span>;
<span class="lineno" id=line229></span>      <span class="big_keyword" title="Define a mutable variable">var</span> eof2 = <span class="library" title="false value">false</span>;
<span class="lineno" id=line230></span>      <span class="big_keyword" title="Define a mutable variable">var</span> len1: <span class="library" title="binding of C int type">int</span>;
<span class="lineno" id=line231></span>      <span class="big_keyword" title="Define a mutable variable">var</span> len2: <span class="library" title="binding of C int type">int</span>;
<span class="lineno" id=line232></span>      <span class="big_keyword" title="Define a mutable variable">var</span> terminated = <span class="library" title="false value">false</span>;
<span class="lineno" id=line233></span>      <span class="big_keyword" title="Define a mutable variable">var</span> cmp = 0;
<span class="lineno" id=line234></span>  
<span class="lineno" id=line235></span>      <span class="small_keyword" title="while loop">while</span> cmp == 0 <span class="small_keyword" title="logical conjunction">and</span> <span class="small_keyword" title="logical negation">not</span> terminated <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line236></span>        len1 = bufsize; read(stream1, &amp;len1, buf1, &amp;eof1);
<span class="lineno" id=line237></span>        len2 = bufsize; read(stream2, &amp;len2, buf2, &amp;eof2);
<span class="lineno" id=line238></span>  
<span class="lineno" id=line239></span>        <span class="library" title="number of elements in data structure">len</span> := min(len1, len2);
<span class="lineno" id=line240></span>  
<span class="lineno" id=line241></span>        <span class="comment">// It's very unfortunate that memcmp doesn't return the position of the</span>
<span class="lineno" id=line242></span>        <span class="comment">// first non-equality</span>
<span class="lineno" id=line243></span>        cmp = Memory::memcmp(buf1, buf2, <span class="library" title="binding of C size_t type">size</span> <span class="library" title="number of elements in data structure">len</span>);
<span class="lineno" id=line244></span>  
<span class="lineno" id=line245></span>        <span class="small_keyword" title="conditional">if</span> cmp == 0 <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line246></span>          cmp = len1 - len2;
<span class="lineno" id=line247></span>          <span class="small_keyword" title="conditional">if</span> cmp == 0 <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line248></span>            terminated = eof1 <span class="small_keyword" title="logical conjunction">and</span> eof2;
<span class="lineno" id=line249></span>            cmp =
<span class="lineno" id=line250></span>              <span class="comment">// ugg: false = case 0, true = case 1</span>
<span class="lineno" id=line251></span>              <span class="small_keyword" title="match statement or expression">match</span> eof1, eof2 <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line252></span>              | <span class="small_keyword" title="Sum type selector">case</span> 1, <span class="small_keyword" title="Sum type selector">case</span> 1 =&gt; 0
<span class="lineno" id=line253></span>              | <span class="small_keyword" title="Sum type selector">case</span> 0, <span class="small_keyword" title="Sum type selector">case</span> 0 =&gt; 0
<span class="lineno" id=line254></span>              | <span class="small_keyword" title="Sum type selector">case</span> 0, <span class="small_keyword" title="Sum type selector">case</span> 1 =&gt; 1
<span class="lineno" id=line255></span>              | <span class="small_keyword" title="Sum type selector">case</span> 1, <span class="small_keyword" title="Sum type selector">case</span> 0 =&gt; -1
<span class="lineno" id=line256></span>              <span class="small_keyword" title="end a match statement or expression">endmatch</span>
<span class="lineno" id=line257></span>            ;
<span class="lineno" id=line258></span>          <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line259></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line260></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line261></span>  
<span class="lineno" id=line262></span>      sign &lt;- cmp;
<span class="lineno" id=line263></span>    }
<span class="lineno" id=line264></span>  
<span class="lineno" id=line265></span>  
<span class="lineno" id=line266></span>    publish <span class="fstring">"Compare the results of two streams."</span>
<span class="lineno" id=line267></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> cmp[istr1, istr2 <span class="small_keyword" title="type-class constraint">with</span> IByteStream[istr1], IByteStream[istr2]] (
<span class="lineno" id=line268></span>      istream1: istr1,
<span class="lineno" id=line269></span>      istream2: istr2,
<span class="lineno" id=line270></span>      res: &amp;<span class="library" title="binding of C int type">int</span>)
<span class="lineno" id=line271></span>    {
<span class="lineno" id=line272></span>      <span class="big_keyword" title="Define an immutable value">val</span> BUFSIZE = 100000;
<span class="lineno" id=line273></span>      <span class="big_keyword" title="Define a mutable variable">var</span> buf1 = Memory::malloc(BUFSIZE);
<span class="lineno" id=line274></span>      <span class="big_keyword" title="Define a mutable variable">var</span> buf2 = Memory::malloc(BUFSIZE);
<span class="lineno" id=line275></span>      stream_cmp(istream1, istream2, buf1, buf2, BUFSIZE, res);
<span class="lineno" id=line276></span>      Memory::free(buf1);
<span class="lineno" id=line277></span>      Memory::free(buf2);
<span class="lineno" id=line278></span>    }
<span class="lineno" id=line279></span>  
<span class="lineno" id=line280></span>    publish <span class="fstring">"Read the results of a stream back into it's stream."</span>
<span class="lineno" id=line281></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> echo[iostr <span class="small_keyword" title="type-class constraint">with</span> IOByteStream[iostr]] (
<span class="lineno" id=line282></span>      iostream: iostr,
<span class="lineno" id=line283></span>      buf: <span class="library" title="special binding of C void* type">address</span>,
<span class="lineno" id=line284></span>      bufsize: <span class="library" title="binding of C int type">int</span>)
<span class="lineno" id=line285></span>    {
<span class="lineno" id=line286></span>      <span class="comment">// echo a = cat a a. that's deep, man.</span>
<span class="lineno" id=line287></span>      cat(iostream, iostream, buf, bufsize);
<span class="lineno" id=line288></span>    }
<span class="lineno" id=line289></span>  
<span class="lineno" id=line290></span>    publish <span class="fstring">"Read in from a stream and write to two streams."</span>
<span class="lineno" id=line291></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> tee[istr,ostr <span class="small_keyword" title="type-class constraint">with</span> IByteStream[istr], OByteStream[ostr]] (
<span class="lineno" id=line292></span>      istream: istr,
<span class="lineno" id=line293></span>      ostream1: ostr,
<span class="lineno" id=line294></span>      ostream2: ostr)
<span class="lineno" id=line295></span>    {
<span class="lineno" id=line296></span>      <span class="big_keyword" title="Define a mutable variable">var</span> reof  = <span class="library" title="false value">false</span>;
<span class="lineno" id=line297></span>      <span class="big_keyword" title="Define a mutable variable">var</span> weof1 = <span class="library" title="false value">false</span>;
<span class="lineno" id=line298></span>      <span class="big_keyword" title="Define a mutable variable">var</span> weof2 = <span class="library" title="false value">false</span>;
<span class="lineno" id=line299></span>      <span class="big_keyword" title="Define a mutable variable">var</span> <span class="library" title="number of elements in data structure">len</span>: <span class="library" title="binding of C int type">int</span>;
<span class="lineno" id=line300></span>  
<span class="lineno" id=line301></span>      <span class="big_keyword" title="Define an immutable value">val</span> BUFSIZE = 10*1024;
<span class="lineno" id=line302></span>      <span class="big_keyword" title="Define a mutable variable">var</span> buf = Memory::malloc(BUFSIZE);
<span class="lineno" id=line303></span>  
<span class="lineno" id=line304></span>      <span class="comment">// don't hammer!</span>
<span class="lineno" id=line305></span>      <span class="small_keyword" title="while loop">while</span> <span class="small_keyword" title="logical negation">not</span> reof <span class="small_keyword" title="logical conjunction">and</span> <span class="small_keyword" title="logical negation">not</span> weof1 <span class="small_keyword" title="logical conjunction">and</span> <span class="small_keyword" title="logical negation">not</span> weof2 <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line306></span>        <span class="library" title="number of elements in data structure">len</span> = BUFSIZE;
<span class="lineno" id=line307></span>        read  (istream,  &amp;<span class="library" title="number of elements in data structure">len</span>, buf, &amp;reof);
<span class="lineno" id=line308></span>        <span class="library" title="Print a string to a stream">write</span> (ostream1, &amp;<span class="library" title="number of elements in data structure">len</span>, buf, &amp;weof1);
<span class="lineno" id=line309></span>        <span class="library" title="Print a string to a stream">write</span> (ostream2, &amp;<span class="library" title="number of elements in data structure">len</span>, buf, &amp;weof2);
<span class="lineno" id=line310></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line311></span>  
<span class="lineno" id=line312></span>      Memory::free buf;
<span class="lineno" id=line313></span>    }
<span class="lineno" id=line314></span>  
<span class="lineno" id=line315></span>    <span class="comment">// highly inefficient!</span>
<span class="lineno" id=line316></span>    <span class="qualifier" title="Function or procedure which must not be inlined">noinline</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> get_line[istr <span class="small_keyword" title="type-class constraint">with</span> IByteStream[istr]] (
<span class="lineno" id=line317></span>      istream: istr,
<span class="lineno" id=line318></span>      s: &amp;<span class="library" title="binding of C++ string type">string</span>)
<span class="lineno" id=line319></span>    {
<span class="lineno" id=line320></span>  <span class="comment">//println$ "get_line starts";</span>
<span class="lineno" id=line321></span>      <span class="big_keyword" title="Define a mutable variable">var</span> c: <span class="library" title="binding of C char type">char</span>;
<span class="lineno" id=line322></span>      <span class="big_keyword" title="Define an immutable value">val</span> ac = <span class="library" title="special binding of C void* type">address</span> (&amp;c);
<span class="lineno" id=line323></span>      <span class="big_keyword" title="Define a mutable variable">var</span> st: <span class="library" title="binding of C++ string type">string</span>=<span class="fstring">""</span>;
<span class="lineno" id=line324></span>      <span class="big_keyword" title="Define a mutable variable">var</span> finished = <span class="library" title="false value">false</span>;
<span class="lineno" id=line325></span>  
<span class="lineno" id=line326></span>      <span class="small_keyword" title="while loop">while</span> <span class="small_keyword" title="logical negation">not</span> finished <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line327></span>        <span class="big_keyword" title="Define a mutable variable">var</span> <span class="library" title="number of elements in data structure">len</span> = 1;
<span class="lineno" id=line328></span>        <span class="big_keyword" title="Define a mutable variable">var</span> eof: bool;
<span class="lineno" id=line329></span>  
<span class="lineno" id=line330></span>  <span class="comment">//println$ "read 1 byte";</span>
<span class="lineno" id=line331></span>        read(istream, &amp;<span class="library" title="number of elements in data structure">len</span>, ac, &amp;eof);
<span class="lineno" id=line332></span>  <span class="comment">//println$ if eof then "EOF" else "not EOF" endif;</span>
<span class="lineno" id=line333></span>  <span class="comment">//println$ "Char = " + str(ord c) + "='"+str c+"'";</span>
<span class="lineno" id=line334></span>        <span class="small_keyword" title="conditional">if</span> eof <span class="small_keyword" title="logical disjunction">or</span> c == <span class="library" title="binding of C char type">char</span> <span class="fstring">'\n'</span> <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line335></span>          finished = <span class="library" title="truth value">true</span>;
<span class="lineno" id=line336></span>        <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line337></span>          st += c;
<span class="lineno" id=line338></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line339></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line340></span>      s &lt;- st;  <span class="comment">// pass back result</span>
<span class="lineno" id=line341></span>    }
<span class="lineno" id=line342></span>  
<span class="lineno" id=line343></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> write_string[ostr <span class="small_keyword" title="type-class constraint">with</span> OByteStream[ostr]] (
<span class="lineno" id=line344></span>      ostream: ostr,
<span class="lineno" id=line345></span>      <span class="big_keyword" title="Define a mutable variable">var</span> s: <span class="library" title="binding of C++ string type">string</span>,
<span class="lineno" id=line346></span>      eof: &amp;bool)
<span class="lineno" id=line347></span>    {
<span class="lineno" id=line348></span>      <span class="big_keyword" title="Define a mutable variable">var</span> slen = s.<span class="library" title="number of elements in data structure">len</span>.<span class="library" title="binding of C int type">int</span>;
<span class="lineno" id=line349></span>      <span class="big_keyword" title="Define a mutable variable">var</span> a = <span class="hack">C_hack</span>::cast[<span class="library" title="special binding of C void* type">address</span>]$ cstr s;
<span class="lineno" id=line350></span>      <span class="library" title="Print a string to a stream">write</span>(ostream, &amp;slen, a, eof);
<span class="lineno" id=line351></span>    }
<span class="lineno" id=line352></span>  } <span class="comment">// class Stream</span>
<span class="lineno" id=line353></span>  
</pre></p></div><h1 id='TCP/IP_Sockets_h'><img src='/share/src/web/images/minus.gif' id='TCP/IP Sockets' onclick='toggle(this,"TCP/IP_Sockets_d")' alt='+'/> 6 TCP/IP Sockets</h1><div id='TCP/IP_Sockets_d' style='display:block'>
<p>These sockets are ONLY for TCP/IP.
</p><pre class='inclusion'>
share/lib/std/io/socket.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Define a type class">class</span> Socket_class[socket_t] {
<span class="lineno" id=line3></span>    <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"demux"</span>;
<span class="lineno" id=line4></span>  
<span class="lineno" id=line5></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> mk_listener: &amp;socket_t * &amp;<span class="library" title="binding of C int type">int</span> * <span class="library" title="binding of C int type">int</span>;
<span class="lineno" id=line6></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> accept: socket_t * &amp;socket_t;
<span class="lineno" id=line7></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> shutdown: socket_t * <span class="library" title="binding of C int type">int</span>;
<span class="lineno" id=line8></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> connect: &amp;socket_t * +<span class="library" title="binding of C char type">char</span> * <span class="library" title="binding of C int type">int</span> * &amp;<span class="library" title="binding of C int type">int</span>;
<span class="lineno" id=line9></span>  
<span class="lineno" id=line10></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> IOStream::IByteStream[socket_t];
<span class="lineno" id=line11></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> IOStream::OByteStream[socket_t];
<span class="lineno" id=line12></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> IOStream::IOByteStream[socket_t];
<span class="lineno" id=line13></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> IOStream::TerminalIByteStream[socket_t];
<span class="lineno" id=line14></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> IOStream::TerminalOByteStream[socket_t];
<span class="lineno" id=line15></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> IOStream::TerminalIOByteStream[socket_t];
<span class="lineno" id=line16></span>  }
<span class="lineno" id=line17></span>  
</pre></p></div><h1 id='Posix_sockets_h'><img src='/share/src/web/images/minus.gif' id='Posix sockets' onclick='toggle(this,"Posix_sockets_d")' alt='+'/> 7 Posix sockets</h1><div id='Posix_sockets_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/io/socket.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Define a type class">class</span> PosixSocket
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"demux"</span>;
<span class="lineno" id=line4></span>    <span class="big_keyword" title="Define an alias for a type expression">typedef</span> socket_t = Faio_posix::socket_t;
<span class="lineno" id=line5></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> Socket_class[socket_t];
<span class="lineno" id=line6></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> Socket_class[socket_t]
<span class="lineno" id=line7></span>    {
<span class="lineno" id=line8></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> mk_listener (l:&amp;socket_t, port: &amp;<span class="library" title="binding of C int type">int</span>, qlen:<span class="library" title="binding of C int type">int</span>) =&gt;
<span class="lineno" id=line9></span>        Faio_posix::mk_listener(l, port, qlen)
<span class="lineno" id=line10></span>      ;
<span class="lineno" id=line11></span>  
<span class="lineno" id=line12></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> accept (l:socket_t, s:&amp;socket_t) =&gt;
<span class="lineno" id=line13></span>        Faio_posix::accept(s, l)  <span class="comment">// success or not? error checking</span>
<span class="lineno" id=line14></span>      ;
<span class="lineno" id=line15></span>  
<span class="lineno" id=line16></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> shutdown(s: socket_t, how: <span class="library" title="binding of C int type">int</span>) =&gt;
<span class="lineno" id=line17></span>        Faio_posix::shutdown(s, how)
<span class="lineno" id=line18></span>      ;
<span class="lineno" id=line19></span>  
<span class="lineno" id=line20></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> connect(s: &amp;socket_t, addr: +<span class="library" title="binding of C char type">char</span>, port: <span class="library" title="binding of C int type">int</span>, err: &amp;<span class="library" title="binding of C int type">int</span>) =&gt;
<span class="lineno" id=line21></span>          Faio_posix::connect(s, addr, port, err)
<span class="lineno" id=line22></span>      ;
<span class="lineno" id=line23></span>  
<span class="lineno" id=line24></span>    }
<span class="lineno" id=line25></span>  
<span class="lineno" id=line26></span>    <span class="comment">//</span>
<span class="lineno" id=line27></span>    <span class="comment">// socket_t</span>
<span class="lineno" id=line28></span>    <span class="comment">//</span>
<span class="lineno" id=line29></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> IOStream::IByteStream[socket_t]
<span class="lineno" id=line30></span>    {
<span class="lineno" id=line31></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> read(s: socket_t, <span class="library" title="number of elements in data structure">len</span>: &amp;<span class="library" title="binding of C int type">int</span>, buf: <span class="library" title="special binding of C void* type">address</span>, eof: &amp;bool)
<span class="lineno" id=line32></span>        { Faio_posix::async_read(s, <span class="library" title="number of elements in data structure">len</span>, buf, eof); }
<span class="lineno" id=line33></span>    }
<span class="lineno" id=line34></span>  
<span class="lineno" id=line35></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> IOStream::OByteStream[socket_t]
<span class="lineno" id=line36></span>    {
<span class="lineno" id=line37></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> <span class="library" title="Print a string to a stream">write</span>(s: socket_t, <span class="library" title="number of elements in data structure">len</span>: &amp;<span class="library" title="binding of C int type">int</span>, buf: <span class="library" title="special binding of C void* type">address</span>, eof: &amp;bool)
<span class="lineno" id=line38></span>        {
<span class="lineno" id=line39></span>          <span class="comment">//println$ "faio/socket.flx: Stream::OByteStream[socket_t]: write(s,"+str (*len)+",buf,"+str(*eof)+") calling async_write ..";</span>
<span class="lineno" id=line40></span>          Faio_posix::async_write(s, <span class="library" title="number of elements in data structure">len</span>, buf, eof);
<span class="lineno" id=line41></span>          <span class="comment">//println$ "faio/socket.flx: Stream::OByteStream[socket_t]: write(s,"+str (*len)+",buf,"+str(*eof)+") called async_write ..";</span>
<span class="lineno" id=line42></span>        }
<span class="lineno" id=line43></span>    }
<span class="lineno" id=line44></span>  
<span class="lineno" id=line45></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> IOStream::IOByteStream[socket_t] {}
<span class="lineno" id=line46></span>  
<span class="lineno" id=line47></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> IOStream::TerminalIByteStream[socket_t]
<span class="lineno" id=line48></span>    {
<span class="lineno" id=line49></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> iclose (s:socket_t)
<span class="lineno" id=line50></span>        { Faio_posix::shutdown (s,0); Faio_posix::close s; }
<span class="lineno" id=line51></span>    }
<span class="lineno" id=line52></span>  
<span class="lineno" id=line53></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> IOStream::TerminalOByteStream[socket_t]
<span class="lineno" id=line54></span>    {
<span class="lineno" id=line55></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> oclose (s:socket_t)
<span class="lineno" id=line56></span>        { Faio_posix::shutdown (s,1); Faio_posix::close s; }
<span class="lineno" id=line57></span>    }
<span class="lineno" id=line58></span>  
<span class="lineno" id=line59></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> IOStream::TerminalIOByteStream[socket_t]
<span class="lineno" id=line60></span>    {
<span class="lineno" id=line61></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> ioclose (s:socket_t)
<span class="lineno" id=line62></span>        {
<span class="lineno" id=line63></span>          <span class="comment">// RF: just close, I don't think any of this stuff is necessary.</span>
<span class="lineno" id=line64></span>          <span class="comment">// I think this is an application level problem.</span>
<span class="lineno" id=line65></span>          <span class="comment">//fprint (cstderr,q"STREAM:Closing socket $s\n");</span>
<span class="lineno" id=line66></span>          <span class="comment">//Faio_posix::shutdown(s,2);</span>
<span class="lineno" id=line67></span>          <span class="comment">//Faio::sleep (Faio::sys_clock,5.0);</span>
<span class="lineno" id=line68></span>          <span class="comment">/*
<span class="lineno" id=line69></span>          var len = 1; var eof = false; var buf = Memory::malloc(1);
<span class="lineno" id=line70></span>          Faio_posix::async_read(s, &amp;len, buf, &amp;eof);
<span class="lineno" id=line71></span>          fprint (cstderr,q"STREAM:socket $s, eof=$eof\n");
<span class="lineno" id=line72></span>          Faio_posix::shutdown(s,0);
<span class="lineno" id=line73></span>          */</span>
<span class="lineno" id=line74></span>          Faio_posix::close s;
<span class="lineno" id=line75></span>        }
<span class="lineno" id=line76></span>    }
<span class="lineno" id=line77></span>      
<span class="lineno" id=line78></span>  }
<span class="lineno" id=line79></span>  
</pre></p></div><h1 id='Windows_sockets_h'><img src='/share/src/web/images/minus.gif' id='Windows sockets' onclick='toggle(this,"Windows_sockets_d")' alt='+'/> 8 Windows sockets</h1><div id='Windows_sockets_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/io/socket.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Define a type class">class</span> Win32Socket
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"demux"</span>;
<span class="lineno" id=line4></span>    <span class="big_keyword" title="Define an alias for a type expression">typedef</span> socket_t = Faio_win32::socket_t;
<span class="lineno" id=line5></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> Socket_class[socket_t];
<span class="lineno" id=line6></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> Socket_class[socket_t]
<span class="lineno" id=line7></span>    {
<span class="lineno" id=line8></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> mk_listener (l:&amp;socket_t, port: &amp;<span class="library" title="binding of C int type">int</span>, qlen:<span class="library" title="binding of C int type">int</span>) =&gt;
<span class="lineno" id=line9></span>        Faio_win32::mk_listener(l, port, qlen)
<span class="lineno" id=line10></span>      ;
<span class="lineno" id=line11></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> accept (<span class="big_keyword" title="Define a mutable variable">var</span> l:socket_t, s:&amp;socket_t) 
<span class="lineno" id=line12></span>      {
<span class="lineno" id=line13></span>        <span class="big_keyword" title="Define a mutable variable">var</span> success: bool;
<span class="lineno" id=line14></span>        Faio_win32::mk_socket(s);  <span class="comment">// error check?</span>
<span class="lineno" id=line15></span>        Faio_win32::Accept(&amp;success, l, *s);
<span class="lineno" id=line16></span>        <span class="small_keyword" title="conditional">if</span> <span class="small_keyword" title="logical negation">not</span> success <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line17></span>          fprint (cstdout, <span class="fstring">"Accept failed! num?\n"</span>);
<span class="lineno" id=line18></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line19></span>      }
<span class="lineno" id=line20></span>  
<span class="lineno" id=line21></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> shutdown(s: socket_t, how: <span class="library" title="binding of C int type">int</span>) =&gt;
<span class="lineno" id=line22></span>        Faio_win32::shutdown(s, how)
<span class="lineno" id=line23></span>      ;
<span class="lineno" id=line24></span>  
<span class="lineno" id=line25></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> connect(s: &amp;socket_t, addr: +<span class="library" title="binding of C char type">char</span>, port: <span class="library" title="binding of C int type">int</span>, err: &amp;<span class="library" title="binding of C int type">int</span>) =&gt;
<span class="lineno" id=line26></span>        Faio_win32::Connect(s, addr, port, err)
<span class="lineno" id=line27></span>      ;
<span class="lineno" id=line28></span>  
<span class="lineno" id=line29></span>    }
<span class="lineno" id=line30></span>  
<span class="lineno" id=line31></span>    <span class="comment">//</span>
<span class="lineno" id=line32></span>    <span class="comment">// socket_t</span>
<span class="lineno" id=line33></span>    <span class="comment">//</span>
<span class="lineno" id=line34></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> IOStream::IByteStream[socket_t]
<span class="lineno" id=line35></span>    {
<span class="lineno" id=line36></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> read(s: socket_t, <span class="library" title="number of elements in data structure">len</span>: &amp;<span class="library" title="binding of C int type">int</span>, buf: <span class="library" title="special binding of C void* type">address</span>, eof: &amp;bool) =&gt;
<span class="lineno" id=line37></span>        Faio_win32::WSARecv(s, <span class="library" title="number of elements in data structure">len</span>, buf, eof)
<span class="lineno" id=line38></span>      ;
<span class="lineno" id=line39></span>    }
<span class="lineno" id=line40></span>  
<span class="lineno" id=line41></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> IOStream::OByteStream[socket_t]
<span class="lineno" id=line42></span>    {
<span class="lineno" id=line43></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> <span class="library" title="Print a string to a stream">write</span>(s: socket_t, <span class="library" title="number of elements in data structure">len</span>: &amp;<span class="library" title="binding of C int type">int</span>, buf: <span class="library" title="special binding of C void* type">address</span>, eof: &amp;bool) =&gt;
<span class="lineno" id=line44></span>        Faio_win32::WSASend(s, <span class="library" title="number of elements in data structure">len</span>, buf, eof)
<span class="lineno" id=line45></span>      ;
<span class="lineno" id=line46></span>    }
<span class="lineno" id=line47></span>  
<span class="lineno" id=line48></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> IOStream::IOByteStream[socket_t] {}
<span class="lineno" id=line49></span>  
<span class="lineno" id=line50></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> IOStream::TerminalIByteStream[socket_t]
<span class="lineno" id=line51></span>    {
<span class="lineno" id=line52></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> iclose (s:socket_t) =&gt;
<span class="lineno" id=line53></span>        Faio_win32::closesocket s
<span class="lineno" id=line54></span>      ;
<span class="lineno" id=line55></span>    }
<span class="lineno" id=line56></span>  
<span class="lineno" id=line57></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> IOStream::TerminalOByteStream[socket_t]
<span class="lineno" id=line58></span>    {
<span class="lineno" id=line59></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> oclose (s:socket_t) =&gt;
<span class="lineno" id=line60></span>        Faio_win32::closesocket s
<span class="lineno" id=line61></span>      ;
<span class="lineno" id=line62></span>    }
<span class="lineno" id=line63></span>  
<span class="lineno" id=line64></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> IOStream::TerminalIOByteStream[socket_t]
<span class="lineno" id=line65></span>    {
<span class="lineno" id=line66></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> ioclose (s:socket_t) =&gt;
<span class="lineno" id=line67></span>        Faio_win32::closesocket s
<span class="lineno" id=line68></span>      ;
<span class="lineno" id=line69></span>    }
<span class="lineno" id=line70></span>  }
</pre></p></div><h1 id='Host_sockets_h'><img src='/share/src/web/images/minus.gif' id='Host sockets' onclick='toggle(this,"Host_sockets_d")' alt='+'/> 9 Host sockets</h1><div id='Host_sockets_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/io/socket.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Define a type class">class</span> Socket
<span class="lineno" id=line3></span>  {
<span class="lineno" id=line4></span>    <span class="small_keyword" title="conditional">if</span> PLAT_WIN32 <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line5></span>      <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> Win32Socket;
<span class="lineno" id=line6></span>    <span class="small_keyword" title="conditional">elif</span> PLAT_POSIX <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line7></span>       <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> PosixSocket;
<span class="lineno" id=line8></span>    <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line9></span>       ERROR;
<span class="lineno" id=line10></span>    <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line11></span>  }
</pre></p></div><h1 id='Demux:_Felix_Event_notification_service_h'><img src='/share/src/web/images/minus.gif' id='Demux: Felix Event notification service' onclick='toggle(this,"Demux:_Felix_Event_notification_service_d")' alt='+'/> 10 Demux: Felix Event notification service</h1><div id='Demux:_Felix_Event_notification_service_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/io/demux.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Define a type class">class</span> Demux
<span class="lineno" id=line3></span>  {
<span class="lineno" id=line4></span>    <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> demuxer = <span class="fstring">"::flx::demux::flx_demuxer_t*"</span>
<span class="lineno" id=line5></span>      <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"demux"</span>
<span class="lineno" id=line6></span>    ;
<span class="lineno" id=line7></span>    <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> mk_sys_demux: 1-&gt;demuxer = <span class="fstring">"::flx::demux::make_std_demuxer()"</span>;
<span class="lineno" id=line8></span>    <span class="big_keyword" title="Define a mutable variable">var</span> sys_demux =  mk_sys_demux();
<span class="lineno" id=line9></span>  }
<span class="lineno" id=line10></span>  
</pre></p></div><h1 id='Faio:_Felix_Asynchronous_I/O_service_h'><img src='/share/src/web/images/minus.gif' id='Faio: Felix Asynchronous I/O service' onclick='toggle(this,"Faio:_Felix_Asynchronous_I/O_service_d")' alt='+'/> 11 Faio: Felix Asynchronous I/O service</h1><div id='Faio:_Felix_Asynchronous_I/O_service_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/io/faio.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Define a type class">class</span> Faio {
<span class="lineno" id=line3></span>    <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"demux"</span>;
<span class="lineno" id=line4></span>    <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"faio"</span>;
<span class="lineno" id=line5></span>  
<span class="lineno" id=line6></span>    <span class="big_keyword" title="Open a module or class">open</span> <span class="hack">C_hack</span>;
<span class="lineno" id=line7></span>  
<span class="lineno" id=line8></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> faio_req[t](preq: &amp;t ) { <span class="comment">// FIXME: HACK! It has to be driver request base</span>
<span class="lineno" id=line9></span>      <span class="big_keyword" title="Define a mutable variable">var</span> p = <span class="hack">C_hack</span>::cast[driver_request_base]preq;
<span class="lineno" id=line10></span>      svc (svc_general p);
<span class="lineno" id=line11></span>    }
<span class="lineno" id=line12></span>  
<span class="lineno" id=line13></span>  <span class="comment">// this svc call doesn't exist now </span>
<span class="lineno" id=line14></span>  <span class="comment">/*
<span class="lineno" id=line15></span>    proc get_thread(thread: &amp;fthread) {
<span class="lineno" id=line16></span>        svc (svc_get_fthread thread );
<span class="lineno" id=line17></span>    }
<span class="lineno" id=line18></span>  */</span>
<span class="lineno" id=line19></span>  
<span class="lineno" id=line20></span>    <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> sel_param = <span class="fstring">"flx::demux::sel_param"</span>;
<span class="lineno" id=line21></span>  
<span class="lineno" id=line22></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> get_bytes_done : &amp;sel_param -&gt; <span class="library" title="binding of C int type">int</span> = <span class="fstring">'$1-&gt;bytes_written'</span>;
<span class="lineno" id=line23></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> init_pb : &amp;sel_param*<span class="library" title="special binding of C void* type">address</span>*<span class="library" title="binding of C int type">int</span>
<span class="lineno" id=line24></span>    = <span class="fstring">'{$1-&gt;buffer=(char*)$2;$1-&gt;buffer_size=$3;$1-&gt;bytes_written=0;}'</span>;
<span class="lineno" id=line25></span>  
<span class="lineno" id=line26></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> calc_eof(pb: &amp;sel_param, <span class="library" title="number of elements in data structure">len</span>: &amp;<span class="library" title="binding of C int type">int</span>, eof: &amp;bool)
<span class="lineno" id=line27></span>    {
<span class="lineno" id=line28></span>        <span class="comment">//println "Calc_eof ..";</span>
<span class="lineno" id=line29></span>        <span class="big_keyword" title="Define a mutable variable">var</span> bytes_done = pb.get_bytes_done;
<span class="lineno" id=line30></span>        <span class="comment">//println$ "Bytes done = "+ str bytes_done;</span>
<span class="lineno" id=line31></span>        <span class="comment">//println$ "Req len= "+ str (*len);</span>
<span class="lineno" id=line32></span>        eof &lt;- (bytes_done != *<span class="library" title="number of elements in data structure">len</span>);
<span class="lineno" id=line33></span>        <span class="comment">//println$ "Eof = " + str (*eof);</span>
<span class="lineno" id=line34></span>        <span class="library" title="number of elements in data structure">len</span> &lt;- bytes_done;
<span class="lineno" id=line35></span>        <span class="comment">//println$ "Reset len to bytes done ..";</span>
<span class="lineno" id=line36></span>    }
<span class="lineno" id=line37></span>  
<span class="lineno" id=line38></span>    <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> sleep_request_t = <span class="fstring">'flx::faio::sleep_request'</span> <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"timer"</span>;
<span class="lineno" id=line39></span>    <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> alarm_clock_t = <span class="fstring">'flx::demux::timer_queue*'</span> <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"timer"</span>; 
<span class="lineno" id=line40></span>  
<span class="lineno" id=line41></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> mk_alarm_clock: 1 -&gt; alarm_clock_t = <span class="fstring">'::flx::demux::mk_timer_queue()'</span>;
<span class="lineno" id=line42></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> mk_sleep_request: alarm_clock_t * <span class="library" title="binding of C double float type">double</span> -&gt; sleep_request_t = <span class="fstring">'::flx::faio::sleep_request($1,$2)'</span>;
<span class="lineno" id=line43></span>  
<span class="lineno" id=line44></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> sleep(clock: alarm_clock_t, delta: <span class="library" title="binding of C double float type">double</span>)
<span class="lineno" id=line45></span>    {
<span class="lineno" id=line46></span>      <span class="big_keyword" title="Define a mutable variable">var</span> sr = mk_sleep_request$ clock,delta;
<span class="lineno" id=line47></span>      faio_req$ &amp;sr;
<span class="lineno" id=line48></span>    }
<span class="lineno" id=line49></span>  
<span class="lineno" id=line50></span>    <span class="comment">// this should be deleted if not used!</span>
<span class="lineno" id=line51></span>    <span class="big_keyword" title="Define a mutable variable">var</span> clock = mk_alarm_clock();
<span class="lineno" id=line52></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> sleep (delta:<span class="library" title="binding of C double float type">double</span>) { sleep (clock,delta); }
<span class="lineno" id=line53></span>  
<span class="lineno" id=line54></span>  } <span class="comment">// class faio</span>
<span class="lineno" id=line55></span>  
</pre></p></div><h1 id='Posix_Faio_h'><img src='/share/src/web/images/minus.gif' id='Posix Faio' onclick='toggle(this,"Posix_Faio_d")' alt='+'/> 12 Posix Faio</h1><div id='Posix_Faio_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/posix/faio_posix.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Define a type class">class</span> Faio_posix  {
<span class="lineno" id=line3></span>  <span class="big_keyword" title="Specify C code to be inserted into header file">header</span> faio_posixio_hpp = '<span class="embedded_c">#<span class="preproc">include</span> <span class="fstring">"faio_posixio.hpp"</span></span>';
<span class="lineno" id=line4></span>  <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"demux"</span>;
<span class="lineno" id=line5></span>  <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"faio"</span>;
<span class="lineno" id=line6></span>  <span class="big_keyword" title="Open a module or class">open</span> <span class="hack">C_hack</span>;        <span class="comment">// cast, address</span>
<span class="lineno" id=line7></span>  <span class="big_keyword" title="Open a module or class">open</span> Faio;
<span class="lineno" id=line8></span>  <span class="big_keyword" title="Open a module or class">open</span> Pthread;
<span class="lineno" id=line9></span>  <span class="big_keyword" title="Open a module or class">open</span> Demux;
<span class="lineno" id=line10></span>  <span class="big_keyword" title="Open a module or class">open</span> Posix_headers;
<span class="lineno" id=line11></span>  
<span class="lineno" id=line12></span>  <span class="big_keyword" title="Specify C code to be inserted into header file">header</span> sockety_h = '<span class="embedded_c">#<span class="preproc">include</span> <span class="fstring">"demux_sockety.hpp"</span></span>';  <span class="comment">// my socket utils</span>
<span class="lineno" id=line13></span>  <span class="big_keyword" title="Specify C code to be inserted into header file">header</span> '<span class="embedded_c">#<span class="preproc">include</span> <span class="fstring">"faio_posixio.hpp"</span></span>';
<span class="lineno" id=line14></span>  
<span class="lineno" id=line15></span>  <span class="comment">// ------------ core file and socket definitions ----------------</span>
<span class="lineno" id=line16></span>  <span class="big_keyword" title="Define an alias for a type expression">typedef</span> fd_t = PosixFileSystem::posix_file;
<span class="lineno" id=line17></span>  
<span class="lineno" id=line18></span>  <span class="comment">// type of a socket</span>
<span class="lineno" id=line19></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> socket_t = <span class="fstring">"int"</span>;
<span class="lineno" id=line20></span>  
<span class="lineno" id=line21></span>  <span class="comment">// a size type for use in some socket functions</span>
<span class="lineno" id=line22></span>  <span class="comment">// stupid confused Unix standard!</span>
<span class="lineno" id=line23></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> socklen_t=<span class="fstring">"socklen_t"</span> <span class="big_keyword" title="specify requirements">requires</span> sockety_h;
<span class="lineno" id=line24></span>  <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> socklen_t : <span class="library" title="binding of C int type">int</span> = <span class="fstring">"$1"</span>;
<span class="lineno" id=line25></span>  <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> <span class="library" title="binding of C int type">int</span> : socklen_t = <span class="fstring">"$1"</span>;
<span class="lineno" id=line26></span>  
<span class="lineno" id=line27></span>  <span class="comment">// A socket address consists of </span>
<span class="lineno" id=line28></span>  <span class="comment">// 1. a port number</span>
<span class="lineno" id=line29></span>  <span class="comment">// 2. an address family indicator</span>
<span class="lineno" id=line30></span>  <span class="comment">// 3. the encoded address, dependent on the family</span>
<span class="lineno" id=line31></span>  <span class="comment">//</span>
<span class="lineno" id=line32></span>  <span class="comment">// We deal only with Internet addresses IPv4 and IPv6,</span>
<span class="lineno" id=line33></span>  <span class="comment">// indicator AF_INET and AF_INET6</span>
<span class="lineno" id=line34></span>  <span class="comment">//</span>
<span class="lineno" id=line35></span>  <span class="comment">// type of socket address protocol family</span>
<span class="lineno" id=line36></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> sa_family_t = <span class="fstring">"sa_family_t"</span> <span class="big_keyword" title="specify requirements">requires</span> sys_socket_h;
<span class="lineno" id=line37></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> ==: sa_family_t * sa_family_t -&gt; bool = <span class="fstring">"$1==$2"</span>;
<span class="lineno" id=line38></span>  
<span class="lineno" id=line39></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> in_port_t = <span class="fstring">"in_port_t"</span> <span class="big_keyword" title="specify requirements">requires</span> netinet_in_h;
<span class="lineno" id=line40></span>  
<span class="lineno" id=line41></span>  <span class="big_keyword" title="Bind a Felix symbol to a C expression">const</span> AF_INET : sa_family_t;
<span class="lineno" id=line42></span>  <span class="big_keyword" title="Bind a Felix symbol to a C expression">const</span> AF_INET6 : sa_family_t;
<span class="lineno" id=line43></span>  
<span class="lineno" id=line44></span>  <span class="comment">// type to allocate on stack to hold any socket address for any protocol</span>
<span class="lineno" id=line45></span>  <span class="comment">// required for stack allocations</span>
<span class="lineno" id=line46></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> sockaddr_storage_t = <span class="fstring">"struct sockaddr_storage"</span> <span class="big_keyword" title="specify requirements">requires</span> sockety_h;
<span class="lineno" id=line47></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> ss_family : &amp;sockaddr_storage_t -&gt; sa_family_t = <span class="fstring">"$1-&gt;ss_family"</span>;
<span class="lineno" id=line48></span>  
<span class="lineno" id=line49></span>  <span class="comment">// type of a socket address</span>
<span class="lineno" id=line50></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> sockaddr_t = <span class="fstring">"struct sockaddr"</span> <span class="big_keyword" title="specify requirements">requires</span> sockety_h;
<span class="lineno" id=line51></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> sa_family : &amp;sockaddr_t -&gt; sa_family_t = <span class="fstring">"$1-&gt;sa_family"</span>;
<span class="lineno" id=line52></span>  
<span class="lineno" id=line53></span>  <span class="comment">// cast socket address storage object pointer to socket address pointer</span>
<span class="lineno" id=line54></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> sockaddr_p : &amp;sockaddr_storage_t -&gt; &amp;sockaddr_t = <span class="fstring">"(struct sockaddr*)$1"</span>;
<span class="lineno" id=line55></span>  <span class="big_keyword" title="Specify core semantics">axiom</span> inet_family(ss: &amp;sockaddr_storage_t) : ss_family ss == sa_family (sockaddr_p ss);
<span class="lineno" id=line56></span>  
<span class="lineno" id=line57></span>  <span class="comment">// --------------------------------------------------------------</span>
<span class="lineno" id=line58></span>  <span class="comment">// IPv4</span>
<span class="lineno" id=line59></span>  <span class="comment">// type containing IPv4 internet address</span>
<span class="lineno" id=line60></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> in_addr_t = <span class="fstring">"in_addr_t"</span> <span class="big_keyword" title="specify requirements">requires</span> netinet_in_h; <span class="comment">// an integer</span>
<span class="lineno" id=line61></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> struct_in_addr = <span class="fstring">"struct in_addr"</span>;
<span class="lineno" id=line62></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> s_addr: struct_in_addr -&gt; in_addr_t = <span class="fstring">"$1.s_addr"</span>;
<span class="lineno" id=line63></span>  
<span class="lineno" id=line64></span>  <span class="comment">// type containing encoded port and IPv4 address</span>
<span class="lineno" id=line65></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> sockaddr_in_t = <span class="fstring">"struct sockaddr_in"</span> <span class="big_keyword" title="specify requirements">requires</span> sockety_h;
<span class="lineno" id=line66></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> sin_family: sockaddr_in_t -&gt; sa_family_t= <span class="fstring">"$1.sin_family"</span>;
<span class="lineno" id=line67></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> sin_port : sockaddr_in_t -&gt; in_port_t= <span class="fstring">"$1.sin_port"</span>;
<span class="lineno" id=line68></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> sin_addr : sockaddr_in_t -&gt; struct_in_addr = <span class="fstring">"$1.sin_addr"</span>;
<span class="lineno" id=line69></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> sin_addr : &amp;sockaddr_in_t -&gt; &amp;struct_in_addr = <span class="fstring">"&amp;($1-&gt;sin_addr)"</span>;
<span class="lineno" id=line70></span>  
<span class="lineno" id=line71></span>  
<span class="lineno" id=line72></span>  <span class="comment">// --------------------------------------------------------------</span>
<span class="lineno" id=line73></span>  <span class="comment">// IPv6</span>
<span class="lineno" id=line74></span>  <span class="comment">// type containing IPv6 internet address</span>
<span class="lineno" id=line75></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> struct_in6_addr = <span class="fstring">"struct in6_addr"</span>;
<span class="lineno" id=line76></span>  <span class="big_keyword" title="Define an alias for a type expression">typedef</span> ipv6_addr = <span class="library" title="binding of C uint8_t type">uint8</span>^16;
<span class="lineno" id=line77></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> s6_addr: struct_in6_addr -&gt; &amp;ipv6_addr = <span class="fstring">"$1.s6_addr"</span>;
<span class="lineno" id=line78></span>  
<span class="lineno" id=line79></span>  <span class="comment">// type containing encoded socket address for IPv6</span>
<span class="lineno" id=line80></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> sockaddr_in6_t = <span class="fstring">"struct sockaddr_in6"</span> <span class="big_keyword" title="specify requirements">requires</span> sockety_h;
<span class="lineno" id=line81></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> sin6_family: sockaddr_in6_t -&gt; sa_family_t= <span class="fstring">"$1.sin6_family"</span>;
<span class="lineno" id=line82></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> sin6_port : sockaddr_in6_t -&gt; in_port_t = <span class="fstring">"$1.sin6_port"</span>;
<span class="lineno" id=line83></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> sin6_addr : sockaddr_in6_t -&gt; struct_in6_addr = <span class="fstring">"$1.sin6_addr"</span>;
<span class="lineno" id=line84></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> sin6_addr : &amp;sockaddr_in6_t -&gt; &amp;struct_in6_addr = <span class="fstring">"&amp;($1-&gt;sin6_addr)"</span>;
<span class="lineno" id=line85></span>  
<span class="lineno" id=line86></span>  
<span class="lineno" id=line87></span>  <span class="comment">// convert Internet address to display format.</span>
<span class="lineno" id=line88></span>  <span class="comment">// $1: Address family</span>
<span class="lineno" id=line89></span>  <span class="comment">// $2: pointer to the address</span>
<span class="lineno" id=line90></span>  <span class="comment">// $3: pointer to output buffer</span>
<span class="lineno" id=line91></span>  <span class="comment">// $4: length of output buffer</span>
<span class="lineno" id=line92></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> inet_ntop: sa_family_t * <span class="library" title="special binding of C void* type">address</span> * +<span class="library" title="binding of C char type">char</span> * socklen_t -&gt; +<span class="library" title="binding of C char type">char</span> <span class="big_keyword" title="specify requirements">requires</span> arpa_inet_h;;
<span class="lineno" id=line93></span>  <span class="big_keyword" title="Bind a Felix symbol to a C expression">const</span> INET_ADDRSTRLEN : socklen_t <span class="big_keyword" title="specify requirements">requires</span> arpa_inet_h;
<span class="lineno" id=line94></span>  <span class="big_keyword" title="Bind a Felix symbol to a C expression">const</span> INET6_ADDRSTRLEN : socklen_t <span class="big_keyword" title="specify requirements">requires</span> arpa_inet_h;
<span class="lineno" id=line95></span>  
<span class="lineno" id=line96></span>  <span class="comment">// --------------------------------------------------------------</span>
<span class="lineno" id=line97></span>  
<span class="lineno" id=line98></span>  <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> Str[FileSystem::posix_file] {
<span class="lineno" id=line99></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="Convert a value to a string">str</span>: FileSystem::posix_file -&gt; <span class="library" title="binding of C++ string type">string</span> = <span class="fstring">"::flx::rtl::strutil::str&lt;int&gt;($1)"</span> <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"flx_strutil"</span>;
<span class="lineno" id=line100></span>  }
<span class="lineno" id=line101></span>  
<span class="lineno" id=line102></span>  <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> Str[socket_t] {
<span class="lineno" id=line103></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="Convert a value to a string">str</span>: socket_t -&gt; <span class="library" title="binding of C++ string type">string</span> = <span class="fstring">"::flx::rtl::strutil::str&lt;int&gt;($1)"</span> <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"flx_strutil"</span>;
<span class="lineno" id=line104></span>  }
<span class="lineno" id=line105></span>  
<span class="lineno" id=line106></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> getpeername: socket_t * &amp;sockaddr_t * &amp;socklen_t -&gt; <span class="library" title="binding of C int type">int</span>;
<span class="lineno" id=line107></span>  
<span class="lineno" id=line108></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> getpeername (s: socket_t) : <span class="library" title="binding of C++ string type">string</span> = 
<span class="lineno" id=line109></span>  {
<span class="lineno" id=line110></span>    <span class="comment">// store for encoded IP address</span>
<span class="lineno" id=line111></span>    <span class="big_keyword" title="Define a mutable variable">var</span> sa:sockaddr_storage_t;
<span class="lineno" id=line112></span>    <span class="big_keyword" title="Define a mutable variable">var</span> paddr : &amp;sockaddr_t = sockaddr_p &amp;sa; <span class="comment">// cast</span>
<span class="lineno" id=line113></span>  
<span class="lineno" id=line114></span>    <span class="comment">// length of encoded IP address</span>
<span class="lineno" id=line115></span>    <span class="big_keyword" title="Define a mutable variable">var</span> nsa = <span class="hack">C_hack</span>::cast[socklen_t] sizeof[sockaddr_storage_t];
<span class="lineno" id=line116></span>  
<span class="lineno" id=line117></span>    <span class="comment">// get encoded peer address</span>
<span class="lineno" id=line118></span>    <span class="big_keyword" title="Define a mutable variable">var</span> res = getpeername (s,  paddr, &amp;nsa);
<span class="lineno" id=line119></span>    <span class="small_keyword" title="conditional">if</span> res == -1 <span class="small_keyword" title="return">return</span> <span class="fstring">""</span>;
<span class="lineno" id=line120></span>  
<span class="lineno" id=line121></span>    <span class="big_keyword" title="Define a mutable variable">var</span> p = <span class="hack">C_hack</span>::cast[+<span class="library" title="binding of C char type">char</span>] null[<span class="library" title="binding of C char type">char</span>]; 
<span class="lineno" id=line122></span>    <span class="big_keyword" title="Define a mutable variable">var</span> ips = <span class="fstring">""</span>;
<span class="lineno" id=line123></span>    <span class="big_keyword" title="Define a mutable variable">var</span> family = ss_family &amp;sa;
<span class="lineno" id=line124></span>    <span class="small_keyword" title="match statement or expression">match</span> family <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line125></span>    | $(AF_INET) =&gt;
<span class="lineno" id=line126></span>      <span class="small_keyword" title="end of extension">begin</span>
<span class="lineno" id=line127></span>        <span class="big_keyword" title="Define a mutable variable">var</span> buffer = <span class="hack">C_hack</span>::cast[+<span class="library" title="binding of C char type">char</span>] (Memory::malloc INET_ADDRSTRLEN.<span class="library" title="binding of C int type">int</span>);
<span class="lineno" id=line128></span>        <span class="comment">// cast to IPv4 socket address</span>
<span class="lineno" id=line129></span>        <span class="big_keyword" title="Define a mutable variable">var</span> inet_sockaddr = <span class="hack">C_hack</span>::cast[&amp;sockaddr_in_t] paddr;
<span class="lineno" id=line130></span>        <span class="comment">// extract pointer to IPv4 internet address</span>
<span class="lineno" id=line131></span>        <span class="big_keyword" title="Define a mutable variable">var</span> p_ipnumber : &amp;struct_in_addr = inet_sockaddr.sin_addr;
<span class="lineno" id=line132></span>        p = inet_ntop
<span class="lineno" id=line133></span>          (
<span class="lineno" id=line134></span>            family, 
<span class="lineno" id=line135></span>            <span class="hack">C_hack</span>::cast[<span class="library" title="special binding of C void* type">address</span>] p_ipnumber, 
<span class="lineno" id=line136></span>            buffer, 
<span class="lineno" id=line137></span>            INET_ADDRSTRLEN
<span class="lineno" id=line138></span>          )
<span class="lineno" id=line139></span>        ;
<span class="lineno" id=line140></span>        <span class="small_keyword" title="conditional">if</span> <span class="small_keyword" title="logical negation">not</span> p.isNULL <span class="small_keyword" title="imperative code begins">do</span> ips = <span class="library" title="Convert a value to a string">str</span> p; <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line141></span>        Memory::free (<span class="hack">C_hack</span>::cast[<span class="library" title="special binding of C void* type">address</span>] buffer);
<span class="lineno" id=line142></span>      <span class="small_keyword" title="end of extension">end</span>
<span class="lineno" id=line143></span>  
<span class="lineno" id=line144></span>    | $(AF_INET6) =&gt;
<span class="lineno" id=line145></span>      <span class="small_keyword" title="end of extension">begin</span>
<span class="lineno" id=line146></span>        <span class="big_keyword" title="Define a mutable variable">var</span> buffer = <span class="hack">C_hack</span>::cast[+<span class="library" title="binding of C char type">char</span>] (Memory::malloc INET6_ADDRSTRLEN.<span class="library" title="binding of C int type">int</span>);
<span class="lineno" id=line147></span>        <span class="comment">// cast to IPv6 socket address</span>
<span class="lineno" id=line148></span>        <span class="big_keyword" title="Define a mutable variable">var</span> inet6_sockaddr = <span class="hack">C_hack</span>::cast[&amp;sockaddr_in6_t] paddr;
<span class="lineno" id=line149></span>        <span class="comment">// extract IPv6 internet address (address of a byte array)</span>
<span class="lineno" id=line150></span>        <span class="big_keyword" title="Define a mutable variable">var</span> p_ip6number : &amp;struct_in6_addr = inet6_sockaddr.sin6_addr;
<span class="lineno" id=line151></span>        p = inet_ntop
<span class="lineno" id=line152></span>          (
<span class="lineno" id=line153></span>            family, 
<span class="lineno" id=line154></span>            <span class="hack">C_hack</span>::cast[<span class="library" title="special binding of C void* type">address</span>] p_ip6number,
<span class="lineno" id=line155></span>            buffer, 
<span class="lineno" id=line156></span>            INET6_ADDRSTRLEN
<span class="lineno" id=line157></span>          )
<span class="lineno" id=line158></span>        ;
<span class="lineno" id=line159></span>        <span class="small_keyword" title="conditional">if</span> <span class="small_keyword" title="logical negation">not</span> p.isNULL <span class="small_keyword" title="imperative code begins">do</span> ips = <span class="library" title="Convert a value to a string">str</span> p; <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line160></span>        Memory::free (<span class="hack">C_hack</span>::cast[<span class="library" title="special binding of C void* type">address</span>] buffer);
<span class="lineno" id=line161></span>      <span class="small_keyword" title="end of extension">end</span>
<span class="lineno" id=line162></span>  
<span class="lineno" id=line163></span>    | _ =&gt; ;
<span class="lineno" id=line164></span>    <span class="small_keyword" title="end a match statement or expression">endmatch</span>
<span class="lineno" id=line165></span>    ;
<span class="lineno" id=line166></span>    <span class="small_keyword" title="return">return</span> ips;
<span class="lineno" id=line167></span>  
<span class="lineno" id=line168></span>  }
<span class="lineno" id=line169></span>  
<span class="lineno" id=line170></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> close: socket_t = <span class="fstring">'close($1);'</span> <span class="big_keyword" title="specify requirements">requires</span> Posix_headers::unistd_h;
<span class="lineno" id=line171></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> shutdown: socket_t*<span class="library" title="binding of C int type">int</span> = <span class="fstring">'shutdown($a);'</span> <span class="big_keyword" title="specify requirements">requires</span> Posix_headers::sys_socket_h;
<span class="lineno" id=line172></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> bad_socket : socket_t -&gt; bool = <span class="fstring">"$1 == -1"</span>;
<span class="lineno" id=line173></span>  
<span class="lineno" id=line174></span>  
<span class="lineno" id=line175></span>  <span class="comment">// socketio_request should be renamed to be async_fd_request</span>
<span class="lineno" id=line176></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> socketio_request = <span class="fstring">"::flx::faio::socketio_request"</span>;
<span class="lineno" id=line177></span>  
<span class="lineno" id=line178></span>  <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> mk_socketio_request: demuxer * socket_t*<span class="library" title="special binding of C void* type">address</span>*<span class="library" title="binding of C int type">int</span>*bool -&gt; socketio_request
<span class="lineno" id=line179></span>      = <span class="fstring">'::flx::faio::socketio_request($1, $2, (char*)$3, $4, $5)'</span>;
<span class="lineno" id=line180></span>  
<span class="lineno" id=line181></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> get_pb: socketio_request -&gt; &amp;sel_param = <span class="fstring">'&amp;$1.sv.pb'</span>;
<span class="lineno" id=line182></span>  
<span class="lineno" id=line183></span>  <span class="comment">// read &amp; write differ only by a flag</span>
<span class="lineno" id=line184></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> async_rw(fd: socket_t, <span class="library" title="number of elements in data structure">len</span>: &amp;<span class="library" title="binding of C int type">int</span>, buf: <span class="library" title="special binding of C void* type">address</span>, eof: &amp;bool, read_flag: bool)
<span class="lineno" id=line185></span>  {
<span class="lineno" id=line186></span>      <span class="comment">//println$ "faio/flx_faoi_posix.flx: async_rw (s,"+str (*len)+",buf,"+str(*eof)+", "+str read_flag+") calling mk_socketio_req ..";</span>
<span class="lineno" id=line187></span>      <span class="big_keyword" title="Define a mutable variable">var</span> asyncb = mk_socketio_request(sys_demux,fd, buf, *<span class="library" title="number of elements in data structure">len</span>, read_flag);
<span class="lineno" id=line188></span>      faio_req$ &amp;asyncb;
<span class="lineno" id=line189></span>      <span class="comment">//println$ "faio/flx_faoi_posix.flx: async_rw ("+ str fd+", "+str (*len)+",buf,"+str(*eof)+", "+str read_flag+") calculating eof ..";</span>
<span class="lineno" id=line190></span>  
<span class="lineno" id=line191></span>      calc_eof(asyncb.get_pb, <span class="library" title="number of elements in data structure">len</span>, eof);
<span class="lineno" id=line192></span>      <span class="comment">//println$ "faio/flx_faoi_posix.flx: async_rw (s,"+str (*len)+",buf,"+str(*eof)+", "+str read_flag+") called mk_socketio_req ..";</span>
<span class="lineno" id=line193></span>  }
<span class="lineno" id=line194></span>  
<span class="lineno" id=line195></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> async_read(fd: socket_t, <span class="library" title="number of elements in data structure">len</span>: &amp;<span class="library" title="binding of C int type">int</span>, buf: <span class="library" title="special binding of C void* type">address</span>,
<span class="lineno" id=line196></span>      eof: &amp;bool)
<span class="lineno" id=line197></span>  {
<span class="lineno" id=line198></span>      async_rw(fd, <span class="library" title="number of elements in data structure">len</span>, buf, eof, <span class="library" title="truth value">true</span>);      <span class="comment">// read</span>
<span class="lineno" id=line199></span>  }
<span class="lineno" id=line200></span>  
<span class="lineno" id=line201></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> async_write(fd: socket_t, <span class="library" title="number of elements in data structure">len</span>: &amp;<span class="library" title="binding of C int type">int</span>, buf: <span class="library" title="special binding of C void* type">address</span>, eof: &amp;bool)
<span class="lineno" id=line202></span>  {
<span class="lineno" id=line203></span>      <span class="comment">//println$ "faio/flx_faoi_posix.flx: async_write(s,"+str (*len)+",buf,"+str(*eof)+" calling async_rw ..";</span>
<span class="lineno" id=line204></span>      async_rw(fd, <span class="library" title="number of elements in data structure">len</span>, buf, eof, <span class="library" title="false value">false</span>);     <span class="comment">// write</span>
<span class="lineno" id=line205></span>      <span class="comment">//println$ "faio/flx_faoi_posix.flx: async_write(s,"+str (*len)+",buf,"+str(*eof)+" call async_rw ..";</span>
<span class="lineno" id=line206></span>  }
<span class="lineno" id=line207></span>  
<span class="lineno" id=line208></span>  <span class="comment">// connect!</span>
<span class="lineno" id=line209></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> async_connect = <span class="fstring">'::flx::faio::connect_request'</span>;
<span class="lineno" id=line210></span>  
<span class="lineno" id=line211></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> mk_async_connect: demuxer * +<span class="library" title="binding of C char type">char</span> *int-&gt; async_connect = <span class="fstring">'::flx::faio::connect_request($a)'</span>;
<span class="lineno" id=line212></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> get_socket: async_connect -&gt; socket_t = <span class="fstring">'$1.s'</span>;
<span class="lineno" id=line213></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> get_err: async_connect -&gt; <span class="library" title="binding of C int type">int</span> = <span class="fstring">'$1.socket_err'</span>;
<span class="lineno" id=line214></span>  
<span class="lineno" id=line215></span>  <span class="comment">// could do multi connects for capable drivers</span>
<span class="lineno" id=line216></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> connect(s: &amp;socket_t, addr: +<span class="library" title="binding of C char type">char</span>, port: <span class="library" title="binding of C int type">int</span>, err: &amp;<span class="library" title="binding of C int type">int</span>)
<span class="lineno" id=line217></span>  {
<span class="lineno" id=line218></span>      <span class="big_keyword" title="Define a mutable variable">var</span> ac = mk_async_connect(sys_demux,addr, port);
<span class="lineno" id=line219></span>      faio_req$ &amp;ac;
<span class="lineno" id=line220></span>      err &lt;- ac.get_err;
<span class="lineno" id=line221></span>      s &lt;- ac.get_socket;
<span class="lineno" id=line222></span>  }
<span class="lineno" id=line223></span>  
<span class="lineno" id=line224></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> accept_request = <span class="fstring">"::flx::faio::accept_request"</span>;
<span class="lineno" id=line225></span>  
<span class="lineno" id=line226></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> mk_accept: demuxer * socket_t -&gt; accept_request = <span class="fstring">'::flx::faio::accept_request($1,$2)'</span>;
<span class="lineno" id=line227></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> get_socket: accept_request -&gt; socket_t = <span class="fstring">'$1.accepted'</span>;
<span class="lineno" id=line228></span>  
<span class="lineno" id=line229></span>  <span class="comment">// arg1 = returned socket, arg2 is port, pass 0 to have one assigned</span>
<span class="lineno" id=line230></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> mk_listener: &amp;socket_t* &amp;<span class="library" title="binding of C int type">int</span> *<span class="library" title="binding of C int type">int</span>
<span class="lineno" id=line231></span>      = <span class="fstring">'*$1 = ::flx::demux::create_async_listener($2, $3);'</span> <span class="big_keyword" title="specify requirements">requires</span> sockety_h;
<span class="lineno" id=line232></span>  
<span class="lineno" id=line233></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> accept(s: &amp;socket_t, listener: socket_t)
<span class="lineno" id=line234></span>  {
<span class="lineno" id=line235></span>      <span class="big_keyword" title="Define a mutable variable">var</span> acc = mk_accept$ sys_demux,listener;
<span class="lineno" id=line236></span>      faio_req$ &amp;acc;
<span class="lineno" id=line237></span>      s &lt;- acc.get_socket;
<span class="lineno" id=line238></span>  }
<span class="lineno" id=line239></span>  
<span class="lineno" id=line240></span>  } <span class="comment">// class faio_posix</span>
<span class="lineno" id=line241></span>  
</pre></p></div><h1 id='Win32_Faio_h'><img src='/share/src/web/images/minus.gif' id='Win32 Faio' onclick='toggle(this,"Win32_Faio_d")' alt='+'/> 13 Win32 Faio</h1><div id='Win32_Faio_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/win32/faio_win32.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  
<span class="lineno" id=line3></span>  <span class="big_keyword" title="Define a module namespace">module</span> Faio_win32 {
<span class="lineno" id=line4></span>  <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"demux"</span>;
<span class="lineno" id=line5></span>  <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"faio"</span>;
<span class="lineno" id=line6></span>  <span class="comment">// contains windows overlapped/iocp io &amp; copipes. no stream wrapper yet.</span>
<span class="lineno" id=line7></span>  <span class="big_keyword" title="Open a module or class">open</span> <span class="hack">C_hack</span>;
<span class="lineno" id=line8></span>  <span class="big_keyword" title="Open a module or class">open</span> Faio;
<span class="lineno" id=line9></span>  <span class="big_keyword" title="Open a module or class">open</span> Demux;
<span class="lineno" id=line10></span>  
<span class="lineno" id=line11></span>  <span class="big_keyword" title="Specify C code to be inserted into header file">header</span> '<span class="embedded_c">#<span class="preproc">include</span> <span class="fstring">"faio_winio.hpp"</span></span>'; <span class="comment">// this has everything (includes asyncio.h)</span>
<span class="lineno" id=line12></span>  
<span class="lineno" id=line13></span>  <span class="comment">// ------------ core file and socket definitions ----------------</span>
<span class="lineno" id=line14></span>  <span class="comment">// I could just use HANDLEs everywhere, but I want to see how this goes</span>
<span class="lineno" id=line15></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> WFILE = <span class="fstring">'HANDLE'</span>;
<span class="lineno" id=line16></span>  <span class="big_keyword" title="Define an alias for a type expression">typedef</span> fd_t = WFILE;
<span class="lineno" id=line17></span>  
<span class="lineno" id=line18></span>  <span class="big_keyword" title="Bind a Felix symbol to a C expression">const</span> INVALID_HANDLE_VALUE: WFILE = <span class="fstring">'INVALID_HANDLE_VALUE'</span>;
<span class="lineno" id=line19></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> == : WFILE*WFILE -&gt; bool = <span class="fstring">'($1 == $2)'</span>;
<span class="lineno" id=line20></span>  
<span class="lineno" id=line21></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> SOCKET = <span class="fstring">"SOCKET"</span>;
<span class="lineno" id=line22></span>  <span class="big_keyword" title="Define an alias for a type expression">typedef</span> socket_t = SOCKET;
<span class="lineno" id=line23></span>  
<span class="lineno" id=line24></span>  <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> Str[socket_t] {
<span class="lineno" id=line25></span>     <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="Convert a value to a string">str</span>: socket_t -&gt; <span class="library" title="binding of C++ string type">string</span> = <span class="fstring">"::flx::rtl::strutil::str&lt;int&gt;($1)"</span> <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"flx_strutil"</span>;
<span class="lineno" id=line26></span>  }
<span class="lineno" id=line27></span>  
<span class="lineno" id=line28></span>  <span class="comment">// --------------------------------------------------------------</span>
<span class="lineno" id=line29></span>  
<span class="lineno" id=line30></span>  <span class="comment">// useful windows function</span>
<span class="lineno" id=line31></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> GetLastError: 1 -&gt; <span class="library" title="binding of C int type">int</span> = <span class="fstring">'GetLastError()'</span>;
<span class="lineno" id=line32></span>  
<span class="lineno" id=line33></span>  <span class="comment">// maybe don't use this - let the socket be passed in already associated</span>
<span class="lineno" id=line34></span>  <span class="comment">// with an IOCP. do I have to make this explicitly overlapped? If we</span>
<span class="lineno" id=line35></span>  <span class="comment">// want async io I think I'll need to associate this with the iocp.</span>
<span class="lineno" id=line36></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> cmk_socket : <span class="library" title="Type with one values (), the empty tuple">unit</span> -&gt; SOCKET = <span class="fstring">'::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)'</span>;
<span class="lineno" id=line37></span>  
<span class="lineno" id=line38></span>  <span class="comment">// well that didn't help.</span>
<span class="lineno" id=line39></span>  <span class="comment">//fun cmk_socket : unit -&gt; SOCKET = 'WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED)';</span>
<span class="lineno" id=line40></span>  <span class="comment">// must associate with iocp to do overlapped io with s (WSASend/Recv)</span>
<span class="lineno" id=line41></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> mk_socket(s: &amp;SOCKET)
<span class="lineno" id=line42></span>  {
<span class="lineno" id=line43></span>      s &lt;- cmk_socket();
<span class="lineno" id=line44></span>      associate_with_iocp(*s);                <span class="comment">// associate with iocp (errors?).</span>
<span class="lineno" id=line45></span>  }
<span class="lineno" id=line46></span>  
<span class="lineno" id=line47></span>  
<span class="lineno" id=line48></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> wasync_accept = <span class="fstring">"flx::faio::wasync_accept"</span>;
<span class="lineno" id=line49></span>  
<span class="lineno" id=line50></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> mk_accept: demuxer *  SOCKET*SOCKET -&gt; wasync_accept = <span class="fstring">'flx::faio::wasync_accept($a)'</span>;
<span class="lineno" id=line51></span>  <span class="comment">// make this a parameterised type</span>
<span class="lineno" id=line52></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> get_success[t]: t -&gt; bool = <span class="fstring">'$1.success'</span>;
<span class="lineno" id=line53></span>  
<span class="lineno" id=line54></span>  <span class="comment">// this feels silly</span>
<span class="lineno" id=line55></span>  <span class="big_keyword" title="Bind a Felix symbol to a C expression">const</span> INVALID_SOCKET: SOCKET = <span class="fstring">'INVALID_SOCKET'</span>;
<span class="lineno" id=line56></span>  <span class="comment">// oops, no good if we can't check against it</span>
<span class="lineno" id=line57></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> eq : SOCKET*SOCKET -&gt; bool = <span class="fstring">'($1 == $2)'</span>;
<span class="lineno" id=line58></span>  
<span class="lineno" id=line59></span>  <span class="comment">// windows style accept. accepted is an already created socket, unbound</span>
<span class="lineno" id=line60></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> Accept(success: &amp;bool, listener: SOCKET, accepted: SOCKET)
<span class="lineno" id=line61></span>  {
<span class="lineno" id=line62></span>      <span class="big_keyword" title="Define a mutable variable">var</span> acc = mk_accept(sys_demux,listener, accepted);
<span class="lineno" id=line63></span>      faio_req$ &amp;acc;    <span class="comment">// causes AcceptEx to be called</span>
<span class="lineno" id=line64></span>      success &lt;- get_success(acc);
<span class="lineno" id=line65></span>  }
<span class="lineno" id=line66></span>  
<span class="lineno" id=line67></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> connect_ex=<span class="fstring">"flx::faio::connect_ex"</span>;
<span class="lineno" id=line68></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> mk_connect_ex: demuxer * SOCKET*+<span class="library" title="binding of C char type">char</span>*<span class="library" title="binding of C int type">int</span> -&gt; connect_ex = <span class="fstring">'flx::faio::connect_ex($a)'</span>;
<span class="lineno" id=line69></span>  
<span class="lineno" id=line70></span>  <span class="comment">// for use on sockets you make yourself, who knows, maybe you want to</span>
<span class="lineno" id=line71></span>  <span class="comment">// reuse them</span>
<span class="lineno" id=line72></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> Connect(s: SOCKET, addr: +<span class="library" title="binding of C char type">char</span>, port: <span class="library" title="binding of C int type">int</span>, err: &amp;<span class="library" title="binding of C int type">int</span>)
<span class="lineno" id=line73></span>  {
<span class="lineno" id=line74></span>      <span class="big_keyword" title="Define a mutable variable">var</span> con = mk_connect_ex(sys_demux,s, addr, port);
<span class="lineno" id=line75></span>      faio_req$ &amp;con;    <span class="comment">// causes ConnectEx to be called</span>
<span class="lineno" id=line76></span>      <span class="big_keyword" title="Define a mutable variable">var</span> success = get_success(con);
<span class="lineno" id=line77></span>      err &lt;- <span class="small_keyword" title="conditional">if</span> success <span class="small_keyword" title="conditional">then</span> 0 <span class="small_keyword" title="conditional">else</span> -1 <span class="small_keyword" title="conditional">endif</span>;
<span class="lineno" id=line78></span>  }
<span class="lineno" id=line79></span>  
<span class="lineno" id=line80></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> Connect(s: &amp;SOCKET, addr: +<span class="library" title="binding of C char type">char</span>, port: <span class="library" title="binding of C int type">int</span>, err: &amp;<span class="library" title="binding of C int type">int</span>)
<span class="lineno" id=line81></span>  {
<span class="lineno" id=line82></span>      mk_socket s;            <span class="comment">// error handling?</span>
<span class="lineno" id=line83></span>      Connect(*s, addr, port, err);
<span class="lineno" id=line84></span>  }
<span class="lineno" id=line85></span>  
<span class="lineno" id=line86></span>  <span class="comment">// listens on all interfaces, I guess</span>
<span class="lineno" id=line87></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> cmk_listener: &amp;SOCKET*&amp;<span class="library" title="binding of C int type">int</span>*<span class="library" title="binding of C int type">int</span>
<span class="lineno" id=line88></span>      = <span class="fstring">'*$1 = flx::demux::create_listener_socket($2, $3);'</span>;
<span class="lineno" id=line89></span>  
<span class="lineno" id=line90></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> mk_listener(listener: &amp;SOCKET, port: &amp;<span class="library" title="binding of C int type">int</span>, backlog: <span class="library" title="binding of C int type">int</span>)
<span class="lineno" id=line91></span>  {
<span class="lineno" id=line92></span>      cmk_listener(listener,port, backlog);
<span class="lineno" id=line93></span>      associate_with_iocp(*listener);
<span class="lineno" id=line94></span>  }
<span class="lineno" id=line95></span>  
<span class="lineno" id=line96></span>  <span class="comment">// ignores return value</span>
<span class="lineno" id=line97></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> closesocket: SOCKET = <span class="fstring">'closesocket($1);'</span>;
<span class="lineno" id=line98></span>  
<span class="lineno" id=line99></span>  <span class="big_keyword" title="Bind a Felix symbol to a C expression">const</span> SD_RECEIVE:<span class="library" title="binding of C int type">int</span> = <span class="fstring">'SD_RECEIVE'</span>;
<span class="lineno" id=line100></span>  <span class="big_keyword" title="Bind a Felix symbol to a C expression">const</span> SD_SEND:<span class="library" title="binding of C int type">int</span> = <span class="fstring">'SD_SEND'</span>;
<span class="lineno" id=line101></span>  <span class="big_keyword" title="Bind a Felix symbol to a C expression">const</span> SD_BOTH:<span class="library" title="binding of C int type">int</span> = <span class="fstring">'SD_BOTH'</span>;
<span class="lineno" id=line102></span>  
<span class="lineno" id=line103></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> shutdown: SOCKET*<span class="library" title="binding of C int type">int</span> = <span class="fstring">'shutdown($1, $2);'</span>;
<span class="lineno" id=line104></span>  
<span class="lineno" id=line105></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> wasync_transmit_file = <span class="fstring">"flx::faio::wasync_transmit_file"</span>;
<span class="lineno" id=line106></span>  
<span class="lineno" id=line107></span>  <span class="comment">// hacked for ro atm. the 0 means exclusive (not good, but I haven't deciphered</span>
<span class="lineno" id=line108></span>  <span class="comment">// the flags yet. NULL for non inheritable security attributes.</span>
<span class="lineno" id=line109></span>  <span class="comment">// OPEN_EXISTING is to make sure it doesn't create the file</span>
<span class="lineno" id=line110></span>  <span class="comment">// Geez, FILE_ATTRIBUTE_NORMAL? not hidden, not temp, etc.</span>
<span class="lineno" id=line111></span>  <span class="comment">// final NULL is for template file. not sure what it does, but I don't want it.</span>
<span class="lineno" id=line112></span>  <span class="comment">// notice that it's opened for SHARED reading</span>
<span class="lineno" id=line113></span>  <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> OpenFile: <span class="library" title="binding of C++ string type">string</span> -&gt; WFILE =
<span class="lineno" id=line114></span>    <span class="fstring">'''CreateFile($1.c_str(), FILE_READ_DATA, FILE_SHARE_READ, NULL,
<span class="lineno" id=line115></span>      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL)'''</span>;
<span class="lineno" id=line116></span>  
<span class="lineno" id=line117></span>  <span class="comment">// basically for windows named pipes</span>
<span class="lineno" id=line118></span>  <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> OpenFileDuplex: <span class="library" title="binding of C++ string type">string</span> -&gt; WFILE =
<span class="lineno" id=line119></span>    <span class="fstring">'''CreateFile($1.c_str(), FILE_READ_DATA | FILE_WRITE_DATA,
<span class="lineno" id=line120></span>       FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
<span class="lineno" id=line121></span>       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL)'''</span>;
<span class="lineno" id=line122></span>  
<span class="lineno" id=line123></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> CloseFile: WFILE = <span class="fstring">'''if(!CloseHandle($1))
<span class="lineno" id=line124></span>    fprintf(stderr, "CloseHandle(WFILE) failed: %i\\n", GetLastError());'''</span>;
<span class="lineno" id=line125></span>  
<span class="lineno" id=line126></span>  <span class="comment">// error handling?</span>
<span class="lineno" id=line127></span>  <span class="comment">// proc CloseFile: WFILE = 'CloseHandle($1);';</span>
<span class="lineno" id=line128></span>  
<span class="lineno" id=line129></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> mk_transmit_file : demuxer * SOCKET*WFILE -&gt; wasync_transmit_file
<span class="lineno" id=line130></span>      = <span class="fstring">'flx::faio::wasync_transmit_file($a)'</span>;
<span class="lineno" id=line131></span>  
<span class="lineno" id=line132></span>  <span class="comment">// toylike interface for now, but still fun</span>
<span class="lineno" id=line133></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> TransmitFile(s: SOCKET, f: WFILE)
<span class="lineno" id=line134></span>  {
<span class="lineno" id=line135></span>      <span class="big_keyword" title="Define a mutable variable">var</span> tf = mk_transmit_file(sys_demux,s, f);
<span class="lineno" id=line136></span>      faio_req$ &amp;tf;
<span class="lineno" id=line137></span>  }
<span class="lineno" id=line138></span>  
<span class="lineno" id=line139></span>  <span class="comment">// by passing special flags to TransmitFile we can transform a connected</span>
<span class="lineno" id=line140></span>  <span class="comment">// socket into a socket ready for use with AcceptEx. DisconnectEx explicitly</span>
<span class="lineno" id=line141></span>  <span class="comment">// does this and without the warning that accept-style &amp; connect-style sockets</span>
<span class="lineno" id=line142></span>  <span class="comment">// cannot be reused as the other type (which isn't a problem for my use)</span>
<span class="lineno" id=line143></span>  <span class="comment">// however I already have TransmitFile code in place.</span>
<span class="lineno" id=line144></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> mk_reuse_socket : demuxer * SOCKET -&gt; wasync_transmit_file
<span class="lineno" id=line145></span>      = <span class="fstring">'flx::faio::wasync_transmit_file($a)'</span>;
<span class="lineno" id=line146></span>  
<span class="lineno" id=line147></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> ReuseSocket(s: SOCKET)
<span class="lineno" id=line148></span>  {
<span class="lineno" id=line149></span>      <span class="big_keyword" title="Define a mutable variable">var</span> tf = mk_reuse_socket(sys_demux,s);
<span class="lineno" id=line150></span>      faio_req$ &amp;tf;
<span class="lineno" id=line151></span>  }
<span class="lineno" id=line152></span>  
<span class="lineno" id=line153></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> wsa_socketio = <span class="fstring">"flx::faio::wsa_socketio"</span>;
<span class="lineno" id=line154></span>  <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> mk_wsa_socketio: demuxer * SOCKET* &amp;sel_param*bool-&gt;wsa_socketio = <span class="fstring">'flx::faio::wsa_socketio($a)'</span>;
<span class="lineno" id=line155></span>  
<span class="lineno" id=line156></span>  <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> to_ptr : sel_param -&gt; &amp;sel_param = <span class="fstring">'&amp;$1'</span>;
<span class="lineno" id=line157></span>  
<span class="lineno" id=line158></span>  
<span class="lineno" id=line159></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> WSARecv(s: SOCKET, <span class="library" title="number of elements in data structure">len</span>: &amp;<span class="library" title="binding of C int type">int</span>, buf: <span class="library" title="special binding of C void* type">address</span>, eof: &amp;bool)
<span class="lineno" id=line160></span>  {
<span class="lineno" id=line161></span>      <span class="big_keyword" title="Define a mutable variable">var</span> pb: sel_param;
<span class="lineno" id=line162></span>      init_pb(&amp;pb, buf, *<span class="library" title="number of elements in data structure">len</span>);
<span class="lineno" id=line163></span>      <span class="big_keyword" title="Define a mutable variable">var</span> ppb: &amp;sel_param = &amp;pb;
<span class="lineno" id=line164></span>  
<span class="lineno" id=line165></span>      <span class="big_keyword" title="Define a mutable variable">var</span> <span class="library" title="return data structure with elements reversed">rev</span> = mk_wsa_socketio(sys_demux,s, ppb, <span class="library" title="truth value">true</span>);  <span class="comment">// reading</span>
<span class="lineno" id=line166></span>      faio_req$ &amp;<span class="library" title="return data structure with elements reversed">rev</span>;
<span class="lineno" id=line167></span>  <span class="comment">// we do have a success flag</span>
<span class="lineno" id=line168></span>      calc_eof(ppb, <span class="library" title="number of elements in data structure">len</span>, eof);
<span class="lineno" id=line169></span>  }
<span class="lineno" id=line170></span>  
<span class="lineno" id=line171></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> WSASend(s: SOCKET, <span class="library" title="number of elements in data structure">len</span>: &amp;<span class="library" title="binding of C int type">int</span>, buf: <span class="library" title="special binding of C void* type">address</span>, eof: &amp;bool)
<span class="lineno" id=line172></span>  {
<span class="lineno" id=line173></span>      <span class="big_keyword" title="Define a mutable variable">var</span> pb: sel_param;
<span class="lineno" id=line174></span>      init_pb(&amp;pb, buf, *<span class="library" title="number of elements in data structure">len</span>);
<span class="lineno" id=line175></span>      <span class="big_keyword" title="Define a mutable variable">var</span> ppb: &amp;sel_param = &amp;pb;
<span class="lineno" id=line176></span>  
<span class="lineno" id=line177></span>      <span class="big_keyword" title="Define a mutable variable">var</span> <span class="library" title="return data structure with elements reversed">rev</span> = mk_wsa_socketio(sys_demux,s, ppb, <span class="library" title="false value">false</span>); <span class="comment">// writing</span>
<span class="lineno" id=line178></span>      faio_req$ &amp;<span class="library" title="return data structure with elements reversed">rev</span>;
<span class="lineno" id=line179></span>      calc_eof(ppb, <span class="library" title="number of elements in data structure">len</span>, eof);
<span class="lineno" id=line180></span>  }
<span class="lineno" id=line181></span>  
<span class="lineno" id=line182></span>  
<span class="lineno" id=line183></span>  <span class="comment">// general request for addition of socket to iocp. might be better to</span>
<span class="lineno" id=line184></span>  <span class="comment">// just create them that way.</span>
<span class="lineno" id=line185></span>  <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> iocp_associator = <span class="fstring">"flx::faio::iocp_associator"</span>;
<span class="lineno" id=line186></span>  <span class="big_keyword" title="Define a function with no side-effects">fun</span> mk_iocp_associator: demuxer * SOCKET -&gt; iocp_associator = <span class="fstring">'flx::faio::iocp_associator($a)'</span>;
<span class="lineno" id=line187></span>  
<span class="lineno" id=line188></span>  <span class="comment">// this ends up just casting to a handle, so I should be able to use</span>
<span class="lineno" id=line189></span>  <span class="comment">// this for other HANDLEs. Note that the user cookie is not settable</span>
<span class="lineno" id=line190></span>  <span class="comment">// via this interface.</span>
<span class="lineno" id=line191></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> associate_with_iocp(s: SOCKET)
<span class="lineno" id=line192></span>  {
<span class="lineno" id=line193></span>      <span class="comment">// results? err code?</span>
<span class="lineno" id=line194></span>      <span class="big_keyword" title="Define a mutable variable">var</span> req = mk_iocp_associator(sys_demux, s);
<span class="lineno" id=line195></span>      faio_req$ &amp;req;
<span class="lineno" id=line196></span>  }
<span class="lineno" id=line197></span>  
<span class="lineno" id=line198></span>  } <span class="comment">// module win32_faio</span>
<span class="lineno" id=line199></span>  
<span class="lineno" id=line200></span>  
</pre></p></div><!--Main Content Body End-->

          </div> <!-- rightpanel contents end -->
          <hr>
        </span> <!-- rightpanel end -->

        <span id="panemover" style="cursor:col-resize;"
         onmousedown="dragStart(event, 'left', 'right'); return false;"
         onmousemove="drag(event, 'left', 'right');"
         onmouseout="dragRelease();"
         onmouseup="dragRelease();"
        >
        </span> <!-- panemover end -->
      </div> <!-- bottom panel end -->
    </div> <!-- container end -->
</body></html>


