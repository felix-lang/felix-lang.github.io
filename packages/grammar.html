<html><head>
<style type="text/css">
body {margin:3%; }
h1 {color:gray; font-size:120%;}
h2 {color:gray; font-size:105%;}
h3 {font-size:100%;}
h4 {font-size:95%;}
h5 {font-size:95%;}
span.fstring {color:darkblue; font-style:italic; }
span.comment {font-family:arial; color:blue; font-style:italic; }
span.doccomment {font-family:arial; color:green; font-style:italic; }
span.big_keyword {color:#FF1010; }
span.small_keyword {color:#802040; }
span.qualifier {color:#A02020; }
span.library {color:#A02000; }
span.ctor {color:#406020; }
span.hack {color:#66DD00; }
span.preproc {color:#005500; }
span.embedded_c{background-color:#DDDDDD; }
span.fpc_fieldname {color:#DD0000; }
span.lineno {color:#101010; background-color:#E0E0E0; font-size:80%; font-family:"courier",monospace; font-style:normal; }
pre.flxbg {background-color:#A0FFA0; color:black; padding:2px; box-shadow:5px 5px 2px #807080; }
pre.uncheckedflxbg {background-color:#D0D0D0; color:black; padding:2px; box-shadow:5px 5px 2px #807080; }
pre.cppbg {background-color:#80FF80; color:black; }
pre.prefmtbg {background-color:#D0D0D0; color:black; }
pre.expected {background-color:#E0FF80; color:black; }
pre.input {background-color:#E08080; color:black; }
pre.inclusion {background-color:#D070D0; color:black; }
code.inclusion {background-color:#D070D0; color:black; }
.obsolete { background-color:#FFEFEF; font-size: small; color:black; }
.future { background-color:#FF8080; font-size: small; color:black; }
.implementation_detail { background-color:#E0E0E0; font-size: small; color:black;  }
.bug { background-color:#FFE0E0; font-size: small; color:black; }
.fixed{ background-color:#FFE0E0; font-size: small; color:black; }
.done { background-color:#FFE0E0; font-size: small; color:black; }
.caveat { background-color:#FF8080; color:black; }
</style>
<title>Base Grammar</title></head><body>
<style>
body {margin:3%; font-family: sans-serif; }
h1 {color:black; font-size:120%; border-bottom: 2px solid #ddd; padding: 0 0 3px 0;}
h2 {color:#202020; font-size:105%;}
h3 {font-size:100%;}
h4 {font-size:95%;}
h5 {font-size:95%;}
span.fstring {color:darkblue; font-style:italic; }
span.comment {font-family:arial; color:blue; font-style:italic; }
span.doccomment {font-family:arial; color:green; font-style:italic; }
span.big_keyword {color:#FF1010; }
span.small_keyword {color:#802040; }
span.qualifier {color:#A02020; }
span.library {color:#A02000; }
span.ctor {color:#406020; }
span.hack {color:#66DD00; }
span.preproc {color:#005500; }
span.embedded_c{background-color:#DDDDDD; }
span.fpc_fieldname {color:#DD0000; }
span.lineno {color:#101010; background-color:#E0E0E0; font-size:80%; font-family:"courier",monospace; font-style:normal; }
pre { border: 1px solid #ccc; color: black; box-shadow:3px 3px 2px rgba(0,0,0,0.1); padding:2px; }
pre.flxbg {background-color:#C2FDC2; box-shadow:3px 3px 2px rgba(0,0,0,0.1) }
pre.uncheckedflxbg {background-color:#eee; box-shadow:3px 3px 2px rgba(0,0,0,0.1); }
pre.cppbg {background-color:#C2FDC2; }
pre.prefmtbg {background-color:#F1F1F1; }
pre.expected {background-color:hsla(74,94%,88%,1); }
pre.input {background-color:hsla(20,94%,88%,1); }
pre.inclusion {
    font-family: Arial;
    font-weight: normal;
    font-size: 0.9em;
    color: #555;
    border: none;
    box-shadow: none;
    text-align: right;
    margin: -7px 11px -12px 0;
    padding: 0;
    background-color:#fafafa;
}
code.inclusion {background-color:#D070D0; color:black; }
.obsolete { background-color:#FFEFEF; font-size: small; color:black; }
.future { background-color:#FF8080; font-size: small; color:black; }
.implementation_detail { background-color:#E0E0E0; font-size: small; color:black;  }
.bug { background-color:#FFE0E0; font-size: small; color:black; }
.fixed{ background-color:#FFE0E0; font-size: small; color:black; }
.done { background-color:#FFE0E0; font-size: small; color:black; }
.caveat { background-color:hsla(0,100%,91%,1); color:black; padding: 0.6em; }
.container {
  position: fixed;
  top:0px;
  left:0px;
  height : 100%;
  width: 100%;
  background-color: grey;
  margin: 0px;
  padding: 0px;
  border-width: 0px;
  color: #404040;
}
.maincontent {
  padding:4px;
  padding-left:8px;
  line-height:1.3em;
  color:#404040; background-color:#fafafa;
}
.maincontent h1 { margin-left:-8px; position: relative; font-family: georgia, serif; font-size: 1.8em; font-weight: normal; }
.maincontent h2 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent h3 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent h4 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent code { color:#902030; }
.toppanel {
  position:absolute; left:0px; top:0px; height:20px; right:0px;
  background-color: #e0e0e0;
}
.bottompanel {
  position:absolute; left:0px; top:22px; bottom:0px; right:0px;
  background-color: #fafafa;
  font-size:14px;
}
.leftpanel {
  position:absolute; left:0px; top:0px; bottom:0px; width: 150px;
  background-color: #eaeaea; overflow: auto;
}
.rightpanel {
  position:absolute; right: 0px; left:160px; top:0px; bottom: 0px;
  background-color: #fafafa; overflow: auto;
}
.divider {
  position:absolute; left: 150px; top:0px; bottom:0px;
  background-color: black; width:2px;
  box-shadow: 0 0 8px #000;
}

#panemover {
    position:absolute;
    left: 150px;
    width : 10px;
    top: 0px;
    bottom: 0px;
    opacity: 0.3;
    cursor:col-resize;
}

div.m {
    margin: 0px;
    padding:0px;
    border-width:2px;
    border-color: green;
}

div.m1 {
    background-color: #86E870;
    border-style:outset;
    border-color:#ccc;
    border-width:2px 0;
    font-size:90%;
    padding: 1px 0 2px 10px;
}

div.m2 {
    background-color: #70C070;
    padding-left:15px;
    padding-top:2px;
    border-style:outset;
    border-color:green;
    border-width:0 0 1px 0;
    font-size:80%;
}

div.m1:hover, div.m2:hover {
    background-color: white;
}

#leftmargintoc a {
    text-decoration: none;
    color: #404040;
}
</style>

<style>
div.m {
    margin: 0px;
    padding:0px;
    border-width:2px;
    border-color: green;
}

div.m1 {
    background-color: #86E870;
    border-style:outset;
    border-color:#ccc;
    border-width:2px 0;
    font-size:90%;
    padding: 1px 0 2px 10px;
}

div.m2 {
    background-color: #70C070;
    padding-left:15px;
    padding-top:2px;
    border-style:outset;
    border-color:green;
    border-width:0 0 1px 0;
    font-size:80%;
}

div.m1:hover, div.m2:hover {
    background-color: white;
}

#leftmargintoc a {
    text-decoration: none;
    color: #404040;
}


</style>

    <script async="true">
      function dragStart(e, left, right){
        document.getElementById("panemover").style.width="70%";
        document.getElementById("panemover").style.left="50px";
        mousedown = true;
        x = e.clientX
        dragOffsetLeft =
          document.getElementById(left).getBoundingClientRect().right -
          document.getElementById(left).getBoundingClientRect().left -
          x
        ;
        dragOffsetDivider= document.getElementById("divider").getBoundingClientRect().left - x;
        dragOffsetRight = document.getElementById(right).getBoundingClientRect().left - x;
      }
      function dragRelease(){
        document.getElementById('panemover').style.width = '10px';
        document.getElementById('panemover').style.left = document.getElementById('divider').offsetLeft + 'px';
        mousedown = false;
      }
      function drag(e, left, right){
        if(!mousedown){return}
        x = e.clientX
        tmpLeft = dragOffsetLeft + x
        tmpDivider= dragOffsetDivider + x
        tmpRight = dragOffsetRight + x
        document.getElementById(left).style.width= tmpLeft + 'px';
        document.getElementById("divider").style.left= tmpDivider + 'px';
        document.getElementById(right).style.left = tmpRight + 'px';
      };
    </script>

<script type="text/javascript">

  function mexpand(id)
  {
    var n = document.getElementById(id).style;
    n.display = "block";
  }

  function mcollapse(id)
  {
    var n = document.getElementById(id).style;
    n.display = "none";
  }

  var counter_max = 0;
  function mshow(id,loc)
  {
    var i;
    for(i=1; i<=counter_max; ++i)
      mcollapse("menu"+String(i));
    mexpand(id);
    window.location.replace(loc);
  }
</script>

<script type="text/javascript">

function expand(but,id)
{
  var n = document.getElementById(id).style;
  var button = document.getElementById(but);
  button.src = "/share/src/web/images/minus.gif";
  button.alt = "-";
  n.display = "block";
}
function collapse(but,id)
{
  var n = document.getElementById(id).style;
  var button = document.getElementById(but);
  button.src = "/share/src/web/images/plus.gif";
  button.alt = "+";
  n.display = "none";
}
function toggle(button,id)
{
  var n = document.getElementById(id).style;
  if (n.display == "none")
  {
    button.src = "/share/src/web/images/minus.gif";
    button.alt = "-";
    n.display = "block";
  }
  else
  {
    button.src = "/share/src/web/images/plus.gif";
    button.alt = "+";
    n.display = "none";
  }
}
var allbuttons = [
"Type Grammar",
"Expressions.",
"Grammar Base",
"Assertions",
"Assignments",
"Block forms",
"Bracket Forms",
"C binding technology",
"Simple C grammar",
"Conditional forms",
"Executable support",
"Master DSSL dependency list.",
"Function forms",
"Standard include file list",
"Identifier Lexer",
"Regular Definitions DSSL",
"Utility Scheme definitions.",
"String like literals.",
"Loops",
"Macros",
"Namespaces",
"Patterns",
"Plugin Support DSSL",
"Requirements",
"Save Thunk.",
"Statements",
"TeX Symbols",
"Type definitions",
"Utility nonterminals.",
"Variable definitions.",
"Chips",
"Syntax",
"Syntax",
"Syntax",
"Syntax",
"Syntax",
"Notation",
"Syntax",
"Syntax",
"Float literal constructors",
"Tuple Constructor Syntax",
"Exception Grammar",
"List syntax",
"Syntax",
"Parallel loop grammar",
"Syntax",
"String syntax",
"ObjC Syntax"
];
function expand_all(dummy)
{
  for (i in allbuttons)
  {
    expand(allbuttons[i], allbuttons[i]+"_d");
  }
}
function collapse_all(dummy)
{
  for (i in allbuttons)
  {
    collapse(allbuttons[i], allbuttons[i]+"_d");
  }
}
</script>

<script>
function mouseover(id)
{
  var elt = document.getElementById(id);
  elt.style.display="none";
  var elt2 = document.getElementById(id+"_mo");
  elt2.style.display="inline";
}

function mouseout(id)
{
  var elt = document.getElementById(id+"_mo");
  elt.style.display="none";
  var elt2 = document.getElementById(id);
  elt2.style.display="inline";
}

</script>
<script> function nop(dummy) {} </script>
    <div class="container">
      <div class="toppanel">
    <!--Main Content top navbar-->
<span style="position:relative; bottom:6px"
  onmouseover="mouseover('expand')"
  onmouseout="mouseout('expand')"
  onclick="expand_all('expand')"
  ><span id="expand"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:blue;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Expand</text></svg></span><span id="expand_mo" style="display:none"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:red;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Expand</text></svg></span></span><span style="position:relative; bottom:6px"
  onmouseover="mouseover('collapse')"
  onmouseout="mouseout('collapse')"
  onclick="collapse_all('collapse')"
  ><span id="collapse"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:blue;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Collapse</text></svg></span><span id="collapse_mo" style="display:none"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:red;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Collapse</text></svg></span></span>    <!--Main Content top navbar End-->

      </div> <!-- toppanel end -->
      <div class="bottompanel">
        <span id="divider" class="divider"></span>

        <span id="left" class="leftpanel" >
          <div class="menucontent">
  <!--Left Margin Toc-->
  <div id="leftmargintoc">
    <!--Left Margin Toc Main Contents-->
      <div class=m1 onclick="mshow('menu1','#Type Grammar_h')"> <a href="#Type_Grammar_h">Type Grammar</a></div>
      <div class=sm id=menu1>
      <div class=m2><a href="#Expressions._h">Expressions.</a></div>
      </div>
      <div class=m1 onclick="mshow('menu2','#Grammar Base_h')"> <a href="#Grammar_Base_h">Grammar Base</a></div>
      <div class=sm id=menu2>
      <div class=m2><a href="#Assertions_h">Assertions</a></div>
      <div class=m2><a href="#Assignments_h">Assignments</a></div>
      <div class=m2><a href="#Block_forms_h">Block forms</a></div>
      <div class=m2><a href="#Bracket_Forms_h">Bracket Forms</a></div>
      <div class=m2><a href="#C_binding_technology_h">C binding technology</a></div>
      <div class=m2><a href="#Simple_C_grammar_h">Simple C grammar</a></div>
      <div class=m2><a href="#Conditional_forms_h">Conditional forms</a></div>
      <div class=m2><a href="#Executable_support_h">Executable support</a></div>
      <div class=m2><a href="#Master_DSSL_dependency_list._h">Master DSSL dependency list.</a></div>
      <div class=m2><a href="#Function_forms_h">Function forms</a></div>
      <div class=m2><a href="#Standard_include_file_list_h">Standard include file list</a></div>
      <div class=m2><a href="#Identifier_Lexer_h">Identifier Lexer</a></div>
      <div class=m2><a href="#Regular_Definitions_DSSL_h">Regular Definitions DSSL</a></div>
      <div class=m2><a href="#Utility_Scheme_definitions._h">Utility Scheme definitions.</a></div>
      <div class=m2><a href="#String_like_literals._h">String like literals.</a></div>
      <div class=m2><a href="#Loops_h">Loops</a></div>
      <div class=m2><a href="#Macros_h">Macros</a></div>
      <div class=m2><a href="#Namespaces_h">Namespaces</a></div>
      <div class=m2><a href="#Patterns_h">Patterns</a></div>
      <div class=m2><a href="#Plugin_Support_DSSL_h">Plugin Support DSSL</a></div>
      <div class=m2><a href="#Requirements_h">Requirements</a></div>
      <div class=m2><a href="#Save_Thunk._h">Save Thunk.</a></div>
      <div class=m2><a href="#Statements_h">Statements</a></div>
      <div class=m2><a href="#TeX_Symbols_h">TeX Symbols</a></div>
      <div class=m2><a href="#Type_definitions_h">Type definitions</a></div>
      <div class=m2><a href="#Utility_nonterminals._h">Utility nonterminals.</a></div>
      <div class=m2><a href="#Variable_definitions._h">Variable definitions.</a></div>
      <div class=m2><a href="#Chips_h">Chips</a></div>
      <div class=m2><a href="#Syntax_h">Syntax</a></div>
      </div>
      <div class=m1 onclick="mshow('menu3','#Syntax_h')"> <a href="#Syntax_h">Syntax</a></div>
      <div class=sm id=menu3>
      <div class=m2><a href="#Syntax_h">Syntax</a></div>
      <div class=m2><a href="#Syntax_h">Syntax</a></div>
      <div class=m2><a href="#Syntax_h">Syntax</a></div>
      <div class=m2><a href="#Notation_h">Notation</a></div>
      <div class=m2><a href="#Syntax_h">Syntax</a></div>
      <div class=m2><a href="#Syntax_h">Syntax</a></div>
      </div>
      <div class=m1 onclick="mshow('menu4','#Float literal constructors_h')"> <a href="#Float_literal_constructors_h">Float literal constructors</a></div>
      <div class=sm id=menu4>
      </div>
      <div class=m1 onclick="mshow('menu5','#Tuple Constructor Syntax_h')"> <a href="#Tuple_Constructor_Syntax_h">Tuple Constructor Syntax</a></div>
      <div class=sm id=menu5>
      </div>
      <div class=m1 onclick="mshow('menu6','#Exception Grammar_h')"> <a href="#Exception_Grammar_h">Exception Grammar</a></div>
      <div class=sm id=menu6>
      </div>
      <div class=m1 onclick="mshow('menu7','#List syntax_h')"> <a href="#List_syntax_h">List syntax</a></div>
      <div class=sm id=menu7>
      </div>
      <div class=m1 onclick="mshow('menu8','#Syntax_h')"> <a href="#Syntax_h">Syntax</a></div>
      <div class=sm id=menu8>
      <div class=m2><a href="#Parallel_loop_grammar_h">Parallel loop grammar</a></div>
      </div>
      <div class=m1 onclick="mshow('menu9','#Syntax_h')"> <a href="#Syntax_h">Syntax</a></div>
      <div class=sm id=menu9>
      </div>
      <div class=m1 onclick="mshow('menu10','#String syntax_h')"> <a href="#String_syntax_h">String syntax</a></div>
      <div class=sm id=menu10>
      </div>
      <div class=m1 onclick="mshow('menu11','#ObjC Syntax_h')"> <a href="#ObjC_Syntax_h">ObjC Syntax</a></div>
      <div class=sm id=menu11>
      </div>
    <script>counter_max=11;</script>
  </div>
  <!--End Left Margin Toc-->

          </div> <!-- leftpanel contents end -->
        </span> <!-- leftpanel end -->

        <span id="right" class="rightpanel">
          <div class="maincontent">
<!--Main Content Body-->
<h1 id='Type_Grammar_h'><img src='/share/src/web/images/minus.gif' id='Type Grammar' onclick='toggle(this,"Type_Grammar_d")' alt='+'/> 1 Type Grammar</h1><div id='Type_Grammar_d' style='display:block'>
<pre class='inclusion'>
share/lib/grammar/types.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> types {
<span class="lineno" id=line3></span>    <span class="big_keyword" title="specify requirements">requires</span> expressions;
<span class="lineno" id=line4></span>  
<span class="lineno" id=line5></span>    <span class="comment">// kind language: products and arrows and simple names only</span>
<span class="lineno" id=line6></span>    skindexpr := k[sarrow_pri] =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line7></span>    k[sarrow_pri] := k[&gt;sarrow_pri] <span class="fstring">"-&gt;"</span> k[sarrow_pri] =&gt;# <span class="fstring">"`(knd_arrow (,_1 ,_3))"</span>;
<span class="lineno" id=line8></span>    k[sproduct_pri] := k[&gt;sproduct_pri] (<span class="fstring">"*"</span> k[&gt;sproduct_pri])+ =&gt;# <span class="fstring">"(chain 'knd_tuple _1 _2)"</span> note <span class="fstring">"mul"</span>;
<span class="lineno" id=line9></span>    k[satomic_pri] := katom =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line10></span>    k[satomic_pri] := <span class="fstring">"("</span> skindexpr <span class="fstring">")"</span>  =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line11></span>    katom := sname =&gt;# <span class="fstring">"`(knd_name ,_1)"</span>;
<span class="lineno" id=line12></span>    skindexpr_comma_list = <span class="library" title="functional, singly linked list">list</span>::commalist1&lt;skindexpr&gt;;
<span class="lineno" id=line13></span>   
<span class="lineno" id=line14></span>  
<span class="lineno" id=line15></span>    stype := t[slambda_pri] =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line16></span>    stypeexpr := t[&gt;sor_condition_pri] =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line17></span>    stypeexpr_comma_list = <span class="library" title="functional, singly linked list">list</span>::commalist1&lt;stypeexpr&gt;;
<span class="lineno" id=line18></span>  
<span class="lineno" id=line19></span>    <span class="doccomment">Anonymous type function (lamda).</span>
<span class="lineno" id=line20></span>    t[slambda_pri] := <span class="fstring">"fun"</span> stypefun_args <span class="fstring">":"</span> skindexpr <span class="fstring">"=&gt;"</span> stype =&gt;#
<span class="lineno" id=line21></span>      <span class="fstring">"""
<span class="lineno" id=line22></span>      `(typ_typefun ,_sr ,_2 ,_4 ,_6)
<span class="lineno" id=line23></span>      """</span>;
<span class="lineno" id=line24></span>  
<span class="lineno" id=line25></span>    t[sas_expr_pri] := t[sas_expr_pri] <span class="fstring">"as"</span> sname =&gt;# <span class="fstring">'`(typ_as ,_sr (,_1 ,_3 (knd_name "TYPE")))'</span>;
<span class="lineno" id=line26></span>    t[sas_expr_pri] := t[sas_expr_pri] <span class="fstring">"as"</span> sname <span class="fstring">":"</span> skindexpr =&gt;# <span class="fstring">"`(typ_as ,_sr (,_1 ,_3 ,_5))"</span>;
<span class="lineno" id=line27></span>  
<span class="lineno" id=line28></span>    t[stuple_pri] := stypeexpr (<span class="fstring">","</span> stypeexpr )+ =&gt;# <span class="fstring">"(chain 'typ_type_tuple _1 _2)"</span>;
<span class="lineno" id=line29></span>  
<span class="lineno" id=line30></span>    <span class="comment">// these for type operations on static_bool, they're NOT type combinators</span>
<span class="lineno" id=line31></span>    t[simplies_condition_pri] := t[simplies_condition_pri] <span class="fstring">"implies"</span> t[&gt;simplies_condition_pri] =&gt;# <span class="fstring">"`(typ_implies ,_sr ,_1 ,_3)"</span>;
<span class="lineno" id=line32></span>    t[sor_condition_pri] := t[sor_condition_pri] <span class="fstring">"or"</span> t[&gt;sor_condition_pri] =&gt;# <span class="fstring">"`(typ_or ,_sr ,_1 ,_3)"</span>;
<span class="lineno" id=line33></span>    t[sand_condition_pri] := t[sand_condition_pri]  <span class="fstring">"and"</span> t[&gt;sand_condition_pri] =&gt;# <span class="fstring">"`(typ_and ,_sr ,_1 ,_3)"</span>;
<span class="lineno" id=line34></span>    t[snot_condition_pri] := <span class="fstring">"not"</span> t[snot_condition_pri]  =&gt;# <span class="fstring">"`(typ_not ,_sr ,_2)"</span>;
<span class="lineno" id=line35></span>    t[satomic_pri] := <span class="fstring">"true"</span>  =&gt;# <span class="fstring">"`(typ_true,_sr)"</span>;
<span class="lineno" id=line36></span>    t[satomic_pri] := <span class="fstring">"false"</span>  =&gt;# <span class="fstring">"`(typ_false ,_sr)"</span>;
<span class="lineno" id=line37></span>  
<span class="lineno" id=line38></span>    <span class="comment">// this is the type intersection combinator</span>
<span class="lineno" id=line39></span>    t[sproduct_pri] := t[sproduct_pri]  <span class="fstring">"/\"</span> t[&gt;sproduct_pri] =&gt;# <span class="fstring">'`(typ_intersect ,_sr ,_1 ,_3)'</span>;
<span class="lineno" id=line40></span>    t[ssum_pri] := t[ssum_pri]  <span class="fstring">"\/"</span> t[&gt;ssum_pri] =&gt;# <span class="fstring">'`(typ_union ,_sr ,_1 ,_3)'</span>;
<span class="lineno" id=line41></span>  
<span class="lineno" id=line42></span>    <span class="doccomment">Ellipsis (for binding C varags functions).</span>
<span class="lineno" id=line43></span>    t[satomic_pri] := <span class="fstring">"..."</span> =&gt;# <span class="fstring">"`(typ_ellipsis ,_sr)"</span>;
<span class="lineno" id=line44></span>  
<span class="lineno" id=line45></span>  
<span class="lineno" id=line46></span>    t[ssum_pri] := t[ssum_pri] <span class="fstring">"`+"</span> t[&gt;ssum_pri] =&gt;# <span class="fstring">"(tInfix)"</span>;
<span class="lineno" id=line47></span>    t[ssum_pri] := t[ssum_pri] <span class="fstring">"`-"</span> t[&gt;ssum_pri] =&gt;# <span class="fstring">"(tInfix)"</span>;
<span class="lineno" id=line48></span>    t[ssum_pri] := t[ssum_pri] <span class="fstring">"`*"</span> t[&gt;ssum_pri] =&gt;# <span class="fstring">"(tInfix)"</span>;
<span class="lineno" id=line49></span>    t[ssum_pri] := t[ssum_pri] <span class="fstring">"`/"</span> t[&gt;ssum_pri] =&gt;# <span class="fstring">"(tInfix)"</span>;
<span class="lineno" id=line50></span>    t[ssum_pri] := t[ssum_pri] <span class="fstring">"`%"</span> t[&gt;ssum_pri] =&gt;# <span class="fstring">"(tInfix)"</span>;
<span class="lineno" id=line51></span>    t[ssum_pri] := t[&gt;scomparison_pri] <span class="fstring">"`=="</span> t[&gt;scomparison_pri] =&gt;# <span class="fstring">"(tInfix)"</span>;
<span class="lineno" id=line52></span>    t[ssum_pri] := t[&gt;scomparison_pri] <span class="fstring">"`&lt;"</span> t[&gt;scomparison_pri] =&gt;# <span class="fstring">"(tInfix)"</span>;
<span class="lineno" id=line53></span>    t[ssum_pri] := t[&gt;scomparison_pri] <span class="fstring">"`&gt;"</span> t[&gt;scomparison_pri] =&gt;# <span class="fstring">"(tInfix)"</span>;
<span class="lineno" id=line54></span>  
<span class="lineno" id=line55></span>    t[scomparison_pri]:= t[&gt;scomparison_pri] cmp t[&gt;scomparison_pri] =&gt;# 
<span class="lineno" id=line56></span>     <span class="fstring">"(tbinop _2 _1 _3))"</span>;
<span class="lineno" id=line57></span>  
<span class="lineno" id=line58></span>    <span class="comment">// right arrows: RIGHT ASSOCIATIVE!</span>
<span class="lineno" id=line59></span>    <span class="doccomment">Function type, right associative.</span>
<span class="lineno" id=line60></span>    t[sarrow_pri] := t[&gt;sarrow_pri] <span class="fstring">"-&gt;"</span> t[sarrow_pri] =&gt;# <span class="fstring">"`(typ_arrow (,_1 ,_3))"</span>;
<span class="lineno" id=line61></span>    t[sarrow_pri] := t[&gt;sarrow_pri] <span class="fstring">"-&gt;"</span> <span class="fstring">"["</span> stype <span class="fstring">"]"</span> t[sarrow_pri] =&gt;# <span class="fstring">"`(typ_effector (,_1 ,_4 ,_6))"</span>;
<span class="lineno" id=line62></span>  
<span class="lineno" id=line63></span>    t[sarrow_pri] := t[&gt;sarrow_pri] <span class="fstring">"-&gt;."</span> t[sarrow_pri] =&gt;# <span class="fstring">"`(typ_lineararrow (,_1 ,_3))"</span>;
<span class="lineno" id=line64></span>    t[sarrow_pri] := t[&gt;sarrow_pri] <span class="fstring">"-&gt;."</span> <span class="fstring">"["</span> stype <span class="fstring">"]"</span> t[sarrow_pri] =&gt;# <span class="fstring">"`(typ_lineareffector (,_1 ,_4 ,_6))"</span>;
<span class="lineno" id=line65></span>  
<span class="lineno" id=line66></span>  
<span class="lineno" id=line67></span>    <span class="doccomment">C function type, right associative.</span>
<span class="lineno" id=line68></span>    t[sarrow_pri] := t[&gt;sarrow_pri] <span class="fstring">"--&gt;"</span> t[sarrow_pri] =&gt;# <span class="fstring">"`(typ_longarrow (,_1 ,_3))"</span>;
<span class="lineno" id=line69></span>  
<span class="lineno" id=line70></span>    <span class="doccomment">Addition: left non-associative.</span>
<span class="lineno" id=line71></span>    t[ssum_pri] := t[&gt;ssum_pri] (<span class="fstring">"+"</span> t[&gt;ssum_pri])+ =&gt;# <span class="fstring">"(chain 'typ_sum _1 _2)"</span> note <span class="fstring">"add"</span>;
<span class="lineno" id=line72></span>    t[scompactsum_pri] := t[&gt;scompactsum_pri] (<span class="fstring">"\+"</span> t[&gt;scompactsum_pri])+ =&gt;# <span class="fstring">"(chain 'typ_compactsum _1 _2)"</span> note <span class="fstring">"add"</span>;
<span class="lineno" id=line73></span>  
<span class="lineno" id=line74></span>    <span class="doccomment">multiplication: non-associative.</span>
<span class="lineno" id=line75></span>    t[sproduct_pri] := t[&gt;sproduct_pri] (<span class="fstring">"*"</span> t[&gt;sproduct_pri])+ =&gt;# <span class="fstring">"(chain 'typ_tuple _1 _2)"</span> note <span class="fstring">"mul"</span>;
<span class="lineno" id=line76></span>    t[scompactproduct_pri] := t[&gt;scompactproduct_pri] (<span class="fstring">"\*"</span> t[&gt;scompactproduct_pri])+ =&gt;# <span class="fstring">"(chain 'typ_compacttuple _1 _2)"</span> note <span class="fstring">"mul"</span>;
<span class="lineno" id=line77></span>    
<span class="lineno" id=line78></span>    <span class="comment">// questionable precedences here!</span>
<span class="lineno" id=line79></span>    t[sproduct_pri] := t[&gt;sproduct_pri] <span class="fstring">"*+"</span> t[sproduct_pri] =&gt;# <span class="fstring">"`(typ_rptsum ,_sr ,_1 ,_3)"</span>;
<span class="lineno" id=line80></span>    t[sproduct_pri] := t[&gt;sproduct_pri] <span class="fstring">"\*+"</span> t[sproduct_pri] =&gt;# <span class="fstring">"`(typ_compactrptsum ,_sr ,_1 ,_3)"</span>;
<span class="lineno" id=line81></span>  
<span class="lineno" id=line82></span>    <span class="doccomment">Prefix </span>
<span class="lineno" id=line83></span>    t[sprefixed_pri] := <span class="fstring">"~"</span> t[sprefixed_pri] =&gt;# <span class="fstring">"`(typ_dual ,_sr ,_2)"</span>;
<span class="lineno" id=line84></span>  
<span class="lineno" id=line85></span>    t[sprefixed_pri] := <span class="fstring">"!"</span> t[sprefixed_pri] =&gt;# <span class="fstring">"(tPrefix)"</span>;
<span class="lineno" id=line86></span>    t[sprefixed_pri] := <span class="fstring">"+"</span> t[sprefixed_pri] =&gt;# <span class="fstring">"(tprefix 'tprefix_plus)"</span>;
<span class="lineno" id=line87></span>    t[sprefixed_pri] := <span class="fstring">"-"</span> t[sprefixed_pri] =&gt;# <span class="fstring">"(tprefix 'tneg)"</span>;
<span class="lineno" id=line88></span>  
<span class="lineno" id=line89></span>  
<span class="lineno" id=line90></span>    <span class="doccomment">Fortran power.</span>
<span class="lineno" id=line91></span>    t[spower_pri] := t[ssuperscript_pri] <span class="fstring">"**"</span> t[sprefixed_pri] =&gt;# <span class="fstring">"`(typ_tuple_cons ,_sr ,_1 ,_3)"</span>;
<span class="lineno" id=line92></span>    t[spower_pri] := t[ssuperscript_pri] <span class="fstring">"&lt;**&gt;"</span> t[sprefixed_pri] =&gt;# <span class="fstring">"(typ_tuple_snoc ,_sr ,_1 ,_3)"</span>;
<span class="lineno" id=line93></span>  
<span class="lineno" id=line94></span>    <span class="doccomment">Superscript, exponential.</span>
<span class="lineno" id=line95></span>    t[ssuperscript_pri] := t[ssuperscript_pri] <span class="fstring">"^"</span> t[srefr_pri] =&gt;# <span class="fstring">"`(typ_array ,_1 ,_3)"</span>;
<span class="lineno" id=line96></span>    t[ssuperscript_pri] := t[ssuperscript_pri] <span class="fstring">"\^"</span> t[srefr_pri] =&gt;# <span class="fstring">"`(typ_compactarray ,_1 ,_3)"</span>;
<span class="lineno" id=line97></span>  
<span class="lineno" id=line98></span>    t[ssuperscript_pri] := t[ssuperscript_pri] <span class="fstring">"\circ"</span> t[&gt;ssuperscript_pri] =&gt;# <span class="fstring">"(tInfix)"</span>;
<span class="lineno" id=line99></span>    t[ssuperscript_pri] := t[ssuperscript_pri] <span class="fstring">"\cdot"</span> t[&gt;ssuperscript_pri] =&gt;# <span class="fstring">"(tInfix)"</span>;
<span class="lineno" id=line100></span>  
<span class="lineno" id=line101></span>    t[sapplication_pri] := t[sapplication_pri] t[&gt;sapplication_pri] =&gt;# 
<span class="lineno" id=line102></span>      <span class="fstring">"`(typ_apply ,_sr (,_1 ,_2))"</span> note <span class="fstring">"apply"</span>;
<span class="lineno" id=line103></span>  
<span class="lineno" id=line104></span>    <span class="comment">// -----------------</span>
<span class="lineno" id=line105></span>    <span class="comment">// typesets</span>
<span class="lineno" id=line106></span>    <span class="comment">// -----------------</span>
<span class="lineno" id=line107></span>    <span class="big_keyword" title="Define order of syntactic priority symbols">priority</span>
<span class="lineno" id=line108></span>      tset_lambda_pri &lt;
<span class="lineno" id=line109></span>      tset_union_pri &lt;
<span class="lineno" id=line110></span>      tset_intersection_pri &lt;
<span class="lineno" id=line111></span>      tset_application_pri &lt;
<span class="lineno" id=line112></span>      tset_atomic_pri 
<span class="lineno" id=line113></span>    ;
<span class="lineno" id=line114></span>  
<span class="lineno" id=line115></span>    <span class="doccomment">Typeset </span>
<span class="lineno" id=line116></span>    stmt := <span class="fstring">"typeset"</span> sdeclname <span class="fstring">"="</span> stypeset <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line117></span>      <span class="fstring">"""
<span class="lineno" id=line118></span>      `(ast_type_alias ,_sr ,(first _2) ,(second _2) ,_4)
<span class="lineno" id=line119></span>      """</span>;
<span class="lineno" id=line120></span>  
<span class="lineno" id=line121></span>    t[slambda_pri] := tys[tset_lambda_pri] =&gt;# <span class="fstring">'_1'</span>;
<span class="lineno" id=line122></span>  
<span class="lineno" id=line123></span>    stypeset = tys[tset_lambda_pri];
<span class="lineno" id=line124></span>  
<span class="lineno" id=line125></span>    tys[tset_atomic_pri] := squalified_name =&gt;# <span class="fstring">"_1"</span>; 
<span class="lineno" id=line126></span>    tys[tset_atomic_pri] := <span class="fstring">"("</span> t[slambda_pri] <span class="fstring">")"</span>  =&gt;# <span class="fstring">"_2"</span>; 
<span class="lineno" id=line127></span>    tys[tset_application_pri] := t[sapplication_pri] t[&gt;sapplication_pri]  =&gt;# 
<span class="lineno" id=line128></span>      <span class="fstring">"`(typ_apply ,_sr (,_1 ,_2))"</span> note <span class="fstring">"apply"</span>;
<span class="lineno" id=line129></span>  
<span class="lineno" id=line130></span>    <span class="comment">//t[sapplication_pri] := "typesetof" "(" list::commalist1&lt;stypeexpr&gt; ")" =&gt;# "`(typ_typeset ,_sr ,_3)"; </span>
<span class="lineno" id=line131></span>    tys[tset_atomic_pri] := <span class="fstring">"{"</span> <span class="library" title="functional, singly linked list">list</span>::commalist1&lt;stypeexpr&gt; <span class="fstring">"}"</span> =&gt;# 
<span class="lineno" id=line132></span>      <span class="fstring">"`(typ_typeset ,_sr ,_2)"</span>; 
<span class="lineno" id=line133></span>  
<span class="lineno" id=line134></span>    tys[tset_union_pri] := tys[tset_union_pri] <span class="fstring">"\cup"</span> tys[&gt;tset_union_pri] =&gt;# 
<span class="lineno" id=line135></span>      <span class="fstring">"`(typ_typesetunion ,_sr ,_1 ,_3)"</span>;
<span class="lineno" id=line136></span>    tys[tset_intersection_pri] := tys[tset_intersection_pri] <span class="fstring">"\cap"</span> tys[&gt;tset_intersection_pri] =&gt;# 
<span class="lineno" id=line137></span>      <span class="fstring">"`(typ_typesetintersection ,_sr ,_1 ,_3)"</span>;
<span class="lineno" id=line138></span>  
<span class="lineno" id=line139></span>    <span class="comment">// -----------------</span>
<span class="lineno" id=line140></span>  
<span class="lineno" id=line141></span>  
<span class="lineno" id=line142></span>    t[sfactor_pri] := t[sfactor_pri] <span class="fstring">"."</span> t[&gt;sfactor_pri] =&gt;# <span class="fstring">"`(typ_apply ,_sr (,_3 ,_1))"</span>;
<span class="lineno" id=line143></span>  
<span class="lineno" id=line144></span>   
<span class="lineno" id=line145></span>    t[sthename_pri] := <span class="fstring">"typeof"</span> <span class="fstring">"("</span> sexpr <span class="fstring">")"</span> =&gt;# <span class="fstring">"`(typ_typeof ,_sr ,_3)"</span>;
<span class="lineno" id=line146></span>  
<span class="lineno" id=line147></span>    t[sthename_pri] := <span class="fstring">"_typeop"</span> <span class="fstring">"("</span> sstring <span class="fstring">","</span> stypeexpr <span class="fstring">","</span> skindexpr <span class="fstring">")"</span> =&gt;#
<span class="lineno" id=line148></span>      <span class="fstring">"`(typ_typeop ,_sr ,_3 ,_5 ,_7)"</span>;
<span class="lineno" id=line149></span>    t[sthename_pri] := <span class="fstring">"&amp;"</span> t[sthename_pri] =&gt;# <span class="fstring">"`(typ_ref ,_sr ,_2)"</span>;
<span class="lineno" id=line150></span>  
<span class="lineno" id=line151></span>    <span class="doccomment">Felix pointer type and address of operator.</span>
<span class="lineno" id=line152></span>    t[sthename_pri] := <span class="fstring">"_uniq"</span>       t[sthename_pri] =&gt;# <span class="fstring">"`(typ_uniq ,_sr ,_2)"</span>;
<span class="lineno" id=line153></span>    t[sthename_pri] := <span class="fstring">"_borrowed"</span>   t[sthename_pri] =&gt;# <span class="fstring">"`(typ_borrowed ,_sr ,_2)"</span>;
<span class="lineno" id=line154></span>    t[sthename_pri] := <span class="fstring">"_rref"</span>       t[sthename_pri] =&gt;# <span class="fstring">"`(typ_rref ,_sr ,_2)"</span>;
<span class="lineno" id=line155></span>    t[sthename_pri] := <span class="fstring">"_vref"</span>       t[sthename_pri] =&gt;# <span class="fstring">"`(typ_vref ,_sr ,_2)"</span>;
<span class="lineno" id=line156></span>    t[sthename_pri] := <span class="fstring">"&amp;&lt;&lt;"</span>         t[sthename_pri] =&gt;# <span class="fstring">"`(typ_vref ,_sr ,_2)"</span>;
<span class="lineno" id=line157></span>    t[sthename_pri] := <span class="fstring">"&amp;&lt;"</span>          t[sthename_pri] =&gt;# <span class="fstring">"`(typ_rref ,_sr ,_2)"</span>;
<span class="lineno" id=line158></span>    t[sthename_pri] := <span class="fstring">"_wref"</span>       t[sthename_pri] =&gt;# <span class="fstring">"`(typ_wref ,_sr ,_2)"</span>;
<span class="lineno" id=line159></span>    t[sthename_pri] := <span class="fstring">"&amp;&gt;"</span>          t[sthename_pri] =&gt;# <span class="fstring">"`(typ_wref ,_sr ,_2)"</span>;
<span class="lineno" id=line160></span>    t[sthename_pri] := <span class="fstring">"@"</span>           t[sthename_pri] =&gt;# <span class="fstring">"(tPrefix)"</span>;
<span class="lineno" id=line161></span>    t[sthename_pri] := squalified_name =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line162></span>    t[sthename_pri] := tfuncref =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line163></span>  
<span class="lineno" id=line164></span>  <span class="comment">// TYPE MATCH HACKS .. FIX LATER</span>
<span class="lineno" id=line165></span>    t[sthename_pri] := <span class="fstring">"?"</span> sname =&gt;# <span class="fstring">"`(typ_patvar ,_sr ,_2)"</span>;
<span class="lineno" id=line166></span>  
<span class="lineno" id=line167></span>    t[sthename_pri] := <span class="fstring">"#?"</span> sinteger =&gt;# <span class="fstring">"`(PARSER_ARGUMENT ,_2)"</span>;
<span class="lineno" id=line168></span>  
<span class="lineno" id=line169></span>    <span class="doccomment">Match anything without naming the subexpression.</span>
<span class="lineno" id=line170></span>    tatom := <span class="fstring">"_"</span> =&gt;# <span class="fstring">"`(typ_patany ,_sr)"</span>;
<span class="lineno" id=line171></span>  
<span class="lineno" id=line172></span>    t[satomic_pri] := tatom =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line173></span>  
<span class="lineno" id=line174></span>    <span class="doccomment">Record type.</span>
<span class="lineno" id=line175></span>    tatom := <span class="fstring">"("</span> srecord_mem_decl (<span class="fstring">","</span> srecord_mem_decl2)*  <span class="fstring">")"</span> =&gt;# 
<span class="lineno" id=line176></span>     <span class="fstring">"`(ast_record_type ,(cons _2 (map second _3)))"</span>;
<span class="lineno" id=line177></span>      srecord_mem_decl := sname <span class="fstring">":"</span> stypeexpr =&gt;# <span class="fstring">"`(,_1 ,_3)"</span>;
<span class="lineno" id=line178></span>      srecord_mem_decl := <span class="fstring">":"</span> stypeexpr =&gt;# <span class="fstring">'`("" ,_2)'</span>;
<span class="lineno" id=line179></span>      srecord_mem_decl2 := sname <span class="fstring">":"</span> stypeexpr =&gt;# <span class="fstring">"`(,_1 ,_3)"</span>;
<span class="lineno" id=line180></span>      srecord_mem_decl2 := <span class="fstring">":"</span> stypeexpr =&gt;# <span class="fstring">'`("" ,_2)'</span>;
<span class="lineno" id=line181></span>      srecord_mem_decl2 := stypeexpr =&gt;# <span class="fstring">'`("" ,_1)'</span>;
<span class="lineno" id=line182></span>  
<span class="lineno" id=line183></span>    <span class="doccomment">polyRecord type.</span>
<span class="lineno" id=line184></span>    tatom := <span class="fstring">"("</span> srecord_mem_decl (<span class="fstring">","</span> srecord_mem_decl2)*  <span class="fstring">"|"</span> srecord_mem_decl2 <span class="fstring">")"</span> =&gt;# 
<span class="lineno" id=line185></span>     <span class="fstring">"`(ast_polyrecord_type ,(cons _2 (map second _3)) ,_5)"</span>;
<span class="lineno" id=line186></span>  
<span class="lineno" id=line187></span>  
<span class="lineno" id=line188></span>    <span class="comment">// INCONSISTENT GRAMMAR (no separator between items??</span>
<span class="lineno" id=line189></span>    <span class="doccomment">Variant type.</span>
<span class="lineno" id=line190></span>    tatom := <span class="fstring">"("</span> stype_variant_items <span class="fstring">")"</span> =&gt;# <span class="fstring">"`(ast_variant_type ,_2)"</span>;
<span class="lineno" id=line191></span>      stype_variant_item := <span class="fstring">"case"</span> sname <span class="fstring">"of"</span> stypeexpr =&gt;# <span class="fstring">"`(ctor ,_2 ,_4)"</span>;
<span class="lineno" id=line192></span>      stype_variant_item := <span class="fstring">"case"</span> sname =&gt;# <span class="fstring">"`(ctor ,_2 ,(noi 'unit))"</span>;
<span class="lineno" id=line193></span>      stype_variant_item := <span class="fstring">"`"</span> sname <span class="fstring">"of"</span> stypeexpr =&gt;# <span class="fstring">"`(ctor ,_2 ,_4)"</span>;
<span class="lineno" id=line194></span>      stype_variant_item := <span class="fstring">"`"</span> sname =&gt;# <span class="fstring">"`(ctor ,_2 ,(noi 'unit))"</span>;
<span class="lineno" id=line195></span>  
<span class="lineno" id=line196></span>      stype_variant_item_bar := <span class="fstring">"|"</span> stype_variant_item =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line197></span>      stype_variant_item_bar := <span class="fstring">"|"</span> stypeexpr =&gt;# <span class="fstring">"`(base ,_2)"</span>;
<span class="lineno" id=line198></span>      stype_variant_items := stypeexpr stype_variant_item_bar+ =&gt;# <span class="fstring">"(cons `(base ,_1) _2)"</span>;
<span class="lineno" id=line199></span>      stype_variant_items := stype_variant_item stype_variant_item_bar* =&gt;# <span class="fstring">"(cons _1 _2)"</span>;
<span class="lineno" id=line200></span>      stype_variant_items := stype_variant_item_bar+ =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line201></span>  
<span class="lineno" id=line202></span>    <span class="comment">// can't use typeexpr here because trailing "&gt;" is a comparison operator ..</span>
<span class="lineno" id=line203></span>    tatom := <span class="fstring">"_pclt&lt;"</span> t[&gt;scomparison_pri] <span class="fstring">","</span> t[&gt;scomparison_pri] <span class="fstring">"&gt;"</span> =&gt;# <span class="fstring">"`(typ_pclt ,_sr ,_2 ,_4)"</span> ;
<span class="lineno" id=line204></span>    tatom := <span class="fstring">"_rpclt&lt;"</span> t[&gt;scomparison_pri] <span class="fstring">","</span> t[&gt;scomparison_pri] <span class="fstring">"&gt;"</span> =&gt;# <span class="fstring">"`(typ_rpclt ,_sr ,_2 ,_4)"</span> ;
<span class="lineno" id=line205></span>    tatom := <span class="fstring">"_wpclt&lt;"</span> t[&gt;scomparison_pri] <span class="fstring">","</span> t[&gt;scomparison_pri] <span class="fstring">"&gt;"</span> =&gt;# <span class="fstring">"`(typ_wpclt ,_sr ,_2 ,_4)"</span> ;
<span class="lineno" id=line206></span>  
<span class="lineno" id=line207></span>  
<span class="lineno" id=line208></span>    <span class="doccomment">scalar literals (numbers, strings).</span>
<span class="lineno" id=line209></span>    tatom := sliteral =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line210></span>    tatom := <span class="fstring">"("</span> <span class="fstring">")"</span> =&gt;# <span class="fstring">"`(typ_type_tuple ,_sr ())"</span>;
<span class="lineno" id=line211></span>    tatom := <span class="fstring">"("</span> stype <span class="fstring">")"</span> =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line212></span>    tatom := <span class="fstring">"extend"</span> stypeexpr_comma_list <span class="fstring">"with"</span> stypeexpr <span class="fstring">"end"</span> =&gt;# <span class="fstring">"""
<span class="lineno" id=line213></span>      `(typ_type_extension ,_sr ,_2 ,_4)
<span class="lineno" id=line214></span>    """</span>;
<span class="lineno" id=line215></span>  
<span class="lineno" id=line216></span>    tatom := stypematch =&gt;# <span class="fstring">'_1'</span>;
<span class="lineno" id=line217></span>  
<span class="lineno" id=line218></span>    stypematch := <span class="fstring">"typematch"</span> stype <span class="fstring">"with"</span> stype_matching+ <span class="fstring">"endmatch"</span> =&gt;#
<span class="lineno" id=line219></span>      <span class="fstring">"`(ast_type_match ,_sr (,_2 ,_4))"</span>;
<span class="lineno" id=line220></span>    stypematch := <span class="fstring">"subtypematch"</span> stype <span class="fstring">"with"</span> stype_matching+ <span class="fstring">"endmatch"</span> =&gt;#
<span class="lineno" id=line221></span>      <span class="fstring">"`(ast_subtype_match ,_sr (,_2 ,_4))"</span>;
<span class="lineno" id=line222></span>    stype_matching := <span class="fstring">"|"</span> stype <span class="fstring">"=&gt;"</span> stype =&gt;# <span class="fstring">"`(,_2 ,_4)"</span>;
<span class="lineno" id=line223></span>  
<span class="lineno" id=line224></span>  
<span class="lineno" id=line225></span>  <span class="comment">// TYPE LANGUAGE ENDS</span>
<span class="lineno" id=line226></span>  }
<span class="lineno" id=line227></span>  
</pre></p><h2 id='Expressions._h'><img src='/share/src/web/images/minus.gif' id='Expressions.' onclick='toggle(this,"Expressions._d")' alt='+'/> 1.1 Expressions.</h2><div id='Expressions._d' style='display:block'>
<p>See also other packages containing extensions.
</p><pre class='inclusion'>
share/lib/grammar/expressions.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> expressions {
<span class="lineno" id=line2></span>    <span class="big_keyword" title="Define order of syntactic priority symbols">priority</span> 
<span class="lineno" id=line3></span>      let_pri &lt; 
<span class="lineno" id=line4></span>      slambda_pri &lt;
<span class="lineno" id=line5></span>      spipe_apply_pri &lt;
<span class="lineno" id=line6></span>      sdollar_apply_pri &lt; 
<span class="lineno" id=line7></span>  
<span class="lineno" id=line8></span>      <span class="comment">// TUPLES</span>
<span class="lineno" id=line9></span>      stuple_cons_pri &lt;
<span class="lineno" id=line10></span>      stuple_pri &lt;
<span class="lineno" id=line11></span>      scompacttuple_pri &lt;
<span class="lineno" id=line12></span>  
<span class="lineno" id=line13></span>      <span class="comment">// LOGIC</span>
<span class="lineno" id=line14></span>      simplies_condition_pri &lt;
<span class="lineno" id=line15></span>      sor_condition_pri &lt;
<span class="lineno" id=line16></span>      sand_condition_pri &lt;
<span class="lineno" id=line17></span>      snot_condition_pri &lt;
<span class="lineno" id=line18></span>  
<span class="lineno" id=line19></span>      <span class="comment">// TEX LOGIC</span>
<span class="lineno" id=line20></span>      stex_implies_condition_pri &lt;
<span class="lineno" id=line21></span>      stex_or_condition_pri &lt;
<span class="lineno" id=line22></span>      stex_and_condition_pri &lt;
<span class="lineno" id=line23></span>      stex_not_condition_pri &lt;
<span class="lineno" id=line24></span>  
<span class="lineno" id=line25></span>      <span class="comment">// COMPARISONS</span>
<span class="lineno" id=line26></span>      scomparison_pri &lt;
<span class="lineno" id=line27></span>      sas_expr_pri &lt;
<span class="lineno" id=line28></span>  
<span class="lineno" id=line29></span>      <span class="comment">// SETWISE OPERATORS</span>
<span class="lineno" id=line30></span>      ssetunion_pri &lt;
<span class="lineno" id=line31></span>      ssetintersection_pri &lt;
<span class="lineno" id=line32></span>      sarrow_pri &lt;
<span class="lineno" id=line33></span>      scase_literal_pri &lt;
<span class="lineno" id=line34></span>  
<span class="lineno" id=line35></span>      <span class="comment">// BITWISE OPERATORS</span>
<span class="lineno" id=line36></span>      sbor_pri &lt;
<span class="lineno" id=line37></span>      sbxor_pri &lt;
<span class="lineno" id=line38></span>      sband_pri &lt;
<span class="lineno" id=line39></span>      sshift_pri &lt;
<span class="lineno" id=line40></span>  
<span class="lineno" id=line41></span>      <span class="comment">// NUMERIC OPERATORS</span>
<span class="lineno" id=line42></span>      ssum_pri &lt;
<span class="lineno" id=line43></span>      scompactsum_pri &lt;
<span class="lineno" id=line44></span>      ssubtraction_pri &lt;
<span class="lineno" id=line45></span>      sproduct_pri &lt;
<span class="lineno" id=line46></span>      scompactproduct_pri &lt;
<span class="lineno" id=line47></span>      s_term_pri &lt;        <span class="comment">// division </span>
<span class="lineno" id=line48></span>  
<span class="lineno" id=line49></span>      <span class="comment">// STUFF</span>
<span class="lineno" id=line50></span>      sprefixed_pri &lt;
<span class="lineno" id=line51></span>      spower_pri &lt;
<span class="lineno" id=line52></span>      ssuperscript_pri &lt;
<span class="lineno" id=line53></span>      srefr_pri &lt;
<span class="lineno" id=line54></span>      scoercion_pri &lt;
<span class="lineno" id=line55></span>  
<span class="lineno" id=line56></span>      <span class="comment">// WHITESPACE APPLICATION</span>
<span class="lineno" id=line57></span>      sapplication_pri &lt;
<span class="lineno" id=line58></span>      sfactor_pri &lt;
<span class="lineno" id=line59></span>      srcompose_pri &lt;
<span class="lineno" id=line60></span>      sthename_pri &lt;
<span class="lineno" id=line61></span>      satomic_pri
<span class="lineno" id=line62></span>    ;
<span class="lineno" id=line63></span>  
<span class="lineno" id=line64></span>    <span class="big_keyword" title="specify requirements">requires</span> 
<span class="lineno" id=line65></span>      types, setexpr, cmpexpr, pordcmpexpr, tordcmpexpr, 
<span class="lineno" id=line66></span>      addexpr, mulexpr, divexpr,
<span class="lineno" id=line67></span>      bitexpr,
<span class="lineno" id=line68></span>      spipeexpr, boolexpr, stringexpr, listexpr, tupleexpr
<span class="lineno" id=line69></span>    ;
<span class="lineno" id=line70></span>    sexpr := x[let_pri] =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line71></span>  
<span class="lineno" id=line72></span>    <span class="doccomment">Let binding.</span>
<span class="lineno" id=line73></span>    x[let_pri] := <span class="fstring">"let"</span> spattern <span class="fstring">"="</span> x[let_pri] <span class="fstring">"in"</span> x[let_pri] =&gt;# <span class="fstring">"`(ast_letin ,_sr (,_2 ,_4 ,_6))"</span>;
<span class="lineno" id=line74></span>  
<span class="lineno" id=line75></span>    <span class="doccomment">Let fun binding.</span>
<span class="lineno" id=line76></span>    x[let_pri] := <span class="fstring">"let"</span> <span class="fstring">"fun"</span> sdeclname sfun_arg* fun_return_type <span class="fstring">"=&gt;"</span> x[let_pri] <span class="fstring">"in"</span> x[let_pri] =&gt;# 
<span class="lineno" id=line77></span>      <span class="fstring">"""
<span class="lineno" id=line78></span>      (let* 
<span class="lineno" id=line79></span>        (
<span class="lineno" id=line80></span>          (body `((ast_fun_return ,_sr ,_7)))
<span class="lineno" id=line81></span>          (fun_decl `(ast_curry_effects ,_sr ,(first _3) ,(second _3) ,_4 ,(first _5) ,(second _5) Function () ,body))
<span class="lineno" id=line82></span>          (final_return `(ast_fun_return ,_sr ,_9))
<span class="lineno" id=line83></span>        )
<span class="lineno" id=line84></span>        (block_expr `(,fun_decl ,final_return))
<span class="lineno" id=line85></span>      )
<span class="lineno" id=line86></span>      """</span>;
<span class="lineno" id=line87></span>  
<span class="lineno" id=line88></span>    <span class="comment">// FIXME</span>
<span class="lineno" id=line89></span>    x[let_pri] := <span class="fstring">"let"</span> <span class="fstring">"fun"</span> sdeclname fun_return_type <span class="fstring">"="</span> smatching+ <span class="fstring">"in"</span> x[let_pri] =&gt;#
<span class="lineno" id=line90></span>      <span class="fstring">"""
<span class="lineno" id=line91></span>      (let* 
<span class="lineno" id=line92></span>        (
<span class="lineno" id=line93></span>          (ixname _3)
<span class="lineno" id=line94></span>          (name (first ixname))
<span class="lineno" id=line95></span>          (tvars (second ixname))
<span class="lineno" id=line96></span>          (t (first (first _4)))
<span class="lineno" id=line97></span>          (traint (second (first _4)))
<span class="lineno" id=line98></span>          (matching _6)
<span class="lineno" id=line99></span>          (expr _8)
<span class="lineno" id=line100></span>        )
<span class="lineno" id=line101></span>        (if (eq? 'typ_arrow (first t))
<span class="lineno" id=line102></span>          (let*
<span class="lineno" id=line103></span>            (
<span class="lineno" id=line104></span>              (argt (caadr t))
<span class="lineno" id=line105></span>              (ret (cadadr t))
<span class="lineno" id=line106></span>              (params `((((,_sr PVal _a ,argt none)) none))) ;; parameters
<span class="lineno" id=line107></span>              (body `((ast_fun_return ,_sr (ast_match ,_sr (,(noi '_a) ,matching)))))
<span class="lineno" id=line108></span>              (fun_decl `(ast_curry ,_sr ,name ,tvars ,params
<span class="lineno" id=line109></span>                 (,ret ,traint)
<span class="lineno" id=line110></span>                 Function () ,body)
<span class="lineno" id=line111></span>              )
<span class="lineno" id=line112></span>              (final_return `(ast_fun_return ,_sr ,expr))
<span class="lineno" id=line113></span>            )
<span class="lineno" id=line114></span>            (block_expr `(,fun_decl ,final_return))
<span class="lineno" id=line115></span>          )
<span class="lineno" id=line116></span>          'ERROR
<span class="lineno" id=line117></span>        )
<span class="lineno" id=line118></span>      )
<span class="lineno" id=line119></span>      """</span>;
<span class="lineno" id=line120></span>  
<span class="lineno" id=line121></span>  
<span class="lineno" id=line122></span>    <span class="doccomment">Unterminated match</span>
<span class="lineno" id=line123></span>    x[let_pri] := <span class="fstring">"let"</span> pattern_match =&gt;# <span class="fstring">"_2"</span>; 
<span class="lineno" id=line124></span>    <span class="comment">// below gets confused with statement expression .. :-)</span>
<span class="lineno" id=line125></span>    satom :=  <span class="fstring">"("</span> <span class="fstring">"var"</span> sname <span class="fstring">"="</span> sexpr <span class="fstring">")"</span> =&gt;# <span class="fstring">"`(ast_as_var ,_sr (,_5 ,_3))"</span>;
<span class="lineno" id=line126></span>    satom :=  <span class="fstring">"("</span> <span class="fstring">"val"</span> sname <span class="fstring">"="</span> sexpr <span class="fstring">")"</span> =&gt;# <span class="fstring">"`(ast_as ,_sr (,_5 ,_3))"</span>;
<span class="lineno" id=line127></span>  
<span class="lineno" id=line128></span>    <span class="doccomment">Conditional expression.</span>
<span class="lineno" id=line129></span>    x[let_pri] := sconditional =&gt;# <span class="fstring">'_1'</span>;
<span class="lineno" id=line130></span>  
<span class="lineno" id=line131></span>    <span class="doccomment">Pattern matching.</span>
<span class="lineno" id=line132></span>    x[let_pri] := pattern_match =&gt;# <span class="fstring">'_1'</span>;
<span class="lineno" id=line133></span>  
<span class="lineno" id=line134></span>  
<span class="lineno" id=line135></span>    <span class="doccomment">Low precedence right associative application.</span>
<span class="lineno" id=line136></span>    x[sdollar_apply_pri] := x[&gt;sdollar_apply_pri] <span class="fstring">"$"</span> x[sdollar_apply_pri] =&gt;# 
<span class="lineno" id=line137></span>      <span class="fstring">"`(ast_apply ,_sr (,_1 ,_3))"</span>;
<span class="lineno" id=line138></span>  
<span class="lineno" id=line139></span>    <span class="doccomment">Low precedence left associative reverse application.</span>
<span class="lineno" id=line140></span>    x[spipe_apply_pri] := x[spipe_apply_pri] <span class="fstring">"|&gt;"</span> x[&gt;spipe_apply_pri] =&gt;# 
<span class="lineno" id=line141></span>      <span class="fstring">"`(ast_apply ,_sr (,_3 ,_1))"</span>;
<span class="lineno" id=line142></span>  
<span class="lineno" id=line143></span>    <span class="doccomment">Haskell-ish style infix notation of functions   foo(x,y) =&gt; x `(foo) y</span>
<span class="lineno" id=line144></span>    x[stuple_pri]  := x[stuple_pri] <span class="fstring">"`("</span> sexpr <span class="fstring">")"</span> sexpr =&gt;# 
<span class="lineno" id=line145></span>      <span class="fstring">"(binop _3 _1 _5)"</span>;
<span class="lineno" id=line146></span>  
<span class="lineno" id=line147></span>    <span class="doccomment">Named temporary value.</span>
<span class="lineno" id=line148></span>    x[sas_expr_pri] := x[sas_expr_pri] <span class="fstring">"as"</span> sname =&gt;# <span class="fstring">"`(ast_as ,_sr (,_1 ,_3))"</span>;
<span class="lineno" id=line149></span>  
<span class="lineno" id=line150></span>    <span class="doccomment">Named variable.</span>
<span class="lineno" id=line151></span>    x[sas_expr_pri] := x[sas_expr_pri] <span class="fstring">"as"</span> <span class="fstring">"var"</span> sname =&gt;# <span class="fstring">"`(ast_as_var ,_sr (,_1 ,_4))"</span>;
<span class="lineno" id=line152></span>  
<span class="lineno" id=line153></span>  
<span class="lineno" id=line154></span>    x[sarrow_pri] := x[&gt;sarrow_pri] <span class="fstring">".."</span> x[&gt;sarrow_pri] =&gt;# <span class="fstring">"(infix 'Slice_range_incl)"</span>;
<span class="lineno" id=line155></span>    x[sarrow_pri] := x[&gt;sarrow_pri] <span class="fstring">"..&lt;"</span> x[&gt;sarrow_pri] =&gt;# <span class="fstring">"(infix 'Slice_range_excl)"</span>;
<span class="lineno" id=line156></span>    x[sarrow_pri] := <span class="fstring">"..&lt;"</span> x[&gt;sarrow_pri] =&gt;# <span class="fstring">"(prefix 'Slice_to_excl)"</span>;
<span class="lineno" id=line157></span>    x[sarrow_pri] := <span class="fstring">".."</span> x[&gt;sarrow_pri] =&gt;# <span class="fstring">"(prefix 'Slice_to_incl)"</span>;
<span class="lineno" id=line158></span>    x[sarrow_pri] := x[&gt;sarrow_pri] <span class="fstring">".."</span> =&gt;# <span class="fstring">"(suffix 'Slice_from)"</span>;
<span class="lineno" id=line159></span>    x[sarrow_pri] := <span class="fstring">".."</span> =&gt;# <span class="fstring">"""`(ast_name ,_sr "Slice_all" () )"""</span>;
<span class="lineno" id=line160></span>    x[sarrow_pri] := <span class="fstring">"..["</span> stypeexpr <span class="fstring">"]"</span> =&gt;# <span class="fstring">"""`(ast_type_slice ,_sr ,_2 )"""</span>;
<span class="lineno" id=line161></span>    x[sarrow_pri] := x[&gt;sarrow_pri] <span class="fstring">".+"</span> x[&gt;sarrow_pri] =&gt;# <span class="fstring">"(infix 'Slice_from_counted)"</span>;
<span class="lineno" id=line162></span>  
<span class="lineno" id=line163></span>  
<span class="lineno" id=line164></span>    x[scase_literal_pri] := <span class="fstring">"case"</span> sinteger =&gt;# <span class="fstring">"`(ast_case_tag ,_sr ,_2))"</span>;
<span class="lineno" id=line165></span>    x[scase_literal_pri] := <span class="fstring">"`"</span> sinteger =&gt;# <span class="fstring">"`(ast_case_tag ,_sr ,_2))"</span>;
<span class="lineno" id=line166></span>  
<span class="lineno" id=line167></span>    <span class="doccomment">Case value.</span>
<span class="lineno" id=line168></span>    x[scase_literal_pri] := <span class="fstring">"case"</span> sinteger <span class="fstring">"of"</span> t[ssum_pri] =&gt;# <span class="fstring">"`(ast_unitsum_literal  ,_sr ,_2 ,_4)"</span>;
<span class="lineno" id=line169></span>    x[scase_literal_pri] := <span class="fstring">"`"</span> sinteger <span class="fstring">"of"</span> t[ssum_pri] =&gt;# <span class="fstring">"`(ast_unitsum_literal ,_sr  ,_2 ,_4)"</span>;
<span class="lineno" id=line170></span>    x[scase_literal_pri] := <span class="fstring">"`"</span> sinteger <span class="fstring">":"</span> t[ssum_pri] =&gt;# <span class="fstring">"`(ast_unitsum_literal ,_sr ,_2 ,_4)"</span>;
<span class="lineno" id=line171></span>  
<span class="lineno" id=line172></span>    <span class="doccomment">Tuple projection function.</span>
<span class="lineno" id=line173></span>    x[scase_literal_pri] := <span class="fstring">"proj"</span> sinteger <span class="fstring">"of"</span> t[ssum_pri] =&gt;# <span class="fstring">"`(ast_projection ,_sr ,_2 ,_4)"</span>;
<span class="lineno" id=line174></span>    x[scase_literal_pri] := <span class="fstring">"aproj"</span> sexpr <span class="fstring">"of"</span> t[ssum_pri] =&gt;# <span class="fstring">"`(ast_array_projection ,_sr ,_2 ,_4)"</span>;
<span class="lineno" id=line175></span>    x[scase_literal_pri] := <span class="fstring">"ident"</span> <span class="fstring">"of"</span> t[ssum_pri] =&gt;# <span class="fstring">"`(ast_identity_function ,_sr ,_3)"</span>;
<span class="lineno" id=line176></span>  
<span class="lineno" id=line177></span>    <span class="comment">// coarray injection</span>
<span class="lineno" id=line178></span>    <span class="comment">// (ainj (r:&gt;&gt;4) of (4 *+ int)) 42</span>
<span class="lineno" id=line179></span>    x[scase_literal_pri] := <span class="fstring">"ainj"</span> sexpr <span class="fstring">"of"</span> t[ssum_pri] =&gt;# <span class="fstring">"`(ast_ainj ,_sr ,_2 ,_4)"</span>;
<span class="lineno" id=line180></span>  
<span class="lineno" id=line181></span>    spv_name := <span class="fstring">"case"</span> sname =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line182></span>    spv_name := <span class="fstring">"`"</span> sname =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line183></span>  
<span class="lineno" id=line184></span>    <span class="doccomment">Variant value.</span>
<span class="lineno" id=line185></span>    x[sthename_pri] := <span class="fstring">"#"</span> spv_name =&gt;# <span class="fstring">"`(ast_variant (,_2 ()))"</span>;
<span class="lineno" id=line186></span>    x[sapplication_pri] := spv_name  x[&gt;sapplication_pri] =&gt;# <span class="fstring">"`(ast_variant (,_1 ,_2))"</span>;
<span class="lineno" id=line187></span>  
<span class="lineno" id=line188></span>    <span class="doccomment">multiplication: right associative</span>
<span class="lineno" id=line189></span>    x[sproduct_pri] := x[&gt;sproduct_pri] <span class="fstring">"\otimes"</span> x[sproduct_pri] =&gt;# <span class="fstring">"(Infix)"</span>;
<span class="lineno" id=line190></span>    x[sproduct_pri] := x[sproduct_pri]  (<span class="fstring">"/\"</span> x[&gt;sproduct_pri])+ =&gt;# <span class="fstring">"(chain 'ast_intersect _1 _2)"</span>;
<span class="lineno" id=line191></span>  
<span class="lineno" id=line192></span>    <span class="comment">// repeated sum type, eg 4 *+ int == int + int + int + int</span>
<span class="lineno" id=line193></span>    <span class="comment">// right associative:  2 *+ 3 *+ int is approx 6 *+ int</span>
<span class="lineno" id=line194></span>    <span class="comment">//x[sproduct_pri] := x[&gt;sproduct_pri] "*+" x[sproduct_pri] =&gt;# "`(ast_rptsum_type ,_sr ,_1 ,_3)";</span>
<span class="lineno" id=line195></span>  
<span class="lineno" id=line196></span>  <span class="comment">//------------------------------------------------------------------------</span>
<span class="lineno" id=line197></span>  
<span class="lineno" id=line198></span>    <span class="doccomment">Prefix exclaim.</span>
<span class="lineno" id=line199></span>    x[sprefixed_pri] := <span class="fstring">"!"</span> x[sprefixed_pri] =&gt;# <span class="fstring">"(Prefix)"</span>;
<span class="lineno" id=line200></span>  
<span class="lineno" id=line201></span>    <span class="doccomment">Prefix plus.</span>
<span class="lineno" id=line202></span>    x[sprefixed_pri] := <span class="fstring">"+"</span> x[sprefixed_pri] =&gt;# <span class="fstring">"(prefix 'prefix_plus)"</span>;
<span class="lineno" id=line203></span>  
<span class="lineno" id=line204></span>    <span class="doccomment">Prefix negation.</span>
<span class="lineno" id=line205></span>    x[sprefixed_pri] := <span class="fstring">"-"</span> x[sprefixed_pri] =&gt;# <span class="fstring">"(prefix 'neg)"</span>;
<span class="lineno" id=line206></span>  
<span class="lineno" id=line207></span>    <span class="doccomment">Prefix complement.</span>
<span class="lineno" id=line208></span>    x[sprefixed_pri] := <span class="fstring">"~"</span> x[sprefixed_pri] =&gt;# <span class="fstring">"(Prefix)"</span>;
<span class="lineno" id=line209></span>  
<span class="lineno" id=line210></span>    <span class="doccomment">Fortran power.</span>
<span class="lineno" id=line211></span>    x[spower_pri] := x[ssuperscript_pri] <span class="fstring">"**"</span> x[sprefixed_pri] =&gt;# <span class="fstring">"(infix 'pow)"</span>;
<span class="lineno" id=line212></span>    x[spower_pri] := x[ssuperscript_pri] <span class="fstring">"&lt;**&gt;"</span> x[sprefixed_pri] =&gt;# <span class="fstring">"(infix 'tuple_snoc)"</span>;
<span class="lineno" id=line213></span>  
<span class="lineno" id=line214></span>    <span class="doccomment">Superscript, exponential.</span>
<span class="lineno" id=line215></span>    x[ssuperscript_pri] := x[ssuperscript_pri] <span class="fstring">"^"</span> x[srefr_pri] =&gt;# <span class="fstring">"`(ast_superscript (,_1 ,_3))"</span>;
<span class="lineno" id=line216></span>  
<span class="lineno" id=line217></span>    <span class="doccomment">composition</span>
<span class="lineno" id=line218></span>    x[ssuperscript_pri] := x[ssuperscript_pri] <span class="fstring">"\circ"</span> x[&gt;ssuperscript_pri] =&gt;# <span class="fstring">"(Infix)"</span>;
<span class="lineno" id=line219></span>    x[ssuperscript_pri] := x[ssuperscript_pri] <span class="fstring">"\cdot"</span> x[&gt;ssuperscript_pri] =&gt;# <span class="fstring">"(Infix)"</span>;
<span class="lineno" id=line220></span>  
<span class="lineno" id=line221></span>  <span class="comment">//------------------------------------------------------------------------</span>
<span class="lineno" id=line222></span>    <span class="doccomment">C dereference.</span>
<span class="lineno" id=line223></span>    x[srefr_pri] := <span class="fstring">"*"</span> x[srefr_pri] =&gt;# <span class="fstring">"(prefix 'deref)"</span>;
<span class="lineno" id=line224></span>  
<span class="lineno" id=line225></span>    <span class="doccomment">Deref primitive.</span>
<span class="lineno" id=line226></span>    x[srefr_pri] := <span class="fstring">"_deref"</span> x[srefr_pri] =&gt;# <span class="fstring">"`(ast_deref ,_sr ,_2)"</span>;
<span class="lineno" id=line227></span>  
<span class="lineno" id=line228></span>    <span class="doccomment">Operator new.</span>
<span class="lineno" id=line229></span>    x[srefr_pri] := <span class="fstring">"new"</span> x[srefr_pri] =&gt;# <span class="fstring">"`(ast_new ,_sr ,_2)"</span>;
<span class="lineno" id=line230></span>  
<span class="lineno" id=line231></span>  <span class="comment">//------------------------------------------------------------------------</span>
<span class="lineno" id=line232></span>    <span class="doccomment">Operator whitespace: application.</span>
<span class="lineno" id=line233></span>    x[sapplication_pri] := x[sapplication_pri] x[&gt;sapplication_pri] =&gt;# 
<span class="lineno" id=line234></span>      <span class="fstring">"`(ast_apply ,_sr (,_1 ,_2))"</span> note <span class="fstring">"apply"</span>;
<span class="lineno" id=line235></span>  
<span class="lineno" id=line236></span>    <span class="doccomment">Variant index.</span>
<span class="lineno" id=line237></span>    x[sapplication_pri] := <span class="fstring">"caseno"</span> x[&gt;sapplication_pri] =&gt;# <span class="fstring">"`(ast_case_index ,_sr ,_2)"</span>;
<span class="lineno" id=line238></span>    x[sapplication_pri] := <span class="fstring">"casearg"</span> x[&gt;sapplication_pri] =&gt;# <span class="fstring">"`(ast_rptsum_arg ,_sr ,_2)"</span>;
<span class="lineno" id=line239></span>  
<span class="lineno" id=line240></span>    <span class="doccomment">Optimisation hint: likely.</span>
<span class="lineno" id=line241></span>    <span class="doccomment">Use in conditionals, e.g. if likely(x) do ...</span>
<span class="lineno" id=line242></span>    x[sapplication_pri] := <span class="fstring">"likely"</span> x[&gt;sapplication_pri] =&gt;# <span class="fstring">"`(ast_likely ,_sr ,_2)"</span>;
<span class="lineno" id=line243></span>  
<span class="lineno" id=line244></span>    <span class="doccomment">Optimisation hint: unlikely.</span>
<span class="lineno" id=line245></span>    <span class="doccomment">Use in conditionals, e.g. if unlikely(x) do ...</span>
<span class="lineno" id=line246></span>    x[sapplication_pri] := <span class="fstring">"unlikely"</span> x[&gt;sapplication_pri] =&gt;# <span class="fstring">"`(ast_unlikely ,_sr ,_2)"</span>;
<span class="lineno" id=line247></span>  
<span class="lineno" id=line248></span>  <span class="comment">//------------------------------------------------------------------------</span>
<span class="lineno" id=line249></span>    <span class="doccomment">Suffixed coercion.</span>
<span class="lineno" id=line250></span>    x[slambda_pri] := x[&gt;slambda_pri] <span class="fstring">":&gt;&gt;"</span> stypeexpr =&gt;# <span class="fstring">"`(ast_coercion ,_sr (,_1 ,_3))"</span>;
<span class="lineno" id=line251></span>  
<span class="lineno" id=line252></span>    x[sfactor_pri] := ssuffixed_name =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line253></span>  
<span class="lineno" id=line254></span>  <span class="comment">//------------------------------------------------------------------------</span>
<span class="lineno" id=line255></span>    <span class="doccomment">Reverse application.</span>
<span class="lineno" id=line256></span>    x[sfactor_pri] := x[sfactor_pri] <span class="fstring">"."</span> x[&gt;sfactor_pri] =&gt;# 
<span class="lineno" id=line257></span>      <span class="fstring">"`(ast_apply ,_sr (,_3 ,_1))"</span>;
<span class="lineno" id=line258></span>  
<span class="lineno" id=line259></span>  
<span class="lineno" id=line260></span>    <span class="doccomment">Reverse application with dereference.</span>
<span class="lineno" id=line261></span>    <span class="doccomment">a *. b same as (*a) . b, like C  a -&gt; b.</span>
<span class="lineno" id=line262></span>    x[sfactor_pri] := x[sfactor_pri] <span class="fstring">"*."</span> x[&gt;sfactor_pri] =&gt;# 
<span class="lineno" id=line263></span>      <span class="fstring">"`(ast_apply ,_sr (,_3 (ast_apply ,_sr (,(noi 'deref) ,_1))))"</span>
<span class="lineno" id=line264></span>    ;
<span class="lineno" id=line265></span>    x[sfactor_pri] := x[sfactor_pri] <span class="fstring">"-&gt;"</span> x[&gt;sfactor_pri] =&gt;# 
<span class="lineno" id=line266></span>      <span class="fstring">"`(ast_apply ,_sr (,_3 (ast_apply ,_sr (,(noi 'deref) ,_1))))"</span>
<span class="lineno" id=line267></span>    ;
<span class="lineno" id=line268></span>  
<span class="lineno" id=line269></span>  
<span class="lineno" id=line270></span>  
<span class="lineno" id=line271></span>    <span class="doccomment">a &amp;. b is similar to &amp;a . b for an array, but can be overloaded</span>
<span class="lineno" id=line272></span>    <span class="doccomment">for abstract arrays: like a + b in C. Returns pointer.</span>
<span class="lineno" id=line273></span>    <span class="comment">// x[sfactor_pri] := x[sfactor_pri] "&amp;." sthe_name =&gt;# "(Infix)";</span>
<span class="lineno" id=line274></span>    x[sfactor_pri] := x[sfactor_pri] <span class="fstring">"&amp;."</span> x[&gt;sfactor_pri] =&gt;# <span class="fstring">"`(ast_apply ,_sr (,_3 (ast_ref ,_sr ,_1)))"</span>;
<span class="lineno" id=line275></span>  
<span class="lineno" id=line276></span>  <span class="comment">//------------------------------------------------------------------------</span>
<span class="lineno" id=line277></span>  
<span class="lineno" id=line278></span>    <span class="doccomment">Reverse composition</span>
<span class="lineno" id=line279></span>    x[srcompose_pri] := x[srcompose_pri] <span class="fstring">"\odot"</span> x[&gt;srcompose_pri] =&gt;# <span class="fstring">"(Infix)"</span>;
<span class="lineno" id=line280></span>  
<span class="lineno" id=line281></span>  <span class="comment">//------------------------------------------------------------------------</span>
<span class="lineno" id=line282></span>    <span class="doccomment">High precedence unit application. #f = f ().</span>
<span class="lineno" id=line283></span>    x[sthename_pri] := <span class="fstring">"#"</span> x[sthename_pri] =&gt;# <span class="fstring">"`(ast_apply ,_sr (,_2 (ast_tuple ,_sr ())))"</span>;
<span class="lineno" id=line284></span>  
<span class="lineno" id=line285></span>    <span class="doccomment">Felix pointer type and address of operator.</span>
<span class="lineno" id=line286></span>    x[sthename_pri] := <span class="fstring">"&amp;"</span> x[sthename_pri] =&gt;# <span class="fstring">"`(ast_ref ,_sr ,_2)"</span>;
<span class="lineno" id=line287></span>  
<span class="lineno" id=line288></span>    x[sthename_pri] := <span class="fstring">"_rref"</span> x[sthename_pri] =&gt;# <span class="fstring">"`(ast_rref ,_sr ,_2)"</span>;
<span class="lineno" id=line289></span>    x[sthename_pri] := <span class="fstring">"_vref"</span> x[sthename_pri] =&gt;# <span class="fstring">"`(ast_vref ,_sr ,_2)"</span>;
<span class="lineno" id=line290></span>    x[sthename_pri] := <span class="fstring">"_wref"</span> x[sthename_pri] =&gt;# <span class="fstring">"`(ast_wref ,_sr ,_2)"</span>;
<span class="lineno" id=line291></span>    x[sthename_pri] := <span class="fstring">"&amp;&lt;&lt;"</span> x[sthename_pri] =&gt;# <span class="fstring">"`(ast_vref ,_sr ,_2)"</span>;
<span class="lineno" id=line292></span>    x[sthename_pri] := <span class="fstring">"&amp;&lt;"</span> x[sthename_pri] =&gt;# <span class="fstring">"`(ast_rref ,_sr ,_2)"</span>;
<span class="lineno" id=line293></span>    x[sthename_pri] := <span class="fstring">"&amp;&gt;"</span> x[sthename_pri] =&gt;# <span class="fstring">"`(ast_wref ,_sr ,_2)"</span>;
<span class="lineno" id=line294></span>  
<span class="lineno" id=line295></span>  
<span class="lineno" id=line296></span>    <span class="doccomment">Felix address of operator.</span>
<span class="lineno" id=line297></span>    x[sthename_pri] := <span class="fstring">"label_address"</span> sname =&gt;# <span class="fstring">"`(ast_label_ref ,_sr ,_2)"</span>;
<span class="lineno" id=line298></span>  
<span class="lineno" id=line299></span>  
<span class="lineno" id=line300></span>    <span class="doccomment">macro expansion freezer.</span>
<span class="lineno" id=line301></span>    x[sthename_pri] := <span class="fstring">"noexpand"</span> squalified_name =&gt;# <span class="fstring">"`(ast_noexpand ,_sr ,_2)"</span>;
<span class="lineno" id=line302></span>  
<span class="lineno" id=line303></span>    <span class="doccomment">pattern variable.</span>
<span class="lineno" id=line304></span>    x[sthename_pri] := <span class="fstring">"?"</span> sname =&gt;# <span class="fstring">"`(ast_patvar ,_sr ,_2)"</span>;
<span class="lineno" id=line305></span>  
<span class="lineno" id=line306></span>    <span class="doccomment">Template replacement index.</span>
<span class="lineno" id=line307></span>    x[sthename_pri] := <span class="fstring">"#?"</span> sinteger =&gt;# <span class="fstring">"`(PARSER_ARGUMENT ,_2)"</span>;
<span class="lineno" id=line308></span>  
<span class="lineno" id=line309></span>    x[sthename_pri] := squalified_name =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line310></span>  
<span class="lineno" id=line311></span>  
<span class="lineno" id=line312></span>    <span class="doccomment">Qualified name.</span>
<span class="lineno" id=line313></span>    sreally_qualified_name := squalified_name <span class="fstring">"::"</span> ssimple_name_parts =&gt;#
<span class="lineno" id=line314></span>      <span class="fstring">"`(ast_lookup (,_1 ,(first _3) ,(second _3)))"</span>;
<span class="lineno" id=line315></span>  
<span class="lineno" id=line316></span>    squalified_name := sreally_qualified_name =&gt;# <span class="fstring">'_1'</span>;
<span class="lineno" id=line317></span>  
<span class="lineno" id=line318></span>    squalified_name := ssimple_name_parts =&gt;#
<span class="lineno" id=line319></span>      <span class="fstring">"`(ast_name ,_sr ,(first _1) ,(second _1))"</span>;
<span class="lineno" id=line320></span>  
<span class="lineno" id=line321></span>    ssimple_name_parts := sname =&gt;# <span class="fstring">"`(,_1 ())"</span>;
<span class="lineno" id=line322></span>    ssimple_name_parts := sname <span class="fstring">"["</span> <span class="fstring">"]"</span> =&gt;# <span class="fstring">"`(,_1 ())"</span>;
<span class="lineno" id=line323></span>    ssimple_name_parts := sname <span class="fstring">"["</span> stypeexpr_comma_list <span class="fstring">"]"</span> =&gt;# <span class="fstring">"`(,_1 (texprs ,_3))"</span>;
<span class="lineno" id=line324></span>    ssimple_name_parts := sname <span class="fstring">"&lt;"</span> skindexpr_comma_list <span class="fstring">"&gt;"</span> =&gt;# <span class="fstring">"`(,_1 (kexprs ,_3))"</span>;
<span class="lineno" id=line325></span>  
<span class="lineno" id=line326></span>    <span class="doccomment">Suffixed name (to name functions).</span>
<span class="lineno" id=line327></span>    ssuffixed_name := squalified_name <span class="fstring">"of"</span> t[sthename_pri] =&gt;#
<span class="lineno" id=line328></span>      <span class="fstring">"`(ast_suffix (,_1 ,_3))"</span>;
<span class="lineno" id=line329></span>  
<span class="lineno" id=line330></span>  <span class="comment">//------------------------------------------------------------------------</span>
<span class="lineno" id=line331></span>    x[satomic_pri] := satom =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line332></span>    <span class="doccomment">record value (comma separated).</span>
<span class="lineno" id=line333></span>    satom := <span class="fstring">"("</span> rassign (<span class="fstring">","</span> rassign2 )* <span class="fstring">")"</span> =&gt;#
<span class="lineno" id=line334></span>      <span class="fstring">"`(ast_record ,_sr ,(cons _2 (map second _3)))"</span>
<span class="lineno" id=line335></span>    ;
<span class="lineno" id=line336></span>      rassign := sname <span class="fstring">"="</span> x[sor_condition_pri] =&gt;# <span class="fstring">"`(,_1 ,_3)"</span>;
<span class="lineno" id=line337></span>      rassign := <span class="fstring">"="</span> x[sor_condition_pri] =&gt;# <span class="fstring">'`("" ,_2)'</span>;
<span class="lineno" id=line338></span>      rassign2 := sname <span class="fstring">"="</span> x[sor_condition_pri] =&gt;# <span class="fstring">"`(,_1 ,_3)"</span>;
<span class="lineno" id=line339></span>      rassign2 := <span class="fstring">"="</span> x[sor_condition_pri] =&gt;# <span class="fstring">'`("" ,_2)'</span>;
<span class="lineno" id=line340></span>      rassign2 := x[sor_condition_pri] =&gt;# <span class="fstring">'`("" ,_1)'</span>;
<span class="lineno" id=line341></span>  
<span class="lineno" id=line342></span>    <span class="doccomment">polyrecord value</span>
<span class="lineno" id=line343></span>    <span class="doccomment">record value (comma separated).</span>
<span class="lineno" id=line344></span>    satom := <span class="fstring">"("</span> rassign (<span class="fstring">","</span> rassign2 )* <span class="fstring">"|"</span> sexpr <span class="fstring">")"</span> =&gt;#
<span class="lineno" id=line345></span>      <span class="fstring">"`(ast_polyrecord ,_sr ,(cons _2 (map second _3)) ,_5)"</span>
<span class="lineno" id=line346></span>    ;
<span class="lineno" id=line347></span>  
<span class="lineno" id=line348></span>    satom := <span class="fstring">"("</span> sexpr <span class="fstring">"without"</span> sname+ <span class="fstring">")"</span> =&gt;#
<span class="lineno" id=line349></span>      <span class="fstring">"`(ast_remove_fields ,_sr ,_2 ,_4)"</span>
<span class="lineno" id=line350></span>    ;
<span class="lineno" id=line351></span>  
<span class="lineno" id=line352></span>    satom := <span class="fstring">"("</span> sexpr <span class="fstring">"getall"</span> sname <span class="fstring">")"</span> =&gt;#
<span class="lineno" id=line353></span>      <span class="fstring">"`(ast_getall_field ,_sr ,_2 ,_4)"</span>
<span class="lineno" id=line354></span>    ;
<span class="lineno" id=line355></span>  
<span class="lineno" id=line356></span>    satom := <span class="fstring">"("</span> sexpr <span class="fstring">"with"</span> rassign (<span class="fstring">","</span> rassign2 )* <span class="fstring">")"</span> =&gt;#
<span class="lineno" id=line357></span>      <span class="fstring">"`(ast_replace_fields ,_sr ,_2 ,(cons _4 (map second _5)))"</span>
<span class="lineno" id=line358></span>    ;
<span class="lineno" id=line359></span>  
<span class="lineno" id=line360></span>  
<span class="lineno" id=line361></span>    <span class="doccomment">record value, statement list.</span>
<span class="lineno" id=line362></span>    <span class="doccomment">this variant is useful for encapsulating</span>
<span class="lineno" id=line363></span>    <span class="doccomment">a series of var x = y; style statements.</span>
<span class="lineno" id=line364></span>    satom := <span class="fstring">"struct"</span> <span class="fstring">"{"</span> vassign+ <span class="fstring">"}"</span> =&gt;#
<span class="lineno" id=line365></span>      <span class="fstring">"`(ast_record ,_sr ,_3 )"</span>
<span class="lineno" id=line366></span>    ;
<span class="lineno" id=line367></span>      vassign := <span class="fstring">"var"</span> sname <span class="fstring">"="</span> sexpr <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(,_2 ,_4)"</span>;
<span class="lineno" id=line368></span>  
<span class="lineno" id=line369></span>    <span class="doccomment">scalar literals (numbers, strings).</span>
<span class="lineno" id=line370></span>    satom := sliteral =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line371></span>  
<span class="lineno" id=line372></span>    <span class="doccomment">Wildcard pattern.</span>
<span class="lineno" id=line373></span>    satom := _ =&gt;# <span class="fstring">"`(ast_patany ,_sr)"</span>;
<span class="lineno" id=line374></span>  
<span class="lineno" id=line375></span>    <span class="doccomment">Callback expression.</span>
<span class="lineno" id=line376></span>    satom := <span class="fstring">"callback"</span> <span class="fstring">"["</span> sexpr <span class="fstring">"]"</span> =&gt;# <span class="fstring">"`(ast_callback ,_sr ,_3)"</span>;
<span class="lineno" id=line377></span>  
<span class="lineno" id=line378></span>    <span class="doccomment">Short form anonymous procedure closure.</span>
<span class="lineno" id=line379></span>    satom := scompound =&gt;# <span class="fstring">"(lazy _1)"</span>;
<span class="lineno" id=line380></span>  
<span class="lineno" id=line381></span>    <span class="doccomment">Short form sequence operator.</span>
<span class="lineno" id=line382></span>    <span class="doccomment">( stmt; expr ) means the same as #{stmt; return expr; }</span>
<span class="lineno" id=line383></span>    satom := <span class="fstring">"("</span> stmt+ sexpr <span class="fstring">")"</span> =&gt;#
<span class="lineno" id=line384></span>      <span class="fstring">"""
<span class="lineno" id=line385></span>      (
<span class="lineno" id=line386></span>        let* 
<span class="lineno" id=line387></span>        (
<span class="lineno" id=line388></span>          (stmts _2)
<span class="lineno" id=line389></span>          (expr _3)
<span class="lineno" id=line390></span>          (retexp `(ast_fun_return ,_sr ,expr))
<span class="lineno" id=line391></span>          (nustmts (append stmts (list retexp)))
<span class="lineno" id=line392></span>        )
<span class="lineno" id=line393></span>        (block_expr nustmts)
<span class="lineno" id=line394></span>      )
<span class="lineno" id=line395></span>      """</span> 
<span class="lineno" id=line396></span>    ;
<span class="lineno" id=line397></span>  
<span class="lineno" id=line398></span>    <span class="doccomment">special anonymous variable forces eager eval.</span>
<span class="lineno" id=line399></span>    satom := <span class="fstring">"("</span> <span class="fstring">"var"</span> sexpr <span class="fstring">")"</span> =&gt;# 
<span class="lineno" id=line400></span>      <span class="fstring">"""
<span class="lineno" id=line401></span>      (
<span class="lineno" id=line402></span>        let
<span class="lineno" id=line403></span>        (
<span class="lineno" id=line404></span>          (name (fresh_name "asvar"))
<span class="lineno" id=line405></span>        )
<span class="lineno" id=line406></span>        `(ast_as_var ,_sr (,_3 ,name))
<span class="lineno" id=line407></span>      )
<span class="lineno" id=line408></span>      """</span>
<span class="lineno" id=line409></span>    ;
<span class="lineno" id=line410></span>  
<span class="lineno" id=line411></span>    <span class="doccomment">inline scheme</span>
<span class="lineno" id=line412></span>    satom := <span class="fstring">"schemelex"</span> sstring =&gt;# <span class="fstring">"(schemelex _2)"</span>;
<span class="lineno" id=line413></span>    satom := <span class="fstring">"schemerun"</span> sstring =&gt;# <span class="fstring">"(schemerun _2)"</span>;
<span class="lineno" id=line414></span>    <span class="doccomment">Empty tuple (unit tuple).</span>
<span class="lineno" id=line415></span>    satom := <span class="fstring">"("</span> <span class="fstring">")"</span> =&gt;# <span class="fstring">"'()"</span>;
<span class="lineno" id=line416></span>  
<span class="lineno" id=line417></span>    <span class="doccomment">Object extension.</span>
<span class="lineno" id=line418></span>    expr_comma_list := <span class="library" title="functional, singly linked list">list</span>::commalist1&lt;x[scomparison_pri]&gt; =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line419></span>    satom := <span class="fstring">"extend"</span> expr_comma_list <span class="fstring">"with"</span> sexpr <span class="fstring">"end"</span> =&gt;# <span class="fstring">"""
<span class="lineno" id=line420></span>      `(ast_extension ,_sr ,_2 ,_4)
<span class="lineno" id=line421></span>    """</span>;
<span class="lineno" id=line422></span>  
<span class="lineno" id=line423></span>      setbar := <span class="fstring">"|"</span> =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line424></span>      setbar := <span class="fstring">"\|"</span> =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line425></span>      setbar := <span class="fstring">"\mid"</span> =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line426></span>  
<span class="lineno" id=line427></span>    setform := spattern <span class="fstring">":"</span> stypeexpr setbar sexpr =&gt;#
<span class="lineno" id=line428></span>      <span class="fstring">"""
<span class="lineno" id=line429></span>      (let* 
<span class="lineno" id=line430></span>        (
<span class="lineno" id=line431></span>           (argt _3)
<span class="lineno" id=line432></span>           (ret (nos "bool"))
<span class="lineno" id=line433></span>           (matchings `((,_1 ,_5)((pat_setform_any ,_sr)(ast_false ,_sr))))
<span class="lineno" id=line434></span>           (body `((ast_fun_return ,_sr (ast_match ,_sr (,(noi '_a) ,matchings)))))
<span class="lineno" id=line435></span>           (param `(,_sr PVal _a ,argt none)) ;; one parameter
<span class="lineno" id=line436></span>           (params `( Satom ,param ))            ;; parameter tuple list
<span class="lineno" id=line437></span>           (paramsx `(,params none))     ;; parameter tuple list with precondition
<span class="lineno" id=line438></span>           (paramsxs `(,paramsx))        ;; curry parameters 
<span class="lineno" id=line439></span>           (method `(ast_curry ,_sr "has_elt"  ,dfltvs ,paramsxs (,ret none) Method () ,body))
<span class="lineno" id=line440></span>           (objsts `(,method))
<span class="lineno" id=line441></span>           (object `(ast_object ,_sr (,dfltvs ,dfltparams typ_none ,objsts))) 
<span class="lineno" id=line442></span>        )
<span class="lineno" id=line443></span>        `(ast_apply ,_sr (,object (ast_tuple ,_sr ())))
<span class="lineno" id=line444></span>      )
<span class="lineno" id=line445></span>      """</span>;
<span class="lineno" id=line446></span>  
<span class="lineno" id=line447></span>    satom := <span class="fstring">"{"</span> setform  <span class="fstring">"}"</span> =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line448></span>    satom := <span class="fstring">"\{"</span> setform  <span class="fstring">"\}"</span> =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line449></span>  
<span class="lineno" id=line450></span>    satom := <span class="fstring">"@("</span> sexpr <span class="fstring">")"</span> =&gt;# 
<span class="lineno" id=line451></span>      <span class="fstring">"""
<span class="lineno" id=line452></span>        `(ast_apply ,_sr (,(nos "objc_box") ,_2))
<span class="lineno" id=line453></span>      """</span>
<span class="lineno" id=line454></span>    ; 
<span class="lineno" id=line455></span>  
<span class="lineno" id=line456></span>  
<span class="lineno" id=line457></span>  }
<span class="lineno" id=line458></span>  
</pre></p></div></div><h1 id='Grammar_Base_h'><img src='/share/src/web/images/minus.gif' id='Grammar Base' onclick='toggle(this,"Grammar_Base_d")' alt='+'/> 2 Grammar Base</h1><div id='Grammar_Base_d' style='display:block'>
<h2 id='Assertions_h'><img src='/share/src/web/images/minus.gif' id='Assertions' onclick='toggle(this,"Assertions_d")' alt='+'/> 2.1 Assertions</h2><div id='Assertions_d' style='display:block'>
<pre class='inclusion'>
share/lib/grammar/assertions.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">Assertion statements.</span>
<span class="lineno" id=line2></span>  <span class="doccomment">See also functions to find pre- and post-conditions.</span>
<span class="lineno" id=line3></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> assertions {
<span class="lineno" id=line4></span>    <span class="big_keyword" title="specify requirements">requires</span> statements;
<span class="lineno" id=line5></span>  
<span class="lineno" id=line6></span>    stmt = assertion_stmt;
<span class="lineno" id=line7></span>  
<span class="lineno" id=line8></span>    <span class="doccomment">The usual assert statement.</span>
<span class="lineno" id=line9></span>    <span class="doccomment">Abort the program if the argument expression evaluates to false</span>
<span class="lineno" id=line10></span>    <span class="doccomment">when control flows through the assert statement.</span>
<span class="lineno" id=line11></span>    <span class="doccomment">Cannot be switched off!</span>
<span class="lineno" id=line12></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> assertion_stmt := <span class="fstring">"assert"</span> sexpr <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_assert ,_sr ,_2)"</span>;
<span class="lineno" id=line13></span>  
<span class="lineno" id=line14></span>    <span class="doccomment">Static assert: type expression of kind BOOL required</span>
<span class="lineno" id=line15></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> assertion_stmt := <span class="fstring">"static-assert"</span> stype <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_static_assert ,_sr ,_2)"</span>;
<span class="lineno" id=line16></span>  
<span class="lineno" id=line17></span>    <span class="doccomment">Define an axiom with a general predicate.</span>
<span class="lineno" id=line18></span>    <span class="doccomment">An axiom is a function which is true for all arguments.</span>
<span class="lineno" id=line19></span>    <span class="doccomment">Axioms are core assertions about invariants which</span>
<span class="lineno" id=line20></span>    <span class="doccomment">can be used to specify semantics and form the basis</span>
<span class="lineno" id=line21></span>    <span class="doccomment">of reasoning about semantics which goes beyond</span>
<span class="lineno" id=line22></span>    <span class="doccomment">structure.</span>
<span class="lineno" id=line23></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> assertion_stmt  := <span class="fstring">"axiom"</span> sdeclname sfun_arg <span class="fstring">":"</span> sexpr <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line24></span>      <span class="fstring">"""
<span class="lineno" id=line25></span>        `(ast_axiom ,_sr ,(first _2) ,(second _2) ,_3 (Predicate ,_5))
<span class="lineno" id=line26></span>      """</span>;
<span class="lineno" id=line27></span>  
<span class="lineno" id=line28></span>    <span class="doccomment">A variant of an axiom which expresses the semantic</span>
<span class="lineno" id=line29></span>    <span class="doccomment">equality of two expressions. Do not confuse this</span>
<span class="lineno" id=line30></span>    <span class="doccomment">with an expresion containing run time equality (==).</span>
<span class="lineno" id=line31></span>    <span class="doccomment">Semantic equality means that one expression could be</span>
<span class="lineno" id=line32></span>    <span class="doccomment">replaced by the other without any observable difference</span>
<span class="lineno" id=line33></span>    <span class="doccomment">in behaviour in any program, this can be asserted even</span>
<span class="lineno" id=line34></span>    <span class="doccomment">if the type does not provide an equality operator (==).</span>
<span class="lineno" id=line35></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> assertion_stmt  := <span class="fstring">"axiom"</span> sdeclname sfun_arg <span class="fstring">":"</span> sexpr <span class="fstring">"="</span> sexpr <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line36></span>      <span class="fstring">"""
<span class="lineno" id=line37></span>        `(ast_axiom ,_sr ,(first _2) ,(second _2) ,_3 (Equation (,_5 ,_7)))
<span class="lineno" id=line38></span>      """</span>;
<span class="lineno" id=line39></span>  
<span class="lineno" id=line40></span>    <span class="doccomment">A lemma is a proposition which it is expected could</span>
<span class="lineno" id=line41></span>    <span class="doccomment">be proved by a good automatic theorem prover,</span>
<span class="lineno" id=line42></span>    <span class="doccomment">given the axioms. This is the predicate form.</span>
<span class="lineno" id=line43></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> assertion_stmt  := <span class="fstring">"lemma"</span> sdeclname sfun_arg <span class="fstring">":"</span> sexpr <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line44></span>      <span class="fstring">"""
<span class="lineno" id=line45></span>        `(ast_lemma ,_sr ,(first _2) ,(second _2) ,_3 (Predicate ,_5))
<span class="lineno" id=line46></span>      """</span>;
<span class="lineno" id=line47></span>  
<span class="lineno" id=line48></span>    <span class="doccomment">A lemma is a proposition which it is expected could</span>
<span class="lineno" id=line49></span>    <span class="doccomment">be proved by a good automatic theorem prover,</span>
<span class="lineno" id=line50></span>    <span class="doccomment">given the axioms. This is the equational form.</span>
<span class="lineno" id=line51></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> assertion_stmt  := <span class="fstring">"lemma"</span> sdeclname sfun_arg <span class="fstring">":"</span> sexpr <span class="fstring">"="</span> sexpr <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line52></span>      <span class="fstring">"""
<span class="lineno" id=line53></span>        `(ast_lemma ,_sr ,(first _2) ,(second _2) ,_3 (Equation (,_5 ,_7)))
<span class="lineno" id=line54></span>      """</span>;
<span class="lineno" id=line55></span>  
<span class="lineno" id=line56></span>    <span class="doccomment">A theorem is a proposition which it is expected could</span>
<span class="lineno" id=line57></span>    <span class="doccomment">NOT be proved by a good automatic theorem prover,</span>
<span class="lineno" id=line58></span>    <span class="doccomment">given the axioms.  In the future, we might like to</span>
<span class="lineno" id=line59></span>    <span class="doccomment">provide a "proof sketch" which a suitable tool could</span>
<span class="lineno" id=line60></span>    <span class="doccomment">fill in. For the present, you can give a proof as </span>
<span class="lineno" id=line61></span>    <span class="doccomment">plain text in a string as a hint to the reader.</span>
<span class="lineno" id=line62></span>    <span class="doccomment">  //$ This is the predicative form.</span>
<span class="lineno" id=line63></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> assertion_stmt  := <span class="fstring">"theorem"</span> sdeclname sfun_arg <span class="fstring">":"</span> sexpr proof? <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line64></span>      <span class="fstring">"""
<span class="lineno" id=line65></span>        `(ast_axiom ,_sr ,(first _2) ,(second _2) ,_3 (Predicate ,_5))
<span class="lineno" id=line66></span>      """</span>;
<span class="lineno" id=line67></span>      proof := <span class="fstring">"proof"</span> sstring;
<span class="lineno" id=line68></span>  
<span class="lineno" id=line69></span>    <span class="doccomment">A theorem is a proposition which it is expected could</span>
<span class="lineno" id=line70></span>    <span class="doccomment">NOT be proved by a good automatic theorem prover,</span>
<span class="lineno" id=line71></span>    <span class="doccomment">given the axioms.  In the future, we might like to</span>
<span class="lineno" id=line72></span>    <span class="doccomment">provide a "proof sketch" which a suitable tool could</span>
<span class="lineno" id=line73></span>    <span class="doccomment">fill in. For the present, you can give a proof as </span>
<span class="lineno" id=line74></span>    <span class="doccomment">plain text in a string as a hint to the reader.</span>
<span class="lineno" id=line75></span>    <span class="doccomment">  //$ This is the equational form.</span>
<span class="lineno" id=line76></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> assertion_stmt  := <span class="fstring">"theorem"</span> sdeclname sfun_arg <span class="fstring">":"</span> sexpr <span class="fstring">"="</span> sexpr proof? <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line77></span>      <span class="fstring">"""
<span class="lineno" id=line78></span>        `(ast_axiom ,_sr ,(first _2) ,(second _2) ,_3 (Equation (,_5 ,_7)))
<span class="lineno" id=line79></span>      """</span>;
<span class="lineno" id=line80></span>  
<span class="lineno" id=line81></span>    <span class="doccomment">A reduction is a special kind of proposition of equational</span>
<span class="lineno" id=line82></span>    <span class="doccomment">form which also directs the compiler to actually replace</span>
<span class="lineno" id=line83></span>    <span class="doccomment">the LHS expression with the RHS expression when found.</span>
<span class="lineno" id=line84></span>    <span class="doccomment">  //$ Reductions allow powerful high level optimisations,</span>
<span class="lineno" id=line85></span>    <span class="doccomment">such as eliminating two successive list reversals.</span>
<span class="lineno" id=line86></span>    <span class="doccomment">  //$ The client must take great care that reductions don't</span>
<span class="lineno" id=line87></span>    <span class="doccomment">lead to infinite loops. Confluence isn't required but</span>
<span class="lineno" id=line88></span>    <span class="doccomment">is probably desirable.</span>
<span class="lineno" id=line89></span>    <span class="doccomment">  //$ Reductions should be used sparingly because searching</span>
<span class="lineno" id=line90></span>    <span class="doccomment">for patterns to reduce is applied to every sub-expression</span>
<span class="lineno" id=line91></span>    <span class="doccomment">of every expression in the whole program, repeatedly</span>
<span class="lineno" id=line92></span>    <span class="doccomment">after any reduction is applied, and this whole process</span>
<span class="lineno" id=line93></span>    <span class="doccomment">is done at several different places in the program,</span>
<span class="lineno" id=line94></span>    <span class="doccomment">to try to effect the reductions. Particularly both</span>
<span class="lineno" id=line95></span>    <span class="doccomment">before and after inlining, since that can destroy</span>
<span class="lineno" id=line96></span>    <span class="doccomment">or create candidate patterns.</span>
<span class="lineno" id=line97></span>  
<span class="lineno" id=line98></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> assertion_stmt  := <span class="fstring">"reduce"</span> sname <span class="fstring">"|"</span>? sreductions <span class="fstring">";"</span>  =&gt;#
<span class="lineno" id=line99></span>      <span class="fstring">"""
<span class="lineno" id=line100></span>        `(ast_reduce ,_sr ,_2 ,_4)
<span class="lineno" id=line101></span>      """</span>;
<span class="lineno" id=line102></span>  
<span class="lineno" id=line103></span>       <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sreduce_args := <span class="fstring">"("</span> stypeparameter_comma_list <span class="fstring">")"</span> =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line104></span>       <span class="comment">//private sreduction := stvarlist sreduce_args ":" sexpr "=&gt;" sexpr =&gt;# "`(,_1 ,_2 ,_4 ,_6)";</span>
<span class="lineno" id=line105></span>       <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sreduction := stvarlist sreduce_args <span class="fstring">":"</span> sexpr <span class="fstring">"=&gt;"</span> sexpr =&gt;# <span class="fstring">"`(,_1 ,_2 ,_4 ,_6)"</span>;
<span class="lineno" id=line106></span>       <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sreductions := sreduction =&gt;# <span class="fstring">"`(,_1)"</span>;
<span class="lineno" id=line107></span>       <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sreductions := sreduction <span class="fstring">"|"</span> sreductions =&gt;# <span class="fstring">"(cons _1 _3)"</span>;  
<span class="lineno" id=line108></span>  }
<span class="lineno" id=line109></span>  
</pre></p></div><h2 id='Assignments_h'><img src='/share/src/web/images/minus.gif' id='Assignments' onclick='toggle(this,"Assignments_d")' alt='+'/> 2.2 Assignments</h2><div id='Assignments_d' style='display:block'>
<p>Defines assignment forms.
</p><pre class='inclusion'>
share/lib/grammar/assignment.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">Assignment forms.</span>
<span class="lineno" id=line2></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> assignment {
<span class="lineno" id=line3></span>    <span class="big_keyword" title="specify requirements">requires</span> statements, swapop;
<span class="lineno" id=line4></span>  
<span class="lineno" id=line5></span>    <span class="doccomment">Assignment form.</span>
<span class="lineno" id=line6></span>    sassignexpr := sexpr sassignop sexpr =&gt;# <span class="fstring">"`(ast_assign ,_sr ,_2 ((Expr ,_sr ,_1) none) ,_3)"</span>;
<span class="lineno" id=line7></span>  
<span class="lineno" id=line8></span>    <span class="doccomment">Assignment.</span>
<span class="lineno" id=line9></span>      sassignop:= <span class="fstring">"="</span> =&gt;# <span class="fstring">"'_set"</span>;
<span class="lineno" id=line10></span>  
<span class="lineno" id=line11></span>    <span class="doccomment">Store at pointer.</span>
<span class="lineno" id=line12></span>      <span class="comment">//sassignop:= "&lt;-" =&gt;# "'_pset";</span>
<span class="lineno" id=line13></span>      sassignop:= <span class="fstring">"&lt;-"</span> =&gt;# <span class="fstring">"'storeat"</span>; <span class="comment">// overloadable now</span>
<span class="lineno" id=line14></span>  
<span class="lineno" id=line15></span>    <span class="doccomment">Short form val declaration.</span>
<span class="lineno" id=line16></span>      sassignop:= <span class="fstring">":="</span> =&gt;# <span class="fstring">"'_init"</span>;
<span class="lineno" id=line17></span>  
<span class="lineno" id=line18></span>    <span class="doccomment">binary read-modify-write operators.</span>
<span class="lineno" id=line19></span>    sassignexpr := sexpr srmwop sexpr =&gt;# <span class="fstring">"`(ast_assign ,_sr ,_2 ((Expr ,_sr ,_1) none) ,_3)"</span>;
<span class="lineno" id=line20></span>  
<span class="lineno" id=line21></span>      <span class="doccomment">Increment.</span>
<span class="lineno" id=line22></span>      srmwop:= <span class="fstring">"+="</span> =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line23></span>      <span class="doccomment">Decrement.</span>
<span class="lineno" id=line24></span>      srmwop:= <span class="fstring">"-="</span> =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line25></span>      <span class="doccomment">Multiply.</span>
<span class="lineno" id=line26></span>      srmwop:= <span class="fstring">"*="</span> =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line27></span>      <span class="doccomment">Divide.</span>
<span class="lineno" id=line28></span>      srmwop:= <span class="fstring">"/="</span> =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line29></span>      <span class="doccomment">C remainder.</span>
<span class="lineno" id=line30></span>      srmwop:= <span class="fstring">"%="</span> =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line31></span>      <span class="doccomment">Left shift.</span>
<span class="lineno" id=line32></span>      srmwop:= <span class="fstring">"&lt;&lt;="</span> =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line33></span>      <span class="doccomment">Right shift.</span>
<span class="lineno" id=line34></span>      srmwop:= <span class="fstring">"&gt;&gt;="</span> =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line35></span>      <span class="doccomment">Bitwise exclusive or.</span>
<span class="lineno" id=line36></span>      srmwop:= <span class="fstring">"^="</span> =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line37></span>      <span class="doccomment">Bitwise or.</span>
<span class="lineno" id=line38></span>      srmwop:= <span class="fstring">"|="</span> =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line39></span>      <span class="doccomment">Bitwise and.</span>
<span class="lineno" id=line40></span>      srmwop:= <span class="fstring">"&amp;="</span> =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line41></span>      <span class="doccomment">Left shift.</span>
<span class="lineno" id=line42></span>      srmwop:= <span class="fstring">"&lt;&lt;="</span> =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line43></span>      <span class="doccomment">Right shift.</span>
<span class="lineno" id=line44></span>      srmwop:= <span class="fstring">"&gt;&gt;="</span> =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line45></span>  
<span class="lineno" id=line46></span>    <span class="doccomment">Swap operator.</span>
<span class="lineno" id=line47></span>    sassignexpr := sexpr sswapop sexpr =&gt;# <span class="fstring">"`(ast_call ,_sr ,(noi _2) ((ast_ref ,_sr ,_1) (ast_ref ,_sr ,_3)))"</span>;
<span class="lineno" id=line48></span>  
<span class="lineno" id=line49></span>    <span class="doccomment">Prefix read/modify/write.</span>
<span class="lineno" id=line50></span>    sassignexpr := spreincrop sexpr =&gt;# <span class="fstring">"`(ast_call ,_sr ,(noi _1) (ast_ref ,_sr ,_2))"</span>;
<span class="lineno" id=line51></span>      <span class="doccomment">Pre-increment.</span>
<span class="lineno" id=line52></span>      spreincrop:= <span class="fstring">"++"</span> =&gt;# <span class="fstring">"'pre_incr"</span>;
<span class="lineno" id=line53></span>      <span class="doccomment">Pre-decrement.</span>
<span class="lineno" id=line54></span>      spreincrop:= <span class="fstring">"--"</span> =&gt;# <span class="fstring">"'pre_decr"</span>;
<span class="lineno" id=line55></span>  
<span class="lineno" id=line56></span>    <span class="doccomment">Postfix read/modify/write.</span>
<span class="lineno" id=line57></span>    sassignexpr := sexpr spostincrop =&gt;# <span class="fstring">"`(ast_call ,_sr ,(noi _2) (ast_ref ,_sr ,_1))"</span>;
<span class="lineno" id=line58></span>      <span class="doccomment">Post-increment.</span>
<span class="lineno" id=line59></span>      spostincrop:= <span class="fstring">"++"</span> =&gt;# <span class="fstring">"'post_incr"</span>;
<span class="lineno" id=line60></span>      <span class="doccomment">Post-decrement.</span>
<span class="lineno" id=line61></span>      spostincrop:= <span class="fstring">"--"</span> =&gt;# <span class="fstring">"'post_decr"</span>;
<span class="lineno" id=line62></span>  
<span class="lineno" id=line63></span>    <span class="doccomment">Multiple initialisation/assignment form.</span>
<span class="lineno" id=line64></span>    <span class="doccomment">  //$ def x, (var y, val z) = 1,(2,3);</span>
<span class="lineno" id=line65></span>    <span class="doccomment">  //$ allows unpacking a tuple into a pre-existing variable,</span>
<span class="lineno" id=line66></span>    <span class="doccomment">creating a new variable, and binding a new value,</span>
<span class="lineno" id=line67></span>    <span class="doccomment">in a single form, with nesting.</span>
<span class="lineno" id=line68></span>    sassignexpr := <span class="fstring">"def"</span> slexpr <span class="fstring">"="</span> sexpr =&gt;# <span class="fstring">"`(ast_assign ,_sr _set ,_2 ,_4)"</span>;
<span class="lineno" id=line69></span>      slexpr := slexprs =&gt;# <span class="fstring">""" (if (null? (tail _1)) (first _1) `((List ,_1) none)) """</span>;
<span class="lineno" id=line70></span>      slexprs := stlelement <span class="fstring">","</span> slexprs =&gt;# <span class="fstring">"(cons _1 _3)"</span>;
<span class="lineno" id=line71></span>      slexprs := stlelement =&gt;# <span class="fstring">"`(,_1)"</span>;
<span class="lineno" id=line72></span>  
<span class="lineno" id=line73></span>      slelement := <span class="fstring">"val"</span> sname =&gt;# <span class="fstring">"`(Val ,_sr ,_2)"</span>;
<span class="lineno" id=line74></span>      slelement := <span class="fstring">"var"</span> sname =&gt;# <span class="fstring">"`(Var ,_sr ,_2)"</span>;
<span class="lineno" id=line75></span>      slelement := sname =&gt;# <span class="fstring">"`(Name ,_sr ,_1)"</span>;
<span class="lineno" id=line76></span>      slelement := <span class="fstring">"_"</span> =&gt;# <span class="fstring">"`(Skip ,_sr)"</span>;
<span class="lineno" id=line77></span>      slelement := <span class="fstring">"("</span> slexprs <span class="fstring">")"</span> =&gt;# <span class="fstring">"`(List ,_2)"</span>;
<span class="lineno" id=line78></span>  
<span class="lineno" id=line79></span>      stlelement := slelement <span class="fstring">":"</span> x[sfactor_pri] =&gt;# <span class="fstring">"`(,_1 (some ,_3))"</span>;
<span class="lineno" id=line80></span>      stlelement := slelement =&gt;# <span class="fstring">"`(,_1 none)"</span>;
<span class="lineno" id=line81></span>  
<span class="lineno" id=line82></span>  }
<span class="lineno" id=line83></span>  
</pre></p></div><h2 id='Block_forms_h'><img src='/share/src/web/images/minus.gif' id='Block forms' onclick='toggle(this,"Block_forms_d")' alt='+'/> 2.3 Block forms</h2><div id='Block_forms_d' style='display:block'>
<pre class='inclusion'>
share/lib/grammar/blocks.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> blocks
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    stmt = block;
<span class="lineno" id=line4></span>    block := <span class="fstring">"do"</span> stmt* <span class="fstring">"done"</span> =&gt;# <span class="fstring">'`(ast_seq ,_sr ,_2)'</span>;
<span class="lineno" id=line5></span>    block := <span class="fstring">"begin"</span> stmt* <span class="fstring">"end"</span> =&gt;# <span class="fstring">'(block_stmts _2)'</span>;
<span class="lineno" id=line6></span>    block := <span class="fstring">"perform"</span> stmt =&gt;# <span class="fstring">'_2'</span>;
<span class="lineno" id=line7></span>  }
<span class="lineno" id=line8></span>  
</pre></p></div><h2 id='Bracket_Forms_h'><img src='/share/src/web/images/minus.gif' id='Bracket Forms' onclick='toggle(this,"Bracket_Forms_d")' alt='+'/> 2.4 Bracket Forms</h2><div id='Bracket_Forms_d' style='display:block'>
<pre class='inclusion'>
share/lib/grammar/brackets.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> brackets 
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    <span class="doccomment">Array expression (deprecated).</span>
<span class="lineno" id=line4></span>    satom := <span class="fstring">"[|"</span> sexpr <span class="fstring">"|]"</span> =&gt;# <span class="fstring">"`(ast_arrayof ,_sr ,(mkexlist _2))"</span>;
<span class="lineno" id=line5></span>  
<span class="lineno" id=line6></span>    <span class="doccomment">Short form anonymous function closure.</span>
<span class="lineno" id=line7></span>    satom := <span class="fstring">"{"</span> sexpr <span class="fstring">"}"</span> =&gt;# <span class="fstring">"(lazy `((ast_fun_return ,_sr ,_2)))"</span>;
<span class="lineno" id=line8></span>  
<span class="lineno" id=line9></span>    <span class="doccomment">Grouping.</span>
<span class="lineno" id=line10></span>    satom := <span class="fstring">"("</span> sexpr <span class="fstring">")"</span> =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line11></span>    satom := <span class="fstring">"\("</span> sexpr <span class="fstring">"\)"</span> =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line12></span>    satom := <span class="fstring">"\["</span> sexpr <span class="fstring">"\]"</span> =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line13></span>    satom := <span class="fstring">"\{"</span> sexpr <span class="fstring">"\}"</span> =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line14></span>  
<span class="lineno" id=line15></span>    <span class="doccomment">floor and ceiling</span>
<span class="lineno" id=line16></span>    satom := <span class="fstring">"\lceil"</span> sexpr <span class="fstring">"\rceil"</span> =&gt;# <span class="fstring">"`(ast_apply ,_sr (,(noi 'ceil) (,_2)))"</span>;
<span class="lineno" id=line17></span>    satom := <span class="fstring">"\lfloor"</span> sexpr <span class="fstring">"\rfloor"</span> =&gt;# <span class="fstring">"`(ast_apply ,_sr (,(noi 'floor) (,_2)))"</span>;
<span class="lineno" id=line18></span>  
<span class="lineno" id=line19></span>    <span class="doccomment">absolute value</span>
<span class="lineno" id=line20></span>    satom := <span class="fstring">"\lvert"</span> sexpr <span class="fstring">"\rvert"</span> =&gt;# <span class="fstring">"`(ast_apply ,_sr (,(noi 'abs) (,_2)))"</span>;
<span class="lineno" id=line21></span>    satom := <span class="fstring">"\left"</span> <span class="fstring">"|"</span> sexpr <span class="fstring">"\right"</span> <span class="fstring">"|"</span> =&gt;# <span class="fstring">"`(ast_apply ,_sr (,(noi 'abs) (,_3)))"</span>;
<span class="lineno" id=line22></span>    satom := <span class="fstring">"\left"</span> <span class="fstring">"\vert"</span> sexpr <span class="fstring">"\right"</span> <span class="fstring">"\vert"</span> =&gt;# <span class="fstring">"`(ast_apply ,_sr (,(noi 'abs) (,_3)))"</span>;
<span class="lineno" id=line23></span>  
<span class="lineno" id=line24></span>    <span class="doccomment">norm or length</span>
<span class="lineno" id=line25></span>    satom := <span class="fstring">"\lVert"</span> sexpr <span class="fstring">"\rVert"</span> =&gt;# <span class="fstring">"`(ast_apply ,_sr (,(noi 'len) (,_2)))"</span>;
<span class="lineno" id=line26></span>    satom := <span class="fstring">"\left"</span> <span class="fstring">"\Vert"</span> sexpr <span class="fstring">"\right"</span> <span class="fstring">"\Vert"</span> =&gt;# <span class="fstring">"`(ast_apply ,_sr (,(noi 'len) (,_3)))"</span>;
<span class="lineno" id=line27></span>  
<span class="lineno" id=line28></span>    <span class="comment">// mediating morphism of a product &lt;f,g&gt;</span>
<span class="lineno" id=line29></span>    satom := <span class="fstring">"\langle"</span> sexpr <span class="fstring">"\rangle"</span> =&gt;# <span class="fstring">"`(ast_apply ,_sr (,(noi 'lrangle) (,_2)))"</span>;
<span class="lineno" id=line30></span>    satom := <span class="fstring">"\left"</span> <span class="fstring">"\langle"</span> sexpr <span class="fstring">"\right"</span> <span class="fstring">"\rangle"</span> =&gt;# <span class="fstring">"`(ast_apply ,_sr (,(noi 'lrangle) (,_3)))"</span>;
<span class="lineno" id=line31></span>  
<span class="lineno" id=line32></span>    <span class="comment">// mediating morphism of a sum [f,g]</span>
<span class="lineno" id=line33></span>    satom := <span class="fstring">"\lbrack"</span> sexpr <span class="fstring">"\rbrack"</span> =&gt;# <span class="fstring">"`(ast_apply ,_sr (,(noi 'lrbrack) (,_2)))"</span>;
<span class="lineno" id=line34></span>    satom := <span class="fstring">"\left"</span> <span class="fstring">"\lbrack"</span> sexpr <span class="fstring">"\right"</span> <span class="fstring">"\rbrack"</span> =&gt;# <span class="fstring">"`(ast_apply ,_sr (,(noi 'lrbrack) (,_3)))"</span>;
<span class="lineno" id=line35></span>   
<span class="lineno" id=line36></span>   
<span class="lineno" id=line37></span>  }
<span class="lineno" id=line38></span>  
</pre></p></div><h2 id='C_binding_technology_h'><img src='/share/src/web/images/minus.gif' id='C binding technology' onclick='toggle(this,"C_binding_technology_d")' alt='+'/> 2.5 C binding technology</h2><div id='C_binding_technology_d' style='display:block'>
<pre class='inclusion'>
share/lib/grammar/cbind.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">Technology for binding to C.</span>
<span class="lineno" id=line2></span>  <span class="doccomment">The forms in this DSSL are used to lift types and functions </span>
<span class="lineno" id=line3></span>  <span class="doccomment">from C into Felix, and, export Felix types and functions</span>
<span class="lineno" id=line4></span>  <span class="doccomment">back into C.</span>
<span class="lineno" id=line5></span>  
<span class="lineno" id=line6></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> cbind {
<span class="lineno" id=line7></span>    <span class="big_keyword" title="specify requirements">requires</span> expressions, statements, requirements, <span class="library" title="functional, singly linked list">list</span>;
<span class="lineno" id=line8></span>  
<span class="lineno" id=line9></span>    stmt = cbind_stmt;
<span class="lineno" id=line10></span>  
<span class="lineno" id=line11></span>    <span class="doccomment">Export a Felix function into C.</span>
<span class="lineno" id=line12></span>    <span class="doccomment">The function is exported by generating a C wrapper function</span>
<span class="lineno" id=line13></span>    <span class="doccomment">which has external linkage and the link name</span>
<span class="lineno" id=line14></span>    <span class="doccomment">given in the "as" phrase.</span>
<span class="lineno" id=line15></span>    <span class="doccomment">The function must be identified by a suffixed name</span>
<span class="lineno" id=line16></span>    <span class="doccomment">to choose between overloads. Example:</span>
<span class="lineno" id=line17></span>    <span class="doccomment">  //$ export fun myfun of (int) as "MyFun";</span>
<span class="lineno" id=line18></span>    <span class="doccomment">  private cbind_stmt := "export" "fun" ssuffixed_name "as" sstring ";" =&gt;#</span>
<span class="lineno" id=line19></span>      <span class="fstring">"`(ast_export_fun ,_sr ,_3 ,_5)"</span>;
<span class="lineno" id=line20></span>  
<span class="lineno" id=line21></span>    <span class="doccomment">Export a Felix function with C type into C.</span>
<span class="lineno" id=line22></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> cbind_stmt := <span class="fstring">"export"</span> <span class="fstring">"cfun"</span> ssuffixed_name <span class="fstring">"as"</span> sstring <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line23></span>      <span class="fstring">"`(ast_export_cfun ,_sr ,_3 ,_5)"</span>;
<span class="lineno" id=line24></span>  
<span class="lineno" id=line25></span>    <span class="doccomment">Export a Felix procedure into C.</span>
<span class="lineno" id=line26></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> cbind_stmt := <span class="fstring">"export"</span> <span class="fstring">"proc"</span> ssuffixed_name <span class="fstring">"as"</span> sstring <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line27></span>      <span class="fstring">"`(ast_export_fun ,_sr ,_3 ,_5)"</span>;
<span class="lineno" id=line28></span>  
<span class="lineno" id=line29></span>    <span class="doccomment">Export a Felix procedure with C type into C.</span>
<span class="lineno" id=line30></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> cbind_stmt := <span class="fstring">"export"</span> <span class="fstring">"cproc"</span> ssuffixed_name <span class="fstring">"as"</span> sstring <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line31></span>      <span class="fstring">"`(ast_export_cfun ,_sr ,_3 ,_5)"</span>;
<span class="lineno" id=line32></span>  
<span class="lineno" id=line33></span>    <span class="doccomment">Export a Felix struct into C.</span>
<span class="lineno" id=line34></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> cbind_stmt := <span class="fstring">"export"</span> <span class="fstring">"struct"</span> ssuffixed_name <span class="fstring">"as"</span> sstring <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line35></span>      <span class="fstring">"`(ast_export_struct ,_sr ,_3 ,_5)"</span>;
<span class="lineno" id=line36></span>  
<span class="lineno" id=line37></span>    <span class="doccomment">Export a Felix union into C.</span>
<span class="lineno" id=line38></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> cbind_stmt := <span class="fstring">"export"</span> <span class="fstring">"variant"</span> ssuffixed_name <span class="fstring">"as"</span> sstring <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line39></span>      <span class="fstring">"`(ast_export_union,_sr ,_3 ,_5)"</span>;
<span class="lineno" id=line40></span>  
<span class="lineno" id=line41></span>    <span class="doccomment">Export a type into C. </span>
<span class="lineno" id=line42></span>    <span class="doccomment">This is done using a typedef that defines the alias</span>
<span class="lineno" id=line43></span>    <span class="doccomment">specified in the "as" phase to be the type expression.</span>
<span class="lineno" id=line44></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> cbind_stmt := <span class="fstring">"export"</span> <span class="fstring">"type"</span> <span class="fstring">"("</span> stypeexpr <span class="fstring">")"</span> <span class="fstring">"as"</span> sstring <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line45></span>      <span class="fstring">"`(ast_export_type ,_sr ,_4 ,_7)"</span>;
<span class="lineno" id=line46></span>  
<span class="lineno" id=line47></span>  
<span class="lineno" id=line48></span>    <span class="comment">// Export python3 function</span>
<span class="lineno" id=line49></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> cbind_stmt := <span class="fstring">"export"</span> <span class="fstring">"python"</span> <span class="fstring">"fun"</span> ssuffixed_name <span class="fstring">"as"</span> sstring <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line50></span>      <span class="fstring">"`(ast_export_python_fun ,_sr ,_4 ,_6)"</span>;
<span class="lineno" id=line51></span>  
<span class="lineno" id=line52></span>  
<span class="lineno" id=line53></span>    <span class="doccomment">The optional precedence phase specifies</span>
<span class="lineno" id=line54></span>    <span class="doccomment">the C++ precedence of an expression, to allow</span>
<span class="lineno" id=line55></span>    <span class="doccomment">the Felix compiler to minimise generated parentheses.</span>
<span class="lineno" id=line56></span>    <span class="doccomment">  //$ The precedence must be one of:</span>
<span class="lineno" id=line57></span>    <span class="doccomment">  //$ atom, primary, postfix, unary, cast, pm, mult, add, shift, rel, eq, </span>
<span class="lineno" id=line58></span>    <span class="doccomment">band, bxor, bor, and, xor, or, cond, assign, comma</span>
<span class="lineno" id=line59></span>    <span class="doccomment"></span>
<span class="lineno" id=line60></span>    sopt_prec := <span class="fstring">"is"</span> sname =&gt;# <span class="fstring">"_2"</span>; 
<span class="lineno" id=line61></span>    sopt_prec := sepsilon =&gt;# <span class="fstring">'(quote "")'</span>;
<span class="lineno" id=line62></span>  
<span class="lineno" id=line63></span>    <span class="doccomment">Define a function by a C expression.</span>
<span class="lineno" id=line64></span>    <span class="doccomment">If the optional C string is elided, the function</span>
<span class="lineno" id=line65></span>    <span class="doccomment">is taken to be bound to a C function of the same name.</span>
<span class="lineno" id=line66></span>    <span class="doccomment">For example:</span>
<span class="lineno" id=line67></span>    <span class="doccomment">  //$ fun sin : double -&gt; double;</span>
<span class="lineno" id=line68></span>    <span class="doccomment">  //$ is equivalent to</span>
<span class="lineno" id=line69></span>    <span class="doccomment">  //$ fun sin : double -&gt; double = "sin($1)";</span>
<span class="lineno" id=line70></span>    <span class="doccomment">  private cbind_stmt := sadjectives sfun_kind sdeclname fun_return_type sopt_cstring sopt_prec srequires_clause ";" =&gt;#</span>
<span class="lineno" id=line71></span>      <span class="fstring">"""
<span class="lineno" id=line72></span>        (let* (
<span class="lineno" id=line73></span>          (name (first _3))
<span class="lineno" id=line74></span>          (vs (second _3))
<span class="lineno" id=line75></span>          (kind (cal_funkind _1 _2))
<span class="lineno" id=line76></span>          (t (first (first _4)))
<span class="lineno" id=line77></span>          (traint (second (first _4)))
<span class="lineno" id=line78></span>          (prec _6)
<span class="lineno" id=line79></span>          (reqs (if (memv 'Virtual _1)
<span class="lineno" id=line80></span>            `(rreq_and (rreq_atom (Property_req "virtual")) ,_7)
<span class="lineno" id=line81></span>            _7)
<span class="lineno" id=line82></span>          )
<span class="lineno" id=line83></span>          (ct
<span class="lineno" id=line84></span>            (if (eq? 'none _5)
<span class="lineno" id=line85></span>              (if (memv 'Virtual _1)
<span class="lineno" id=line86></span>                'Virtual
<span class="lineno" id=line87></span>                 ;; `(StrTemplate ,(string-append "(#0) ::" name "($a)"))
<span class="lineno" id=line88></span>                 `(StrTemplate ,(string-append "(#0) " name "($a)")) ;; the :: doesn't work cause it could be a macro!
<span class="lineno" id=line89></span>               )
<span class="lineno" id=line90></span>               (second _5))
<span class="lineno" id=line91></span>          )
<span class="lineno" id=line92></span>        )
<span class="lineno" id=line93></span>        (let (
<span class="lineno" id=line94></span>          (reqs
<span class="lineno" id=line95></span>            (if (eq? 'Generator kind)
<span class="lineno" id=line96></span>              `(rreq_and (rreq_atom (Property_req "generator")) ,reqs)
<span class="lineno" id=line97></span>              reqs))
<span class="lineno" id=line98></span>        )
<span class="lineno" id=line99></span>        (if (eq? 'typ_arrow (first t))
<span class="lineno" id=line100></span>          (let (
<span class="lineno" id=line101></span>            (argt (caadr t))
<span class="lineno" id=line102></span>            (ret (cadadr t)))
<span class="lineno" id=line103></span>          `(ast_fun_decl ,_sr ,name ,vs ,(mktylist argt) ,ret ,ct ,reqs ,prec)
<span class="lineno" id=line104></span>          )
<span class="lineno" id=line105></span>          (giveup))))
<span class="lineno" id=line106></span>      """</span>;
<span class="lineno" id=line107></span>  
<span class="lineno" id=line108></span>    <span class="doccomment">Define a constructor function by a C expression.</span>
<span class="lineno" id=line109></span>    stmt := <span class="fstring">"ctor"</span> stvarlist squalified_name <span class="fstring">":"</span> stypeexpr sopt_cstring sopt_prec srequires_clause <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line110></span>      <span class="fstring">"""
<span class="lineno" id=line111></span>      (let*
<span class="lineno" id=line112></span>        (
<span class="lineno" id=line113></span>          (name (string-append "_ctor_" (base_of_qualified_name _3)))
<span class="lineno" id=line114></span>          (vs _2)
<span class="lineno" id=line115></span>          (ret _3)
<span class="lineno" id=line116></span>          (argt _5)
<span class="lineno" id=line117></span>          (ct
<span class="lineno" id=line118></span>            (if (eq? 'none _6)
<span class="lineno" id=line119></span>              `(StrTemplate ,(string-append "::" (base_of_qualified_name _3) "($a)"))
<span class="lineno" id=line120></span>              (second _6)
<span class="lineno" id=line121></span>            )
<span class="lineno" id=line122></span>          )
<span class="lineno" id=line123></span>          (prec _7)
<span class="lineno" id=line124></span>          (reqs _8)
<span class="lineno" id=line125></span>        )
<span class="lineno" id=line126></span>        `(ast_fun_decl ,_sr ,name ,vs ,(mktylist argt) ,ret ,ct ,reqs ,prec)
<span class="lineno" id=line127></span>      )
<span class="lineno" id=line128></span>      """</span>;
<span class="lineno" id=line129></span>    stmt := <span class="fstring">"supertype"</span> stvarlist squalified_name <span class="fstring">":"</span> stypeexpr sopt_cstring sopt_prec srequires_clause <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line130></span>      <span class="fstring">"""
<span class="lineno" id=line131></span>      (let*
<span class="lineno" id=line132></span>        (
<span class="lineno" id=line133></span>          (name (string-append "_supertype_" (base_of_qualified_name _3)))
<span class="lineno" id=line134></span>          (vs _2)
<span class="lineno" id=line135></span>          (ret _3)
<span class="lineno" id=line136></span>          (argt _5)
<span class="lineno" id=line137></span>          (ct
<span class="lineno" id=line138></span>            (if (eq? 'none _6)
<span class="lineno" id=line139></span>              `(StrTemplate ,(string-append "::" (base_of_qualified_name _3) "($a)"))
<span class="lineno" id=line140></span>              (second _6)
<span class="lineno" id=line141></span>            )
<span class="lineno" id=line142></span>          )
<span class="lineno" id=line143></span>          (prec _7)
<span class="lineno" id=line144></span>          (xreqs _8)
<span class="lineno" id=line145></span>          (reqs `(rreq_and (rreq_atom (Subtype_req)) ,xreqs))
<span class="lineno" id=line146></span>        )
<span class="lineno" id=line147></span>        `(ast_fun_decl ,_sr ,name ,vs ,(mktylist argt) ,ret ,ct ,reqs ,prec)
<span class="lineno" id=line148></span>      )
<span class="lineno" id=line149></span>      """</span>;
<span class="lineno" id=line150></span>    stmt := <span class="fstring">"supertype"</span> stvarlist <span class="fstring">"&amp;"</span> squalified_name <span class="fstring">":"</span> stypeexpr sopt_cstring sopt_prec srequires_clause <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line151></span>      <span class="fstring">"""
<span class="lineno" id=line152></span>      (let*
<span class="lineno" id=line153></span>        (
<span class="lineno" id=line154></span>          (name (string-append "_supertype_" (base_of_qualified_name _4)))
<span class="lineno" id=line155></span>          (vs _2)
<span class="lineno" id=line156></span>          (ret `(typ_ref ,_sr ,_4))
<span class="lineno" id=line157></span>          (argt _6)
<span class="lineno" id=line158></span>          (ct
<span class="lineno" id=line159></span>            (if (eq? 'none _7)
<span class="lineno" id=line160></span>              `(StrTemplate ,(string-append "::" (base_of_qualified_name _4) "($a)"))
<span class="lineno" id=line161></span>              (second _6)
<span class="lineno" id=line162></span>            )
<span class="lineno" id=line163></span>          )
<span class="lineno" id=line164></span>          (prec _8)
<span class="lineno" id=line165></span>          (xreqs _9)
<span class="lineno" id=line166></span>          (reqs `(rreq_and (rreq_atom (Subtype_req)) ,xreqs))
<span class="lineno" id=line167></span>        )
<span class="lineno" id=line168></span>        `(ast_fun_decl ,_sr ,name ,vs ,(mktylist argt) ,ret ,ct ,reqs ,prec)
<span class="lineno" id=line169></span>      )
<span class="lineno" id=line170></span>      """</span>;
<span class="lineno" id=line171></span>    cbind_stmt:= <span class="fstring">"virtual"</span> <span class="fstring">"type"</span> sname <span class="fstring">";"</span> =&gt;# 
<span class="lineno" id=line172></span>      <span class="fstring">"`(ast_virtual_type ,_sr ,_3)"</span>
<span class="lineno" id=line173></span>    ;
<span class="lineno" id=line174></span>  
<span class="lineno" id=line175></span>    <span class="doccomment">Define a type by a C type expression.</span>
<span class="lineno" id=line176></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> cbind_stmt:= stype_qual* <span class="fstring">"type"</span> sdeclname <span class="fstring">"="</span> scode_spec srequires_clause <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line177></span>      <span class="fstring">"""
<span class="lineno" id=line178></span>      `(ast_abs_decl ,_sr ,(first _3) ,(second _3) ,_1 ,_5 ,_6)
<span class="lineno" id=line179></span>      """</span>;
<span class="lineno" id=line180></span>  
<span class="lineno" id=line181></span>    <span class="doccomment">Define a special kind of procedure which can be used</span>
<span class="lineno" id=line182></span>    <span class="doccomment">as a C callback.</span>
<span class="lineno" id=line183></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> cbind_stmt := <span class="fstring">"callback"</span> <span class="fstring">"proc"</span> sname <span class="fstring">":"</span> stypeexpr srequires_clause <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line184></span>      <span class="fstring">"""
<span class="lineno" id=line185></span>      `(ast_callback_decl ,_sr ,_3 ,(mktylist _5) (ast_void ,_sr) ,_6)
<span class="lineno" id=line186></span>      """</span>;
<span class="lineno" id=line187></span>  
<span class="lineno" id=line188></span>    <span class="doccomment">Define a special kind of function which can be used</span>
<span class="lineno" id=line189></span>    <span class="doccomment">as a C callback.</span>
<span class="lineno" id=line190></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> cbind_stmt := <span class="fstring">"callback"</span> <span class="fstring">"fun"</span> sname <span class="fstring">":"</span> stypeexpr srequires_clause <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line191></span>      <span class="fstring">"""
<span class="lineno" id=line192></span>      (if (eq? 'typ_arrow (first _5))
<span class="lineno" id=line193></span>        (let*
<span class="lineno" id=line194></span>          (
<span class="lineno" id=line195></span>            (ft (second _5))
<span class="lineno" id=line196></span>            (dom (first ft))
<span class="lineno" id=line197></span>            (cod (second ft))
<span class="lineno" id=line198></span>            (args (mktylist dom))
<span class="lineno" id=line199></span>          )
<span class="lineno" id=line200></span>        `(ast_callback_decl ,_sr ,_3 ,args ,cod ,_6)
<span class="lineno" id=line201></span>        )
<span class="lineno" id=line202></span>        'ERROR
<span class="lineno" id=line203></span>      )
<span class="lineno" id=line204></span>      """</span>;
<span class="lineno" id=line205></span>  
<span class="lineno" id=line206></span>    <span class="doccomment">The type qualifier incomplete is used to</span>
<span class="lineno" id=line207></span>    <span class="doccomment">prevent allocation of values of this type.</span>
<span class="lineno" id=line208></span>    <span class="doccomment">Pointers can still be formed.</span>
<span class="lineno" id=line209></span>    stype_qual := <span class="fstring">"incomplete"</span> =&gt;# <span class="fstring">"'Incomplete"</span>;
<span class="lineno" id=line210></span>    stype_qual := <span class="fstring">"uncopyable"</span> =&gt;# <span class="fstring">"'Uncopyable"</span>;
<span class="lineno" id=line211></span>    stype_qual := <span class="fstring">"regular"</span> =&gt;# <span class="fstring">"'Regular"</span>;
<span class="lineno" id=line212></span>    stype_qual := <span class="fstring">"semiregular"</span> =&gt;# <span class="fstring">"'Semiregular"</span>;
<span class="lineno" id=line213></span>  
<span class="lineno" id=line214></span>    <span class="doccomment">The type qualified pod is used to specify</span>
<span class="lineno" id=line215></span>    <span class="doccomment">that a type has a trivial destructor.</span>
<span class="lineno" id=line216></span>    <span class="doccomment">This allows the garbage collector to omit</span>
<span class="lineno" id=line217></span>    <span class="doccomment">a call to the destructor, which is the default</span>
<span class="lineno" id=line218></span>    <span class="doccomment">finaliser.</span>
<span class="lineno" id=line219></span>    stype_qual := <span class="fstring">"pod"</span> =&gt;# <span class="fstring">"'Pod"</span>;
<span class="lineno" id=line220></span>  
<span class="lineno" id=line221></span>    <span class="doccomment">Specify a C types is a garbage collectable</span>
<span class="lineno" id=line222></span>    <span class="doccomment">pointer type, so it will be tracked by the collector.</span>
<span class="lineno" id=line223></span>    stype_qual := <span class="fstring">"_gc_pointer"</span> =&gt;# <span class="fstring">"'GC_pointer"</span>;
<span class="lineno" id=line224></span>  
<span class="lineno" id=line225></span>    <span class="doccomment">Specify the shape of the type should</span>
<span class="lineno" id=line226></span>    <span class="doccomment">be taken as the shape of the given type expression.</span>
<span class="lineno" id=line227></span>    <span class="doccomment">This is required when the type is immobile</span>
<span class="lineno" id=line228></span>    <span class="doccomment">and represented by a pointer.</span>
<span class="lineno" id=line229></span>    <span class="doccomment">  //$ For example, the C++ RE2 type of Google's RE2 package</span>
<span class="lineno" id=line230></span>    <span class="doccomment">cannot be used directly as a type because it is not</span>
<span class="lineno" id=line231></span>    <span class="doccomment">copy assignable. Instead we have to use a pointer.</span>
<span class="lineno" id=line232></span>    <span class="doccomment">  //$ Here is the way this is done:</span>
<span class="lineno" id=line233></span>    <span class="doccomment">  //$ private type RE2_ = "::re2::RE2";</span>
<span class="lineno" id=line234></span>    <span class="doccomment">_gc_pointer _gc_type RE2_ type RE2 = "::re2::RE2*";</span>
<span class="lineno" id=line235></span>    <span class="doccomment">gen _ctor_RE2 : string -&gt; RE2 = "new (*ptf-&gt;gcp, @0, false) RE2($1)";</span>
<span class="lineno" id=line236></span>    <span class="doccomment">  //$ We bind the private type RE2_ to the C type RE2.</span>
<span class="lineno" id=line237></span>    <span class="doccomment">It's private so the public cannot allocate it.</span>
<span class="lineno" id=line238></span>    <span class="doccomment">  //$ Instead we use the type RE2 which is a pointer, and thus</span>
<span class="lineno" id=line239></span>    <span class="doccomment">copyable. because it is a pointer we have to specify</span>
<span class="lineno" id=line240></span>    <span class="doccomment">_gc_pointer.</span>
<span class="lineno" id=line241></span>    <span class="doccomment"></span>
<span class="lineno" id=line242></span>    <span class="doccomment">Now, the constructor _ctor_RE2 takes a string and returns</span>
<span class="lineno" id=line243></span>    <span class="doccomment">a Felix RE2 (C type RE2*) which is a pointer to a heap allocated </span>
<span class="lineno" id=line244></span>    <span class="doccomment">object of type _RE2 (C type RE2).</span>
<span class="lineno" id=line245></span>    <span class="doccomment"></span>
<span class="lineno" id=line246></span>    <span class="doccomment">The constructor does the allocation, so it must provde the</span>
<span class="lineno" id=line247></span>    <span class="doccomment">shape of the RE2_ object, and this is what the specification</span>
<span class="lineno" id=line248></span>    <span class="doccomment">_gc_type RE2_ does. This allows the notation @0 to refer to</span>
<span class="lineno" id=line249></span>    <span class="doccomment">the shape of RE2_ instead of RE2 which it would normally.</span>
<span class="lineno" id=line250></span>  
<span class="lineno" id=line251></span>    stype_qual := <span class="fstring">"_gc_type"</span> stypeexpr =&gt;# <span class="fstring">"`(Raw_needs_shape ,_2)"</span>;
<span class="lineno" id=line252></span>  
<span class="lineno" id=line253></span>    <span class="doccomment">Define a set of types as C types with the same names.</span>
<span class="lineno" id=line254></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> cbind_stmt:= stype_qual* <span class="fstring">"ctypes"</span> snames srequires_clause <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line255></span>      <span class="fstring">"`(ast_ctypes ,_sr ,_3 ,_1 ,_4)"</span>;
<span class="lineno" id=line256></span>  
<span class="lineno" id=line257></span>    <span class="doccomment">Embed a C statement into Felix code with arguments.</span>
<span class="lineno" id=line258></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> cbind_stmt:= <span class="fstring">"cstmt"</span> scode_spec sexpr? <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_code ,_sr ,_2 ,_3)"</span>;
<span class="lineno" id=line259></span>  
<span class="lineno" id=line260></span>  
<span class="lineno" id=line261></span>    <span class="doccomment">Embed a C statement which does not return normally</span>
<span class="lineno" id=line262></span>    <span class="doccomment">into Felix code. For example:</span>
<span class="lineno" id=line263></span>    <span class="doccomment">  //$ noreturn cstmt "exit(0);";</span>
<span class="lineno" id=line264></span>    <span class="doccomment">  private cbind_stmt:= "noreturn" "cstmt" scode_spec sexpr? ";" =&gt;# "`(ast_noreturn_code ,_sr ,_3 ,_4)";</span>
<span class="lineno" id=line265></span>  
<span class="lineno" id=line266></span>    <span class="doccomment">Embed a C expression into Felix.</span>
<span class="lineno" id=line267></span>    <span class="doccomment">This required giving the Felix type of the expression. </span>
<span class="lineno" id=line268></span>    <span class="doccomment">The expression is contained in the string. For example:</span>
<span class="lineno" id=line269></span>    <span class="doccomment">  //$ cexpr [double] "sin(0.7)" endcexpr</span>
<span class="lineno" id=line270></span>    <span class="doccomment">  satom := "cexpr" "[" stypeexpr "]" scode_spec sexpr? "endcexpr" =&gt;# "`(ast_expr ,_sr ,_5 ,_3 ,_6)";</span>
<span class="lineno" id=line271></span>  
<span class="lineno" id=line272></span>    <span class="doccomment">A short form embedding for variables.</span>
<span class="lineno" id=line273></span>    <span class="doccomment">  //$ cvar [double] M_PI</span>
<span class="lineno" id=line274></span>    <span class="doccomment">  satom := "cvar" "[" stypeexpr "]" sname =&gt;# "`(ast_expr ,_sr (Str ,_5) ,_3 ())";</span>
<span class="lineno" id=line275></span>  
<span class="lineno" id=line276></span>    <span class="doccomment">Bind a C expression to a name.</span>
<span class="lineno" id=line277></span>    <span class="doccomment">Note that despite the binding being called "const",</span>
<span class="lineno" id=line278></span>    <span class="doccomment">the C expression does not have to be constant.</span>
<span class="lineno" id=line279></span>    <span class="doccomment">For example:</span>
<span class="lineno" id=line280></span>    <span class="doccomment">  //$ const rand : int = "rand()";</span>
<span class="lineno" id=line281></span>    <span class="doccomment">  // note: also needed by typeclasses atm for virtual consts</span>
<span class="lineno" id=line282></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> cbind_stmt := sadjectives <span class="fstring">"const"</span> sdeclname <span class="fstring">":"</span> stypeexpr <span class="fstring">"="</span> scode_spec srequires_clause <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line283></span>      <span class="fstring">"""
<span class="lineno" id=line284></span>        (let ((reqs (if (memv 'Virtual _1)
<span class="lineno" id=line285></span>          `(rreq_and (rreq_atom (Property_req "virtual")) ,_8)
<span class="lineno" id=line286></span>          _8)))
<span class="lineno" id=line287></span>        `(ast_const_decl ,_sr ,(first _3) ,(second _3) ,_5 ,_7 ,reqs)
<span class="lineno" id=line288></span>        )
<span class="lineno" id=line289></span>      """</span>;
<span class="lineno" id=line290></span>  
<span class="lineno" id=line291></span>    <span class="doccomment">Short form of const that declares a variable</span>
<span class="lineno" id=line292></span>    <span class="doccomment">bound to the same name in C.</span>
<span class="lineno" id=line293></span>    <span class="doccomment">Example:</span>
<span class="lineno" id=line294></span>    <span class="doccomment">  //$ const RAND_MAX: long;</span>
<span class="lineno" id=line295></span>    <span class="doccomment">/*</span>
<span class="lineno" id=line296></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> cbind_stmt := sadjectives <span class="fstring">"const"</span> sdeclname <span class="fstring">":"</span> stypeexpr srequires_clause <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line297></span>      <span class="fstring">"""
<span class="lineno" id=line298></span>        (let ((reqs (if (memv 'Virtual _1)
<span class="lineno" id=line299></span>          `(rreq_and (rreq_atom (Property_req "virtual")) ,_6)
<span class="lineno" id=line300></span>          _6)))
<span class="lineno" id=line301></span>        `(ast_const_decl ,_sr ,(first _3) ,(second _3) ,_5 (Str ,(first _3)) ,reqs)
<span class="lineno" id=line302></span>        )
<span class="lineno" id=line303></span>      """</span>;
<span class="lineno" id=line304></span>  */
<span class="lineno" id=line305></span>  
<span class="lineno" id=line306></span>  
<span class="lineno" id=line307></span>   
<span class="lineno" id=line308></span>    <span class="doccomment">Short form of const that declares a list of variables</span>
<span class="lineno" id=line309></span>    <span class="doccomment">of the same type to be bound to their C names.</span>
<span class="lineno" id=line310></span>    <span class="doccomment">Useful for lifting enumerations. Example:</span>
<span class="lineno" id=line311></span>    <span class="doccomment">  //$ const a,b,c : int;</span>
<span class="lineno" id=line312></span>    <span class="doccomment">  private cbind_stmt := sadjectives "const" sdeclnames ":" stypeexpr srequires_clause ";" =&gt;#</span>
<span class="lineno" id=line313></span>      <span class="fstring">"""
<span class="lineno" id=line314></span>        (let ((reqs (if (memv 'Virtual _1)
<span class="lineno" id=line315></span>          `(rreq_and (rreq_atom (Property_req "virtual")) ,_6)
<span class="lineno" id=line316></span>          _6)))
<span class="lineno" id=line317></span>        (begin 
<span class="lineno" id=line318></span>           (define (constdef sym) 
<span class="lineno" id=line319></span>            `(ast_const_decl ,_sr ,(first sym) ,(second sym) ,_5 (Str ,(first sym)) ,reqs))
<span class="lineno" id=line320></span>           `(ast_seq ,_sr ,(map constdef _3)) 
<span class="lineno" id=line321></span>        )
<span class="lineno" id=line322></span>      )
<span class="lineno" id=line323></span>      """</span>;
<span class="lineno" id=line324></span>  
<span class="lineno" id=line325></span>    <span class="doccomment">Special form for lifting C enumerations.</span>
<span class="lineno" id=line326></span>    <span class="doccomment">Specifies the type name and enumeration constants</span>
<span class="lineno" id=line327></span>    <span class="doccomment">in a single statement. Names bound to the same names in C.</span>
<span class="lineno" id=line328></span>    <span class="doccomment">  //$ This form also defined equality and inequality operators</span>
<span class="lineno" id=line329></span>    <span class="doccomment">for the type automatically, as an instance of class Eq.</span>
<span class="lineno" id=line330></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> cbind_stmt := <span class="fstring">"cenum"</span> sname <span class="fstring">"="</span> snames srequires_clause <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line331></span>      <span class="fstring">"""
<span class="lineno" id=line332></span>        (begin 
<span class="lineno" id=line333></span>           (define (constdef sym) 
<span class="lineno" id=line334></span>            `(ast_const_decl ,_sr ,sym ,dfltvs ,(nos _2) (Str ,sym) ,_5))
<span class="lineno" id=line335></span>             (let* 
<span class="lineno" id=line336></span>               (
<span class="lineno" id=line337></span>                 (tdec `(ast_abs_decl ,_sr ,_2 ,dfltvs (Pod) (Str ,_2) ,_5))
<span class="lineno" id=line338></span>                 (argt `(typ_tuple ,_sr (,(nos _2) ,(nos _2))))
<span class="lineno" id=line339></span>                 (eqdef `(ast_fun_decl ,_sr "==" ,dfltvs ,(mktylist argt) ,(nos "bool") (StrTemplate "$1==$2") rreq_true ""))
<span class="lineno" id=line340></span>                 (instdef `(ast_instance ,_sr ,dfltvs (ast_name ,_sr "Eq" (texprs (,(nos _2)))) (,eqdef)))
<span class="lineno" id=line341></span>                 (inherit `(ast_inject_module ,_sr ,dfltvs (ast_name ,_sr "Eq" (texprs (,(nos _2))))))
<span class="lineno" id=line342></span>               )
<span class="lineno" id=line343></span>               `(ast_seq ,_sr ,(append `(,tdec ,instdef ,inherit) (map constdef _4)))
<span class="lineno" id=line344></span>             )
<span class="lineno" id=line345></span>        )
<span class="lineno" id=line346></span>      """</span>;
<span class="lineno" id=line347></span>  
<span class="lineno" id=line348></span>    <span class="comment">// Very special form for binding C enumeration used as bit flags.</span>
<span class="lineno" id=line349></span>    <span class="doccomment">Specifies the type name and enumeration constants</span>
<span class="lineno" id=line350></span>    <span class="doccomment">in a single statement. Names bound to the same names in C.</span>
<span class="lineno" id=line351></span>    <span class="doccomment">  //$ This form automatically defines equality as an instance of class Eq.</span>
<span class="lineno" id=line352></span>    <span class="doccomment">Furthermore it defines all the standard bitwise operators,</span>
<span class="lineno" id=line353></span>    <span class="doccomment">as an instance of class Bits.</span>
<span class="lineno" id=line354></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> cbind_stmt := <span class="fstring">"cflags"</span> sname <span class="fstring">"="</span> snames srequires_clause <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line355></span>      <span class="fstring">"""
<span class="lineno" id=line356></span>        (begin 
<span class="lineno" id=line357></span>           (define (constdef sym) 
<span class="lineno" id=line358></span>            `(ast_const_decl ,_sr ,sym ,dfltvs ,(nos _2) (Str ,sym) ,_5))
<span class="lineno" id=line359></span>             (let* 
<span class="lineno" id=line360></span>               (
<span class="lineno" id=line361></span>                 (tdec `(ast_abs_decl ,_sr ,_2 ,dfltvs (Pod) (Str ,_2) ,_5))
<span class="lineno" id=line362></span>                 (argt `(typ_tuple ,_sr (,(nos _2) ,(nos _2))))
<span class="lineno" id=line363></span>                 (eqdef `(ast_fun_decl ,_sr "==" ,dfltvs ,(mktylist argt) ,(nos "bool") (StrTemplate "$1==$2") rreq_true ""))
<span class="lineno" id=line364></span>                 (instdef `(ast_instance ,_sr ,dfltvs (ast_name ,_sr "Eq" (texprs (,(nos _2)))) (,eqdef)))
<span class="lineno" id=line365></span>                 (inherit `(ast_inject_module ,_sr ,dfltvs (ast_name ,_sr "Eq" (texprs (,(nos _2))))))
<span class="lineno" id=line366></span>                 (inherit2 `(ast_inject_module ,_sr ,dfltvs (ast_name ,_sr "Bits" (texprs (,(nos _2))))))
<span class="lineno" id=line367></span>               )
<span class="lineno" id=line368></span>               `(ast_seq ,_sr ,(append `(,tdec ,instdef ,inherit ,inherit2) (map constdef _4)))
<span class="lineno" id=line369></span>             )
<span class="lineno" id=line370></span>        )
<span class="lineno" id=line371></span>      """</span>;
<span class="lineno" id=line372></span>  
<span class="lineno" id=line373></span>  
<span class="lineno" id=line374></span>    <span class="doccomment">Define a Felix procedures as a binding to a </span>
<span class="lineno" id=line375></span>    <span class="doccomment">C statement. Only one statement is allowed.</span>
<span class="lineno" id=line376></span>    <span class="doccomment">But you can use a block of course!</span>
<span class="lineno" id=line377></span>    <span class="doccomment">  //$ If the option C text is elided, the procedure</span>
<span class="lineno" id=line378></span>    <span class="doccomment">is taken to be bound to a C function returning void</span>
<span class="lineno" id=line379></span>    <span class="doccomment">of the same name.</span>
<span class="lineno" id=line380></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> cbind_stmt := sadjectives sproc_kind sdeclname <span class="fstring">":"</span> stypeexpr sopt_cstring srequires_clause <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line381></span>      <span class="fstring">"""
<span class="lineno" id=line382></span>        (let (
<span class="lineno" id=line383></span>          (name (first _3))
<span class="lineno" id=line384></span>          (vs (second _3))
<span class="lineno" id=line385></span>          (kind (cal_funkind _1 _2))
<span class="lineno" id=line386></span>          (t _5)
<span class="lineno" id=line387></span>          (reqs (if (memv 'Virtual _1)
<span class="lineno" id=line388></span>            `(rreq_and (rreq_atom (Property_req "virtual")) ,_7)
<span class="lineno" id=line389></span>            _7)
<span class="lineno" id=line390></span>          )
<span class="lineno" id=line391></span>          (ct
<span class="lineno" id=line392></span>            (if (eq? 'none _6)
<span class="lineno" id=line393></span>              (if (memv 'Virtual _1)
<span class="lineno" id=line394></span>                'Virtual
<span class="lineno" id=line395></span>                 `(StrTemplate ,(string-append "::" (first _3) "($a);"))
<span class="lineno" id=line396></span>               )
<span class="lineno" id=line397></span>               (second _6))
<span class="lineno" id=line398></span>          )
<span class="lineno" id=line399></span>        )
<span class="lineno" id=line400></span>        (let (
<span class="lineno" id=line401></span>          (reqs
<span class="lineno" id=line402></span>            (if (eq? 'Generator kind)
<span class="lineno" id=line403></span>              `(rreq_and (rreq_atom (Property_req "generator")) ,reqs)
<span class="lineno" id=line404></span>              reqs))
<span class="lineno" id=line405></span>        )
<span class="lineno" id=line406></span>        (let (
<span class="lineno" id=line407></span>          (argt t)
<span class="lineno" id=line408></span>          (ret `(ast_void ,_sr)))
<span class="lineno" id=line409></span>          `(ast_fun_decl ,_sr ,name ,vs ,(mktylist argt) ,ret ,ct ,reqs "")
<span class="lineno" id=line410></span>          )))
<span class="lineno" id=line411></span>      """</span>;
<span class="lineno" id=line412></span>  }
</pre></p></div><h2 id='Simple_C_grammar_h'><img src='/share/src/web/images/minus.gif' id='Simple C grammar' onclick='toggle(this,"Simple_C_grammar_d")' alt='+'/> 2.6 Simple C grammar</h2><div id='Simple_C_grammar_d' style='display:block'>
<pre class='inclusion'>
share/lib/grammar/cgram.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">Embed C into Felix using extern "C" { } style.</span>
<span class="lineno" id=line2></span>  <span class="doccomment">Direct name binding.</span>
<span class="lineno" id=line3></span>  <span class="doccomment">WORK IN PROGRESS, NOT OPERATIONAL!</span>
<span class="lineno" id=line4></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> cgram {
<span class="lineno" id=line5></span>    stmt := <span class="fstring">"extern"</span> <span class="fstring">'"C"'</span> cstatement =&gt;# <span class="fstring">'`(ast_comment ,_sr "C code ..")'</span>;
<span class="lineno" id=line6></span>    stmt := <span class="fstring">"extern"</span> <span class="fstring">'"C"'</span> <span class="fstring">"{"</span> cstatement+ <span class="fstring">"}"</span> =&gt;# <span class="fstring">'`(ast_comment ,_sr "C code ..")'</span>;
<span class="lineno" id=line7></span>    cstatement := external_declaration;
<span class="lineno" id=line8></span>    <span class="comment">// this only for testing</span>
<span class="lineno" id=line9></span>    satom := <span class="fstring">"extern"</span> <span class="fstring">'"C"'</span> <span class="fstring">"("</span> expression <span class="fstring">")"</span> =&gt;# <span class="fstring">"_4"</span>;
<span class="lineno" id=line10></span>  
<span class="lineno" id=line11></span>  
<span class="lineno" id=line12></span>  TYPE_NAME := sname ; <span class="comment">// special, needs to lookup typedef names</span>
<span class="lineno" id=line13></span>  
<span class="lineno" id=line14></span>  primary_expression
<span class="lineno" id=line15></span>  	:= sname             =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line16></span>  	| sliteral           =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line17></span>  	| <span class="fstring">'('</span> expression <span class="fstring">')'</span> =&gt;# <span class="fstring">"_2"</span>
<span class="lineno" id=line18></span>  	;
<span class="lineno" id=line19></span>  
<span class="lineno" id=line20></span>  postfix_expression
<span class="lineno" id=line21></span>  	:= primary_expression =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line22></span>  	| postfix_expression <span class="fstring">'['</span> expression <span class="fstring">']'</span> =&gt;# <span class="fstring">"`(subscript ,_sr ,_1 ,_3)"</span>
<span class="lineno" id=line23></span>  	| postfix_expression <span class="fstring">'('</span> <span class="fstring">')'</span>            =&gt;# <span class="fstring">"`(apply ,_sr ,_1 ())"</span>
<span class="lineno" id=line24></span>  	| postfix_expression <span class="fstring">'('</span> argument_expression_list <span class="fstring">')'</span> =&gt;# <span class="fstring">"`(ast_apply ,_sr ,(_1 (reverse _3)))"</span>
<span class="lineno" id=line25></span>  	| postfix_expression <span class="fstring">'.'</span> sname                        =&gt;# <span class="fstring">"`(ast_apply ,_sr (,_3 ,_1))"</span>
<span class="lineno" id=line26></span>  	| postfix_expression <span class="fstring">'-&gt;'</span> sname                       =&gt;# <span class="fstring">"`(typ_arrow ,_sr (,_1 ,_3))"</span>
<span class="lineno" id=line27></span>  	| postfix_expression <span class="fstring">'++'</span>                             =&gt;# <span class="fstring">"`(uop ,_sr 'postincr' ,_1)"</span>
<span class="lineno" id=line28></span>  	| postfix_expression <span class="fstring">'--'</span>                             =&gt;# <span class="fstring">"`(uop ,_sr 'postdecr' ,_1)"</span>
<span class="lineno" id=line29></span>  	;
<span class="lineno" id=line30></span>  
<span class="lineno" id=line31></span>  argument_expression_list
<span class="lineno" id=line32></span>  	:= assignment_expression =&gt;# <span class="fstring">"`(,_1)"</span>
<span class="lineno" id=line33></span>  	| argument_expression_list <span class="fstring">','</span> assignment_expression =&gt;# <span class="fstring">"(cons _3 _1)"</span>
<span class="lineno" id=line34></span>  	;
<span class="lineno" id=line35></span>  
<span class="lineno" id=line36></span>  unary_expression
<span class="lineno" id=line37></span>  	:= postfix_expression =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line38></span>  	| unary_operator cast_expression =&gt;# <span class="fstring">"(prefix _2)"</span>
<span class="lineno" id=line39></span>  	| <span class="fstring">'sizeof'</span> <span class="fstring">'('</span> type_name <span class="fstring">')'</span> =&gt;# <span class="fstring">"`(sizeoftype ,_sr ,_3)"</span> <span class="comment">// FIXME, WRONG!</span>
<span class="lineno" id=line40></span>  	;
<span class="lineno" id=line41></span>  
<span class="lineno" id=line42></span>  unary_operator
<span class="lineno" id=line43></span>  	:= <span class="fstring">'&amp;'</span> =&gt;# <span class="fstring">"'addressof"</span>
<span class="lineno" id=line44></span>  	| <span class="fstring">'*'</span>  =&gt;# <span class="fstring">"'deref"</span> 
<span class="lineno" id=line45></span>  	| <span class="fstring">'+'</span>  =&gt;# <span class="fstring">"'pos"</span>
<span class="lineno" id=line46></span>  	| <span class="fstring">'-'</span>  =&gt;# <span class="fstring">"'neg"</span>
<span class="lineno" id=line47></span>  	| <span class="fstring">'~'</span>  =&gt;# <span class="fstring">"'compl"</span>
<span class="lineno" id=line48></span>  	| <span class="fstring">'!'</span>  =&gt;# <span class="fstring">"'excl"</span>
<span class="lineno" id=line49></span>    | <span class="fstring">'++'</span> =&gt;# <span class="fstring">"'preincr"</span>
<span class="lineno" id=line50></span>    | <span class="fstring">'--'</span> =&gt;# <span class="fstring">"'postincr"</span>
<span class="lineno" id=line51></span>    | <span class="fstring">'sizeof'</span> =&gt;# <span class="fstring">"'sizeof"</span>
<span class="lineno" id=line52></span>  	;
<span class="lineno" id=line53></span>  
<span class="lineno" id=line54></span>  cast_expression
<span class="lineno" id=line55></span>  	:= unary_expression =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line56></span>  	| <span class="fstring">'('</span> type_name <span class="fstring">')'</span> cast_expression =&gt;# <span class="fstring">"`(ast_coercion ,_sr (,_3 ,_2))"</span> <span class="comment">// FIXME, WRONG!</span>
<span class="lineno" id=line57></span>  	;
<span class="lineno" id=line58></span>  
<span class="lineno" id=line59></span>  multiplicative_expression
<span class="lineno" id=line60></span>  	:= cast_expression =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line61></span>  	| multiplicative_expression <span class="fstring">'*'</span> cast_expression =&gt;# <span class="fstring">"(infix 'mul)"</span>
<span class="lineno" id=line62></span>  	| multiplicative_expression <span class="fstring">'/'</span> cast_expression =&gt;# <span class="fstring">"(infix 'div)"</span>
<span class="lineno" id=line63></span>  	| multiplicative_expression <span class="fstring">'%'</span> cast_expression =&gt;# <span class="fstring">"(infix 'mod)"</span>
<span class="lineno" id=line64></span>  	;
<span class="lineno" id=line65></span>  
<span class="lineno" id=line66></span>  additive_expression
<span class="lineno" id=line67></span>  	:= multiplicative_expression =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line68></span>  	| additive_expression <span class="fstring">'+'</span> multiplicative_expression =&gt;# <span class="fstring">"(infix 'add)"</span> 
<span class="lineno" id=line69></span>  	| additive_expression <span class="fstring">'-'</span> multiplicative_expression =&gt;# <span class="fstring">"(infix 'sub)"</span> 
<span class="lineno" id=line70></span>  	;
<span class="lineno" id=line71></span>  
<span class="lineno" id=line72></span>  shift_expression
<span class="lineno" id=line73></span>  	:= additive_expression =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line74></span>  	| shift_expression <span class="fstring">'&lt;&lt;'</span> additive_expression =&gt;# <span class="fstring">"(infix 'shl)"</span> 
<span class="lineno" id=line75></span>  	| shift_expression <span class="fstring">'&gt;&gt;'</span> additive_expression =&gt;# <span class="fstring">"(infix 'shr)"</span> 
<span class="lineno" id=line76></span>  	;
<span class="lineno" id=line77></span>  
<span class="lineno" id=line78></span>  relational_expression
<span class="lineno" id=line79></span>  	:= shift_expression =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line80></span>  	| relational_expression <span class="fstring">'&lt;'</span> shift_expression =&gt;# <span class="fstring">"(infix 'lt)"</span> 
<span class="lineno" id=line81></span>  	| relational_expression <span class="fstring">'&gt;'</span> shift_expression =&gt;# <span class="fstring">"(infix 'gt)"</span> 
<span class="lineno" id=line82></span>  	| relational_expression <span class="fstring">'&lt;='</span> shift_expression =&gt;# <span class="fstring">"(infix 'le)"</span> 
<span class="lineno" id=line83></span>  	| relational_expression <span class="fstring">'&gt;='</span> shift_expression =&gt;# <span class="fstring">"(infix 'ge)"</span> 
<span class="lineno" id=line84></span>  	;
<span class="lineno" id=line85></span>  
<span class="lineno" id=line86></span>  equality_expression
<span class="lineno" id=line87></span>  	:= relational_expression =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line88></span>  	| equality_expression <span class="fstring">'=='</span> relational_expression =&gt;# <span class="fstring">"(infix 'eq)"</span> 
<span class="lineno" id=line89></span>  	| equality_expression <span class="fstring">'!='</span> relational_expression =&gt;# <span class="fstring">"(infix 'ne)"</span>
<span class="lineno" id=line90></span>  	;
<span class="lineno" id=line91></span>  
<span class="lineno" id=line92></span>  and_expression
<span class="lineno" id=line93></span>  	:= equality_expression =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line94></span>  	| and_expression <span class="fstring">'&amp;'</span> equality_expression =&gt;# <span class="fstring">"(infix 'band)"</span> 
<span class="lineno" id=line95></span>  	;
<span class="lineno" id=line96></span>  
<span class="lineno" id=line97></span>  exclusive_or_expression
<span class="lineno" id=line98></span>  	:= and_expression =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line99></span>  	| exclusive_or_expression <span class="fstring">'^'</span> and_expression =&gt;# <span class="fstring">"(infix 'bxor)"</span> 
<span class="lineno" id=line100></span>  	;
<span class="lineno" id=line101></span>  
<span class="lineno" id=line102></span>  inclusive_or_expression
<span class="lineno" id=line103></span>  	:= exclusive_or_expression =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line104></span>  	| inclusive_or_expression <span class="fstring">'|'</span> exclusive_or_expression =&gt;# <span class="fstring">"(infix 'bor)"</span> 
<span class="lineno" id=line105></span>  	;
<span class="lineno" id=line106></span>  
<span class="lineno" id=line107></span>  logical_and_expression
<span class="lineno" id=line108></span>  	:= inclusive_or_expression =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line109></span>  	| logical_and_expression <span class="fstring">'&amp;&amp;'</span> inclusive_or_expression =&gt;# <span class="fstring">"(infix 'land)"</span> 
<span class="lineno" id=line110></span>  	;
<span class="lineno" id=line111></span>  
<span class="lineno" id=line112></span>  logical_or_expression
<span class="lineno" id=line113></span>  	:= logical_and_expression =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line114></span>  	| logical_or_expression <span class="fstring">'||'</span> logical_and_expression =&gt;# <span class="fstring">"(infix 'lor))"</span> 
<span class="lineno" id=line115></span>  	;
<span class="lineno" id=line116></span>  
<span class="lineno" id=line117></span>  conditional_expression
<span class="lineno" id=line118></span>  	:= logical_or_expression =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line119></span>  	| logical_or_expression <span class="fstring">'?'</span> expression <span class="fstring">':'</span> conditional_expression =&gt;# <span class="fstring">"`(ast_cond ,_sr (,_1 ,_3 ,_5))"</span> 
<span class="lineno" id=line120></span>  	;
<span class="lineno" id=line121></span>  
<span class="lineno" id=line122></span>  assignment_expression
<span class="lineno" id=line123></span>  	:= conditional_expression =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line124></span>  	| unary_expression assignment_operator assignment_expression =&gt;# <span class="fstring">"(infix _2)"</span> 
<span class="lineno" id=line125></span>  	;
<span class="lineno" id=line126></span>  
<span class="lineno" id=line127></span>  assignment_operator
<span class="lineno" id=line128></span>  	:= <span class="fstring">'='</span> =&gt;# <span class="fstring">"'_set"</span>
<span class="lineno" id=line129></span>  	| <span class="fstring">'*='</span> =&gt;# <span class="fstring">"'muleq"</span>
<span class="lineno" id=line130></span>  	| <span class="fstring">'/='</span> =&gt;# <span class="fstring">"'diveq"</span>
<span class="lineno" id=line131></span>  	| <span class="fstring">'%='</span> =&gt;# <span class="fstring">"'modeq"</span>
<span class="lineno" id=line132></span>  	| <span class="fstring">'+='</span> =&gt;# <span class="fstring">"'addeq"</span>
<span class="lineno" id=line133></span>  	| <span class="fstring">'-='</span> =&gt;# <span class="fstring">"'subeq"</span>
<span class="lineno" id=line134></span>  	| <span class="fstring">'&lt;&lt;='</span> =&gt;# <span class="fstring">"'lsheq"</span>
<span class="lineno" id=line135></span>  	| <span class="fstring">'&gt;&gt;='</span> =&gt;# <span class="fstring">"'rsheq"</span>
<span class="lineno" id=line136></span>  	| <span class="fstring">'&amp;='</span> =&gt;# <span class="fstring">"'bandeq"</span>
<span class="lineno" id=line137></span>  	| <span class="fstring">'^='</span> =&gt;# <span class="fstring">"'bxoreq"</span>
<span class="lineno" id=line138></span>  	| <span class="fstring">'|='</span> =&gt;# <span class="fstring">"'boreq"</span>
<span class="lineno" id=line139></span>  	;
<span class="lineno" id=line140></span>  
<span class="lineno" id=line141></span>  expression
<span class="lineno" id=line142></span>  	:= assignment_expression =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line143></span>  	| expression <span class="fstring">','</span> assignment_expression =&gt;# <span class="fstring">"(infix 'comma)"</span> 
<span class="lineno" id=line144></span>  	;
<span class="lineno" id=line145></span>  
<span class="lineno" id=line146></span>  declaration
<span class="lineno" id=line147></span>  	:= declaration_specifiers <span class="fstring">';'</span>
<span class="lineno" id=line148></span>  	| declaration_specifiers init_declarator_list <span class="fstring">';'</span>
<span class="lineno" id=line149></span>    | <span class="fstring">'typedef'</span> type_specifier declarator <span class="fstring">';'</span>
<span class="lineno" id=line150></span>  	;
<span class="lineno" id=line151></span>  
<span class="lineno" id=line152></span>  declaration_specifiers
<span class="lineno" id=line153></span>  	:= storage_class_specifier
<span class="lineno" id=line154></span>  	| storage_class_specifier declaration_specifiers
<span class="lineno" id=line155></span>  	| type_specifier
<span class="lineno" id=line156></span>  	| type_specifier declaration_specifiers
<span class="lineno" id=line157></span>  	| type_qualifier
<span class="lineno" id=line158></span>  	| type_qualifier declaration_specifiers
<span class="lineno" id=line159></span>  	;
<span class="lineno" id=line160></span>  
<span class="lineno" id=line161></span>  init_declarator_list
<span class="lineno" id=line162></span>  	:= init_declarator
<span class="lineno" id=line163></span>  	| init_declarator_list <span class="fstring">','</span> init_declarator
<span class="lineno" id=line164></span>  	;
<span class="lineno" id=line165></span>  
<span class="lineno" id=line166></span>  init_declarator
<span class="lineno" id=line167></span>  	:= declarator
<span class="lineno" id=line168></span>  	| declarator <span class="fstring">'='</span> initializer
<span class="lineno" id=line169></span>  	;
<span class="lineno" id=line170></span>  
<span class="lineno" id=line171></span>  storage_class_specifier
<span class="lineno" id=line172></span>  	:= 
<span class="lineno" id=line173></span>  	| <span class="fstring">'extern'</span>
<span class="lineno" id=line174></span>  	| <span class="fstring">'static'</span>
<span class="lineno" id=line175></span>  	| <span class="fstring">'auto'</span>
<span class="lineno" id=line176></span>  	| <span class="fstring">'register'</span>
<span class="lineno" id=line177></span>  	;
<span class="lineno" id=line178></span>  
<span class="lineno" id=line179></span>  type_specifier
<span class="lineno" id=line180></span>  	:= <span class="fstring">'void'</span>
<span class="lineno" id=line181></span>  	| <span class="fstring">'char'</span>
<span class="lineno" id=line182></span>  	| <span class="fstring">'short'</span>
<span class="lineno" id=line183></span>  	| <span class="fstring">'int'</span>
<span class="lineno" id=line184></span>  	| <span class="fstring">'long'</span>
<span class="lineno" id=line185></span>  	| <span class="fstring">'float'</span>
<span class="lineno" id=line186></span>  	| <span class="fstring">'double'</span>
<span class="lineno" id=line187></span>  	| <span class="fstring">'signed'</span>
<span class="lineno" id=line188></span>  	| <span class="fstring">'unsigned'</span>
<span class="lineno" id=line189></span>  	| struct_or_union_specifier
<span class="lineno" id=line190></span>  	| enum_specifier
<span class="lineno" id=line191></span>  <span class="comment">//	| TYPE_NAME</span>
<span class="lineno" id=line192></span>  	;
<span class="lineno" id=line193></span>  
<span class="lineno" id=line194></span>  struct_or_union_specifier
<span class="lineno" id=line195></span>  	:= struct_or_union sname <span class="fstring">'{'</span> struct_declaration_list <span class="fstring">'}'</span>
<span class="lineno" id=line196></span>  	| struct_or_union <span class="fstring">'{'</span> struct_declaration_list <span class="fstring">'}'</span>
<span class="lineno" id=line197></span>  	| struct_or_union sname
<span class="lineno" id=line198></span>  	;
<span class="lineno" id=line199></span>  
<span class="lineno" id=line200></span>  struct_or_union
<span class="lineno" id=line201></span>  	:= <span class="fstring">'struct'</span>
<span class="lineno" id=line202></span>  	| <span class="fstring">'union'</span>
<span class="lineno" id=line203></span>  	;
<span class="lineno" id=line204></span>  
<span class="lineno" id=line205></span>  struct_declaration_list
<span class="lineno" id=line206></span>  	:= struct_declaration
<span class="lineno" id=line207></span>  	| struct_declaration_list struct_declaration
<span class="lineno" id=line208></span>  	;
<span class="lineno" id=line209></span>  
<span class="lineno" id=line210></span>  struct_declaration
<span class="lineno" id=line211></span>  	:= specifier_qualifier_list struct_declarator_list <span class="fstring">';'</span>
<span class="lineno" id=line212></span>  	;
<span class="lineno" id=line213></span>  
<span class="lineno" id=line214></span>  specifier_qualifier_list
<span class="lineno" id=line215></span>  	:= type_specifier specifier_qualifier_list
<span class="lineno" id=line216></span>  	| type_specifier
<span class="lineno" id=line217></span>  	| type_qualifier specifier_qualifier_list
<span class="lineno" id=line218></span>  	| type_qualifier
<span class="lineno" id=line219></span>  	;
<span class="lineno" id=line220></span>  
<span class="lineno" id=line221></span>  struct_declarator_list
<span class="lineno" id=line222></span>  	:= struct_declarator
<span class="lineno" id=line223></span>  	| struct_declarator_list <span class="fstring">','</span> struct_declarator
<span class="lineno" id=line224></span>  	;
<span class="lineno" id=line225></span>  
<span class="lineno" id=line226></span>  struct_declarator
<span class="lineno" id=line227></span>  	:= declarator
<span class="lineno" id=line228></span>  	| <span class="fstring">':'</span> constant_expression
<span class="lineno" id=line229></span>  	| declarator <span class="fstring">':'</span> constant_expression
<span class="lineno" id=line230></span>  	;
<span class="lineno" id=line231></span>  
<span class="lineno" id=line232></span>  enum_specifier
<span class="lineno" id=line233></span>  	:= <span class="fstring">'enum'</span> <span class="fstring">'{'</span> enumerator_list <span class="fstring">'}'</span>
<span class="lineno" id=line234></span>  	| <span class="fstring">'enum'</span> sname <span class="fstring">'{'</span> enumerator_list <span class="fstring">'}'</span>
<span class="lineno" id=line235></span>  	| <span class="fstring">'enum'</span> sname
<span class="lineno" id=line236></span>  	;
<span class="lineno" id=line237></span>  
<span class="lineno" id=line238></span>  enumerator_list
<span class="lineno" id=line239></span>  	:= enumerator
<span class="lineno" id=line240></span>  	| enumerator_list <span class="fstring">','</span> enumerator
<span class="lineno" id=line241></span>  	;
<span class="lineno" id=line242></span>  
<span class="lineno" id=line243></span>  enumerator
<span class="lineno" id=line244></span>  	:= sname 
<span class="lineno" id=line245></span>  	| sname <span class="fstring">'='</span> constant_expression
<span class="lineno" id=line246></span>  	;
<span class="lineno" id=line247></span>  
<span class="lineno" id=line248></span>  <span class="comment">// Felix doesn't support const or volatile</span>
<span class="lineno" id=line249></span>  type_qualifier
<span class="lineno" id=line250></span>  	:= <span class="fstring">'const'</span>
<span class="lineno" id=line251></span>  	| <span class="fstring">'volatile'</span>
<span class="lineno" id=line252></span>  	;
<span class="lineno" id=line253></span>  
<span class="lineno" id=line254></span>  type_qualifier_list
<span class="lineno" id=line255></span>  	:= type_qualifier
<span class="lineno" id=line256></span>  	| type_qualifier_list type_qualifier
<span class="lineno" id=line257></span>  	;
<span class="lineno" id=line258></span>  
<span class="lineno" id=line259></span>  declarator
<span class="lineno" id=line260></span>  	:= pointer direct_declarator =&gt;# <span class="fstring">"`(ast_ref ,_sr ,_2)"</span> 
<span class="lineno" id=line261></span>  	| direct_declarator =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line262></span>  	;
<span class="lineno" id=line263></span>  
<span class="lineno" id=line264></span>  direct_declarator
<span class="lineno" id=line265></span>  	:= sname                        =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line266></span>  	| <span class="fstring">'('</span> declarator <span class="fstring">')'</span>            =&gt;# <span class="fstring">"_2"</span>
<span class="lineno" id=line267></span>  	| direct_declarator <span class="fstring">'['</span> constant_expression <span class="fstring">']'</span> =&gt;# <span class="fstring">"`(array ,_sr ,_1 ,_3)"</span>
<span class="lineno" id=line268></span>  	| direct_declarator <span class="fstring">'['</span> <span class="fstring">']'</span>                     =&gt;# <span class="fstring">"`(array ,_sr ,_1 ())"</span>  
<span class="lineno" id=line269></span>  	| direct_declarator <span class="fstring">'('</span> parameter_type_list <span class="fstring">')'</span> =&gt;# <span class="fstring">"`(fun ,_sr ,_1 ,(reverse _3))"</span>
<span class="lineno" id=line270></span>  	| direct_declarator <span class="fstring">'('</span> <span class="fstring">')'</span>                     =&gt;# <span class="fstring">"`(fun ,_sr ,_1 ())"</span>
<span class="lineno" id=line271></span>  	;
<span class="lineno" id=line272></span>  
<span class="lineno" id=line273></span>  pointer
<span class="lineno" id=line274></span>  	:= <span class="fstring">'*'</span>                                          =&gt;# <span class="fstring">"`(ptr)"</span>
<span class="lineno" id=line275></span>  	| <span class="fstring">'*'</span> type_qualifier_list                       =&gt;# <span class="fstring">"`(ptr)"</span>
<span class="lineno" id=line276></span>  	| <span class="fstring">'*'</span> pointer                                   =&gt;# <span class="fstring">"(cons 'ptr ,_2)"</span>
<span class="lineno" id=line277></span>  	| <span class="fstring">'*'</span> type_qualifier_list pointer               =&gt;# <span class="fstring">"(cons 'ptr ,_3)"</span>
<span class="lineno" id=line278></span>  	;
<span class="lineno" id=line279></span>  
<span class="lineno" id=line280></span>  parameter_type_list
<span class="lineno" id=line281></span>  	:= parameter_list              =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line282></span>  	| parameter_list <span class="fstring">','</span> <span class="fstring">'...'</span>     =&gt;# <span class="fstring">"(cons 'ellipsis _1)"</span>
<span class="lineno" id=line283></span>  	;
<span class="lineno" id=line284></span>  
<span class="lineno" id=line285></span>  parameter_list
<span class="lineno" id=line286></span>  	:= parameter_declaration                   =&gt;# <span class="fstring">"`(,_1)"</span>
<span class="lineno" id=line287></span>  	| parameter_list <span class="fstring">','</span> parameter_declaration =&gt;# <span class="fstring">"(cons _3 _1)"</span>
<span class="lineno" id=line288></span>  	;
<span class="lineno" id=line289></span>  
<span class="lineno" id=line290></span>  parameter_declaration
<span class="lineno" id=line291></span>  	:= declaration_specifiers declarator         =&gt;# <span class="fstring">"`(,_1 ,_2)"</span>
<span class="lineno" id=line292></span>  	| declaration_specifiers abstract_declarator =&gt;# <span class="fstring">"`(,_1 ,_2)"</span>
<span class="lineno" id=line293></span>  	| declaration_specifiers                     =&gt;# <span class="fstring">"`(,_1 ())"</span>
<span class="lineno" id=line294></span>  	;
<span class="lineno" id=line295></span>  
<span class="lineno" id=line296></span>  identifier_list
<span class="lineno" id=line297></span>  	:= sname                                =&gt;# <span class="fstring">"`(,_1)"</span>
<span class="lineno" id=line298></span>  	| identifier_list <span class="fstring">','</span> sname             =&gt;# <span class="fstring">"(cons _3 _1)"</span>
<span class="lineno" id=line299></span>  	;
<span class="lineno" id=line300></span>  
<span class="lineno" id=line301></span>  type_name
<span class="lineno" id=line302></span>  	:= specifier_qualifier_list                    =&gt;# <span class="fstring">"`(,_1 ())"</span>
<span class="lineno" id=line303></span>  	| specifier_qualifier_list abstract_declarator =&gt;# <span class="fstring">"`(,_1 ,_2)"</span>
<span class="lineno" id=line304></span>  	;
<span class="lineno" id=line305></span>  
<span class="lineno" id=line306></span>  abstract_declarator
<span class="lineno" id=line307></span>  	:= pointer
<span class="lineno" id=line308></span>  	| direct_abstract_declarator
<span class="lineno" id=line309></span>  	| pointer direct_abstract_declarator
<span class="lineno" id=line310></span>  	;
<span class="lineno" id=line311></span>  
<span class="lineno" id=line312></span>  direct_abstract_declarator
<span class="lineno" id=line313></span>  	:= <span class="fstring">'('</span> abstract_declarator <span class="fstring">')'</span>
<span class="lineno" id=line314></span>  	| <span class="fstring">'['</span> <span class="fstring">']'</span>
<span class="lineno" id=line315></span>  	| <span class="fstring">'['</span> constant_expression <span class="fstring">']'</span>
<span class="lineno" id=line316></span>  	| direct_abstract_declarator <span class="fstring">'['</span> <span class="fstring">']'</span>
<span class="lineno" id=line317></span>  	| direct_abstract_declarator <span class="fstring">'['</span> constant_expression <span class="fstring">']'</span>
<span class="lineno" id=line318></span>  	| <span class="fstring">'('</span> <span class="fstring">')'</span>
<span class="lineno" id=line319></span>  	| <span class="fstring">'('</span> parameter_type_list <span class="fstring">')'</span>
<span class="lineno" id=line320></span>  	| direct_abstract_declarator <span class="fstring">'('</span> <span class="fstring">')'</span>
<span class="lineno" id=line321></span>  	| direct_abstract_declarator <span class="fstring">'('</span> parameter_type_list <span class="fstring">')'</span>
<span class="lineno" id=line322></span>  	;
<span class="lineno" id=line323></span>  
<span class="lineno" id=line324></span>  initializer
<span class="lineno" id=line325></span>  	:= assignment_expression
<span class="lineno" id=line326></span>  	| <span class="fstring">'{'</span> initializer_list <span class="fstring">'}'</span>
<span class="lineno" id=line327></span>  	| <span class="fstring">'{'</span> initializer_list <span class="fstring">','</span> <span class="fstring">'}'</span>
<span class="lineno" id=line328></span>  	;
<span class="lineno" id=line329></span>  
<span class="lineno" id=line330></span>  initializer_list
<span class="lineno" id=line331></span>  	:= initializer
<span class="lineno" id=line332></span>  	| initializer_list <span class="fstring">','</span> initializer
<span class="lineno" id=line333></span>  	;
<span class="lineno" id=line334></span>  
<span class="lineno" id=line335></span>  statement
<span class="lineno" id=line336></span>  	:= labeled_statement
<span class="lineno" id=line337></span>  	| compound_statement
<span class="lineno" id=line338></span>  	| expression_statement
<span class="lineno" id=line339></span>  	| selection_statement
<span class="lineno" id=line340></span>  	| iteration_statement
<span class="lineno" id=line341></span>  	| jump_statement
<span class="lineno" id=line342></span>  	;
<span class="lineno" id=line343></span>  
<span class="lineno" id=line344></span>  labeled_statement
<span class="lineno" id=line345></span>  	:= sname <span class="fstring">':'</span> statement
<span class="lineno" id=line346></span>  	| <span class="fstring">'case'</span> constant_expression <span class="fstring">':'</span> statement
<span class="lineno" id=line347></span>  	| <span class="fstring">'default'</span> <span class="fstring">':'</span> statement
<span class="lineno" id=line348></span>  	;
<span class="lineno" id=line349></span>  
<span class="lineno" id=line350></span>  compound_statement
<span class="lineno" id=line351></span>  	:= <span class="fstring">'{'</span> <span class="fstring">'}'</span>
<span class="lineno" id=line352></span>  	| <span class="fstring">'{'</span> statement_list <span class="fstring">'}'</span>
<span class="lineno" id=line353></span>  	| <span class="fstring">'{'</span> declaration_list <span class="fstring">'}'</span>
<span class="lineno" id=line354></span>  	| <span class="fstring">'{'</span> declaration_list statement_list <span class="fstring">'}'</span>
<span class="lineno" id=line355></span>  	;
<span class="lineno" id=line356></span>  
<span class="lineno" id=line357></span>  declaration_list
<span class="lineno" id=line358></span>  	:= declaration
<span class="lineno" id=line359></span>  	| declaration_list declaration
<span class="lineno" id=line360></span>  	;
<span class="lineno" id=line361></span>  
<span class="lineno" id=line362></span>  statement_list
<span class="lineno" id=line363></span>  	:= statement
<span class="lineno" id=line364></span>  	| statement_list statement
<span class="lineno" id=line365></span>  	;
<span class="lineno" id=line366></span>  
<span class="lineno" id=line367></span>  expression_statement
<span class="lineno" id=line368></span>  	:= <span class="fstring">';'</span>
<span class="lineno" id=line369></span>  	| expression <span class="fstring">';'</span>
<span class="lineno" id=line370></span>  	;
<span class="lineno" id=line371></span>  
<span class="lineno" id=line372></span>  selection_statement
<span class="lineno" id=line373></span>  	:= <span class="fstring">'if'</span> <span class="fstring">'('</span> expression <span class="fstring">')'</span> statement
<span class="lineno" id=line374></span>  	| <span class="fstring">'if'</span> <span class="fstring">'('</span> expression <span class="fstring">')'</span> statement <span class="fstring">'else'</span> statement
<span class="lineno" id=line375></span>  	| <span class="fstring">'switch'</span> <span class="fstring">'('</span> expression <span class="fstring">')'</span> statement
<span class="lineno" id=line376></span>  	;
<span class="lineno" id=line377></span>  
<span class="lineno" id=line378></span>  iteration_statement
<span class="lineno" id=line379></span>  	:= <span class="fstring">'while'</span> <span class="fstring">'('</span> expression <span class="fstring">')'</span> statement
<span class="lineno" id=line380></span>  	| <span class="fstring">'do'</span> statement <span class="fstring">'while'</span> <span class="fstring">'('</span> expression <span class="fstring">')'</span> <span class="fstring">';'</span>
<span class="lineno" id=line381></span>  	| <span class="fstring">'for'</span> <span class="fstring">'('</span> expression_statement expression_statement <span class="fstring">')'</span> statement
<span class="lineno" id=line382></span>  	| <span class="fstring">'for'</span> <span class="fstring">'('</span> expression_statement expression_statement expression <span class="fstring">')'</span> statement
<span class="lineno" id=line383></span>  	;
<span class="lineno" id=line384></span>  
<span class="lineno" id=line385></span>  jump_statement
<span class="lineno" id=line386></span>  	:= <span class="fstring">'goto'</span> sname <span class="fstring">';'</span>
<span class="lineno" id=line387></span>  	| <span class="fstring">'continue'</span> <span class="fstring">';'</span>
<span class="lineno" id=line388></span>  	| <span class="fstring">'break'</span> <span class="fstring">';'</span>
<span class="lineno" id=line389></span>  	| <span class="fstring">'return'</span> <span class="fstring">';'</span>
<span class="lineno" id=line390></span>  	| <span class="fstring">'return'</span> expression <span class="fstring">';'</span>
<span class="lineno" id=line391></span>  	;
<span class="lineno" id=line392></span>  
<span class="lineno" id=line393></span>  external_declaration
<span class="lineno" id=line394></span>  	:= function_definition
<span class="lineno" id=line395></span>  	| declaration
<span class="lineno" id=line396></span>  	;
<span class="lineno" id=line397></span>  
<span class="lineno" id=line398></span>  function_definition
<span class="lineno" id=line399></span>  	:= declaration_specifiers declarator declaration_list compound_statement
<span class="lineno" id=line400></span>  	| declaration_specifiers declarator compound_statement
<span class="lineno" id=line401></span>  	| declarator declaration_list compound_statement
<span class="lineno" id=line402></span>  	| declarator compound_statement
<span class="lineno" id=line403></span>  	;
<span class="lineno" id=line404></span>  }
</pre></p></div><h2 id='Conditional_forms_h'><img src='/share/src/web/images/minus.gif' id='Conditional forms' onclick='toggle(this,"Conditional_forms_d")' alt='+'/> 2.7 Conditional forms</h2><div id='Conditional_forms_d' style='display:block'>
<pre class='inclusion'>
share/lib/grammar/conditional.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">Basic conditional statements.</span>
<span class="lineno" id=line2></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> conditional 
<span class="lineno" id=line3></span>  {
<span class="lineno" id=line4></span>    block = if_stmt;
<span class="lineno" id=line5></span>  
<span class="lineno" id=line6></span>    <span class="comment">/* Unfortunately we cannot currently use "if sexpr block"
<span class="lineno" id=line7></span>      because this makes if c do .. done and if c do .. else .. done
<span class="lineno" id=line8></span>      ambiguous for some reason i do not fathom, so we have
<span class="lineno" id=line9></span>      to list all the cases separately
<span class="lineno" id=line10></span>    */</span>
<span class="lineno" id=line11></span>    if_stmt := <span class="fstring">"if"</span> sexpr if_stmt =&gt;# <span class="fstring">'`(ast_ifdo ,_sr ,_2 (,_3) ())'</span>;
<span class="lineno" id=line12></span>    if_stmt := <span class="fstring">"if"</span> sexpr loop_stmt =&gt;# <span class="fstring">'`(ast_ifdo ,_sr ,_2 (,_3) ())'</span>;
<span class="lineno" id=line13></span>    if_stmt := <span class="fstring">"if"</span> sexpr match_stmt =&gt;# <span class="fstring">'`(ast_ifdo ,_sr ,_2 (,_3) ())'</span>;
<span class="lineno" id=line14></span>    if_stmt := <span class="fstring">"if"</span> sexpr <span class="fstring">"perform"</span> stmt =&gt;# <span class="fstring">'`(ast_ifdo ,_sr ,_2 (,_4) ())'</span>;
<span class="lineno" id=line15></span>    
<span class="lineno" id=line16></span>    <span class="doccomment">Short form conditional goto statements.</span>
<span class="lineno" id=line17></span>    if_stmt := <span class="fstring">"if"</span> sexpr <span class="fstring">"goto"</span> sexpr <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_ifgoto_indirect ,_sr ,_2 ,_4)"</span>;
<span class="lineno" id=line18></span>    if_stmt := <span class="fstring">"if"</span> sexpr <span class="fstring">"break"</span> sname =&gt;# <span class="fstring">'`(ast_ifgoto ,_sr ,_2 ,(string-append "break_" _4))'</span>;
<span class="lineno" id=line19></span>    if_stmt := <span class="fstring">"if"</span> sexpr <span class="fstring">"continue"</span> sname =&gt;# <span class="fstring">'`(ast_ifgoto ,_sr ,_2 ,(string-append "continue_" _4))'</span>;
<span class="lineno" id=line20></span>    if_stmt := <span class="fstring">"if"</span> sexpr <span class="fstring">"redo"</span> sname =&gt;# <span class="fstring">'`(ast_ifgoto ,_sr ,_2 ,(string-append "redo_" _4))'</span>;
<span class="lineno" id=line21></span>  
<span class="lineno" id=line22></span>    <span class="doccomment">Short form conditional return statement.</span>
<span class="lineno" id=line23></span>    if_stmt := <span class="fstring">"if"</span> sexpr <span class="fstring">"return"</span> <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_ifreturn ,_sr ,_2)"</span>;
<span class="lineno" id=line24></span>    if_stmt := <span class="fstring">"if"</span> sexpr <span class="fstring">"return"</span> sexpr <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_ifdo ,_sr ,_2 ((ast_fun_return ,_sr ,_4)) ())"</span>;
<span class="lineno" id=line25></span>  
<span class="lineno" id=line26></span>    <span class="doccomment">Short form conditional call statement.</span>
<span class="lineno" id=line27></span>    if_stmt := <span class="fstring">"if"</span> sexpr <span class="fstring">"call"</span> sexpr <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line28></span>      <span class="fstring">"`(ast_ifdo ,_sr ,_2 (,(cons 'ast_call (cons _sr (splitapply _4))))())"</span>;
<span class="lineno" id=line29></span>  
<span class="lineno" id=line30></span>    <span class="doccomment">Short form one branch conditional.</span>
<span class="lineno" id=line31></span>    if_stmt := <span class="fstring">"if"</span> sexpr <span class="fstring">"do"</span> stmt* <span class="fstring">"done"</span> =&gt;#
<span class="lineno" id=line32></span>      <span class="fstring">"`(ast_ifdo ,_sr ,_2 ,_4 ())"</span>;
<span class="lineno" id=line33></span>  
<span class="lineno" id=line34></span>    <span class="doccomment">Short form one branch conditional.</span>
<span class="lineno" id=line35></span>    if_stmt := <span class="fstring">"if"</span> sexpr <span class="fstring">"begin"</span> stmt* <span class="fstring">"end"</span> =&gt;#
<span class="lineno" id=line36></span>      <span class="fstring">"(block_stmts (list `(ast_ifdo ,_sr ,_2 ,_4 ())))"</span>;
<span class="lineno" id=line37></span>  
<span class="lineno" id=line38></span>    <span class="doccomment">General conditional chain statement.</span>
<span class="lineno" id=line39></span>    <span class="doccomment">  //$ if condition do</span>
<span class="lineno" id=line40></span>    <span class="doccomment">  ..</span>
<span class="lineno" id=line41></span>    <span class="doccomment">elif condition do</span>
<span class="lineno" id=line42></span>    <span class="doccomment">  .</span>
<span class="lineno" id=line43></span>    <span class="doccomment">  .</span>
<span class="lineno" id=line44></span>    <span class="doccomment">else</span>
<span class="lineno" id=line45></span>    <span class="doccomment"> ..</span>
<span class="lineno" id=line46></span>    <span class="doccomment">done</span>
<span class="lineno" id=line47></span>    if_stmt := <span class="fstring">"if"</span> sexpr <span class="fstring">"do"</span>  stmt* selse_clause <span class="fstring">"done"</span> =&gt;#
<span class="lineno" id=line48></span>      <span class="fstring">"`(ast_ifdo ,_sr ,_2 ,_4 ,_5)"</span>;
<span class="lineno" id=line49></span>  
<span class="lineno" id=line50></span>    if_stmt := <span class="fstring">"if"</span> sexpr <span class="fstring">"begin"</span> stmt* selse_clause <span class="fstring">"end"</span> =&gt;#
<span class="lineno" id=line51></span>      <span class="fstring">"(block_stmts (list `(ast_ifdo ,_sr ,_2 ,_4 ,_5)))"</span>;
<span class="lineno" id=line52></span>  
<span class="lineno" id=line53></span>    <span class="doccomment">General elif clause.</span>
<span class="lineno" id=line54></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> selif_clause := <span class="fstring">"elif"</span> sexpr <span class="fstring">"do"</span> stmt* =&gt;# <span class="fstring">"`(,_2 ,_4)"</span>;
<span class="lineno" id=line55></span>  
<span class="lineno" id=line56></span>    <span class="doccomment">Short form elif return clause.</span>
<span class="lineno" id=line57></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> selif_clause := <span class="fstring">"elif"</span> sexpr <span class="fstring">"return"</span> <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(,_2 ((ast_proc_return ,_sr)))"</span>;
<span class="lineno" id=line58></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> selif_clause := <span class="fstring">"elif"</span> sexpr <span class="fstring">"return"</span> sexpr <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(,_2 ((ast_fun_return ,_sr ,_4)))"</span>;
<span class="lineno" id=line59></span>  
<span class="lineno" id=line60></span>    <span class="doccomment">Short form elif goto clause.</span>
<span class="lineno" id=line61></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> selif_clause := <span class="fstring">"elif"</span> sexpr <span class="fstring">"goto"</span> sexpr <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(,_2 (ast_cgoto ,_sr ,_4))"</span>;
<span class="lineno" id=line62></span>  
<span class="lineno" id=line63></span>  
<span class="lineno" id=line64></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> selif_clauses := selif_clauses selif_clause =&gt;# <span class="fstring">"(cons _2 _1)"</span>; <span class="comment">// Reversed!</span>
<span class="lineno" id=line65></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> selif_clauses := selif_clause =&gt;# <span class="fstring">"`(,_1)"</span>;
<span class="lineno" id=line66></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> selse_clause := selif_clauses <span class="fstring">"else"</span> stmt* =&gt;#
<span class="lineno" id=line67></span>      <span class="fstring">"""
<span class="lineno" id=line68></span>          (let ((f (lambda (result condthn)
<span class="lineno" id=line69></span>            (let ((cond (first condthn)) (thn (second condthn)))
<span class="lineno" id=line70></span>              `((ast_ifdo ,_sr ,cond ,thn ,result))))))
<span class="lineno" id=line71></span>          (fold_left f _3 _1))
<span class="lineno" id=line72></span>      """</span>;
<span class="lineno" id=line73></span>  
<span class="lineno" id=line74></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> selse_clause := <span class="fstring">"else"</span> stmt* =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line75></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> selse_clause := selif_clauses =&gt;#
<span class="lineno" id=line76></span>      <span class="fstring">"""
<span class="lineno" id=line77></span>          (let ((f (lambda (result condthn)
<span class="lineno" id=line78></span>            (let ((cond (first condthn)) (thn (second condthn)))
<span class="lineno" id=line79></span>              `((ast_ifdo ,_sr ,cond ,thn ,result))))))
<span class="lineno" id=line80></span>          (fold_left f () _1))
<span class="lineno" id=line81></span>      """</span>;
<span class="lineno" id=line82></span>  
<span class="lineno" id=line83></span>    <span class="doccomment">helpful error message for invalid if/then syntax on statements</span>
<span class="lineno" id=line84></span>    if_stmt := <span class="fstring">"if"</span> sexpr <span class="fstring">"then"</span>  stmt* <span class="fstring">"endif"</span> =&gt;# <span class="fstring">"""
<span class="lineno" id=line85></span>      (raise (string-append 
<span class="lineno" id=line86></span>          "  Invalid syntax: This instance of 'if/then' is not valid. Try the following instead:\n"
<span class="lineno" id=line87></span>          "    if (condition) do\n"
<span class="lineno" id=line88></span>          "      ...\n"
<span class="lineno" id=line89></span>          "    done\n"))
<span class="lineno" id=line90></span>      """</span>;
<span class="lineno" id=line91></span>  
<span class="lineno" id=line92></span>    <span class="doccomment">helpful error message for invalid if/then/else syntax on statements</span>
<span class="lineno" id=line93></span>    if_stmt := <span class="fstring">"if"</span> sexpr <span class="fstring">"then"</span>  stmt* (<span class="fstring">"else"</span> | <span class="fstring">"elif"</span>) =&gt;# <span class="fstring">"""
<span class="lineno" id=line94></span>      (raise (string-append 
<span class="lineno" id=line95></span>          "  Invalid syntax: This instance of 'if/then/else' is not valid. Try the following instead:\n"
<span class="lineno" id=line96></span>          "    if (condition) do\n"
<span class="lineno" id=line97></span>          "      ...\n"
<span class="lineno" id=line98></span>          "    elif (condition) do\n"
<span class="lineno" id=line99></span>          "      ...\n"
<span class="lineno" id=line100></span>          "    else do\n"
<span class="lineno" id=line101></span>          "      ...\n"
<span class="lineno" id=line102></span>          "    done\n"))
<span class="lineno" id=line103></span>      """</span>;
<span class="lineno" id=line104></span>  
<span class="lineno" id=line105></span>  }
</pre></p><pre class='inclusion'>
share/lib/grammar/control.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">Core control flow operators.</span>
<span class="lineno" id=line2></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> control 
<span class="lineno" id=line3></span>  {
<span class="lineno" id=line4></span>    <span class="doccomment">Call a procedure (verbose).</span>
<span class="lineno" id=line5></span>    block := <span class="fstring">"call"</span> sexpr  <span class="fstring">";"</span> =&gt;# <span class="fstring">"""(cons 'ast_call (cons _sr (splitapply _2)))"""</span>;
<span class="lineno" id=line6></span>    block := <span class="fstring">"call_with_trap"</span> sexpr  <span class="fstring">";"</span> =&gt;# <span class="fstring">"""(cons 'ast_call_with_trap (cons _sr (splitapply _2)))"""</span>;
<span class="lineno" id=line7></span>    block := <span class="fstring">"callcc"</span> sexpr  <span class="fstring">";"</span> =&gt;# <span class="fstring">"""
<span class="lineno" id=line8></span>      (let* 
<span class="lineno" id=line9></span>        (
<span class="lineno" id=line10></span>          (labstring (fresh_name "_callcclab_"))
<span class="lineno" id=line11></span>          (lab (nos labstring))
<span class="lineno" id=line12></span>        )
<span class="lineno" id=line13></span>        `(ast_seq ,_sr 
<span class="lineno" id=line14></span>          (
<span class="lineno" id=line15></span>            (ast_jump ,_sr ,_2 ,lab)
<span class="lineno" id=line16></span>            (ast_label ,_sr ,labstring)
<span class="lineno" id=line17></span>          )
<span class="lineno" id=line18></span>        )
<span class="lineno" id=line19></span>      )
<span class="lineno" id=line20></span>    """</span>;
<span class="lineno" id=line21></span>  
<span class="lineno" id=line22></span>    <span class="doccomment">Procedure return.</span>
<span class="lineno" id=line23></span>    block := <span class="fstring">"return"</span> <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_proc_return ,_sr)"</span>;
<span class="lineno" id=line24></span>  
<span class="lineno" id=line25></span>    <span class="doccomment">Fast procedure return.</span>
<span class="lineno" id=line26></span>    <span class="doccomment">Returns immediately from enclosing procedure with given name.</span>
<span class="lineno" id=line27></span>    block := <span class="fstring">"return"</span> <span class="fstring">"from"</span> sname <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_proc_return_from ,_sr ,_3)"</span>;
<span class="lineno" id=line28></span>  
<span class="lineno" id=line29></span>  
<span class="lineno" id=line30></span>    <span class="doccomment">Procedure explicit tail call.</span>
<span class="lineno" id=line31></span>    <span class="doccomment">Equivalent to a call followed by a return.</span>
<span class="lineno" id=line32></span>    block := <span class="fstring">"jump"</span> sexpr <span class="fstring">";"</span> =&gt;# <span class="fstring">"""(cons 'ast_jump (cons _sr (splitapply _2)))"""</span>;
<span class="lineno" id=line33></span>  
<span class="lineno" id=line34></span>    <span class="doccomment">Function return with value.</span>
<span class="lineno" id=line35></span>    block := <span class="fstring">"return"</span> sexpr <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_fun_return ,_sr ,_2)"</span>;
<span class="lineno" id=line36></span>  
<span class="lineno" id=line37></span>    <span class="doccomment">Generator/iterator exchange with value (restart after yield).</span>
<span class="lineno" id=line38></span>    <span class="doccomment">Yield is like a return, except that re-entering the generator</span>
<span class="lineno" id=line39></span>    <span class="doccomment">will continue on after the yield statement rather that starting</span>
<span class="lineno" id=line40></span>    <span class="doccomment">from the top.</span>
<span class="lineno" id=line41></span>    block := <span class="fstring">"yield"</span> sexpr <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_yield ,_sr ,_2)"</span>;
<span class="lineno" id=line42></span>  
<span class="lineno" id=line43></span>    <span class="doccomment">Special short form procedure self-tail call with argument.</span>
<span class="lineno" id=line44></span>    block := <span class="fstring">"loop"</span> sname sexpr <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_jump ,_sr (ast_name ,_sr ,_2 ()) ,_3)"</span>;
<span class="lineno" id=line45></span>  
<span class="lineno" id=line46></span>    <span class="doccomment">Special short form procedure self-tail call without argument.</span>
<span class="lineno" id=line47></span>    block := <span class="fstring">"loop"</span> sname <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_jump ,_sr (ast_name ,_sr ,_2 ()) (ast_tuple,_sr ()))"</span>;
<span class="lineno" id=line48></span>  
<span class="lineno" id=line49></span>    <span class="doccomment">Stop the program with prejudice and a message.</span>
<span class="lineno" id=line50></span>    block := <span class="fstring">"halt"</span> sstring <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_halt ,_sr ,_2)"</span>;
<span class="lineno" id=line51></span>  
<span class="lineno" id=line52></span>    <span class="doccomment">Label any statement.</span>
<span class="lineno" id=line53></span>    <span class="doccomment">Do not confuse with loop labels.</span>
<span class="lineno" id=line54></span>    stmt := sname <span class="fstring">":&gt;"</span> =&gt;# <span class="fstring">"`(ast_label ,_sr ,_1)"</span>;
<span class="lineno" id=line55></span>  
<span class="lineno" id=line56></span>    <span class="doccomment">Unconditional goto label.</span>
<span class="lineno" id=line57></span>    stmt := <span class="fstring">"goto"</span> sexpr <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_goto_indirect ,_sr ,_2)"</span>;
<span class="lineno" id=line58></span>  
<span class="lineno" id=line59></span>    <span class="doccomment">Unconditional goto expression.</span>
<span class="lineno" id=line60></span>    block := <span class="fstring">"goto-indirect"</span> sexpr <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_goto_indirect ,_sr ,_2)"</span>;
<span class="lineno" id=line61></span>  
<span class="lineno" id=line62></span>  }
<span class="lineno" id=line63></span>  
</pre></p></div><h2 id='Executable_support_h'><img src='/share/src/web/images/minus.gif' id='Executable support' onclick='toggle(this,"Executable_support_d")' alt='+'/> 2.8 Executable support</h2><div id='Executable_support_d' style='display:block'>
<pre class='inclusion'>
share/lib/grammar/executable.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">Special executable forms.</span>
<span class="lineno" id=line2></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> executable {
<span class="lineno" id=line3></span>    <span class="big_keyword" title="specify requirements">requires</span> statements;
<span class="lineno" id=line4></span>  
<span class="lineno" id=line5></span>    stmt := <span class="fstring">"type-error"</span> stmt =&gt;# <span class="fstring">"`(ast_type_error ,_sr ,_2)"</span>;
<span class="lineno" id=line6></span>    stmt := <span class="fstring">"type-assert"</span> stmt =&gt;# <span class="fstring">"`(ast_type_assert ,_sr ,_2)"</span>;
<span class="lineno" id=line7></span>  
<span class="lineno" id=line8></span>    <span class="doccomment">System service call.</span>
<span class="lineno" id=line9></span>    stmt := <span class="fstring">"_svc"</span> sname =&gt;# <span class="fstring">"`(ast_svc ,_sr ,_2)"</span>;
<span class="lineno" id=line10></span>  
<span class="lineno" id=line11></span>    <span class="doccomment">Assignment expression.</span>
<span class="lineno" id=line12></span>    stmt := sassignexpr <span class="fstring">";"</span> =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line13></span>  
<span class="lineno" id=line14></span>    <span class="doccomment">Debug trace expression.</span>
<span class="lineno" id=line15></span>    stmt := <span class="fstring">"trace"</span> sname sstring =&gt;# <span class="fstring">"`(ast_trace ,_sr ,_2 ,_3)"</span>;
<span class="lineno" id=line16></span>  
<span class="lineno" id=line17></span>    <span class="doccomment">Call expression.</span>
<span class="lineno" id=line18></span>    <span class="doccomment">Short form of "call f a;" is just "f a;"</span>
<span class="lineno" id=line19></span>    <span class="doccomment">Short form of "call f ();" is just "f"</span>
<span class="lineno" id=line20></span>    stmt := sexpr <span class="fstring">";"</span> =&gt;# <span class="fstring">"(cons 'ast_call (cons _sr (splitapply _1)))"</span>;
<span class="lineno" id=line21></span>  
<span class="lineno" id=line22></span>    <span class="doccomment">Template replacement index.</span>
<span class="lineno" id=line23></span>    stmt := <span class="fstring">"??"</span> sinteger <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_seq ,_sr (PARSER_ARGUMENT ,_2))"</span>;
<span class="lineno" id=line24></span>  }
<span class="lineno" id=line25></span>  
</pre></p></div><h2 id='Master_DSSL_dependency_list._h'><img src='/share/src/web/images/minus.gif' id='Master DSSL dependency list.' onclick='toggle(this,"Master_DSSL_dependency_list._d")' alt='+'/> 2.9 Master DSSL dependency list.</h2><div id='Master_DSSL_dependency_list._d' style='display:block'>
<p>Defines the standard felix grammar by specifying
all the DSSLs required for it.
</p><pre class='inclusion'>
share/lib/grammar/felix.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> felix {
<span class="lineno" id=line2></span>    <span class="big_keyword" title="specify requirements">requires</span>
<span class="lineno" id=line3></span>      <span class="library" title="functional, singly linked list">list</span>,
<span class="lineno" id=line4></span>      blocks,
<span class="lineno" id=line5></span>      lexer,
<span class="lineno" id=line6></span>      statements,
<span class="lineno" id=line7></span>      type_decls,
<span class="lineno" id=line8></span>      variables,
<span class="lineno" id=line9></span>      executable,
<span class="lineno" id=line10></span>      assignment,
<span class="lineno" id=line11></span>      control,
<span class="lineno" id=line12></span>      exceptions,
<span class="lineno" id=line13></span>      conditional,
<span class="lineno" id=line14></span>      loops,
<span class="lineno" id=line15></span>      pfor, 
<span class="lineno" id=line16></span>      assertions,
<span class="lineno" id=line17></span>      namespaces,
<span class="lineno" id=line18></span>      requirements,
<span class="lineno" id=line19></span>      expressions,
<span class="lineno" id=line20></span>      types,
<span class="lineno" id=line21></span>      brackets,
<span class="lineno" id=line22></span>      texsyms,
<span class="lineno" id=line23></span>      functions,
<span class="lineno" id=line24></span>      patterns,
<span class="lineno" id=line25></span>      cbind,
<span class="lineno" id=line26></span>      regexps,
<span class="lineno" id=line27></span>      macros,
<span class="lineno" id=line28></span>      plugins,
<span class="lineno" id=line29></span>      debug,
<span class="lineno" id=line30></span>      chips
<span class="lineno" id=line31></span>    ;
<span class="lineno" id=line32></span>  }
</pre></p></div><h2 id='Function_forms_h'><img src='/share/src/web/images/minus.gif' id='Function forms' onclick='toggle(this,"Function_forms_d")' alt='+'/> 2.10 Function forms</h2><div id='Function_forms_d' style='display:block'>
<pre class='inclusion'>
share/lib/grammar/functions.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">General functional forms.</span>
<span class="lineno" id=line2></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> functions {
<span class="lineno" id=line3></span>    <span class="big_keyword" title="specify requirements">requires</span> expressions;
<span class="lineno" id=line4></span>  
<span class="lineno" id=line5></span>    <span class="doccomment">Anonymous function (lamda).</span>
<span class="lineno" id=line6></span>    satom := sadjectives <span class="fstring">"fun"</span> stvarlist slambda_fun_args fun_return_type <span class="fstring">"="</span>? scompound =&gt;#
<span class="lineno" id=line7></span>      <span class="fstring">"""
<span class="lineno" id=line8></span>      `(ast_lambda ,_sr (,_3 ,_4 ,(first (first _5)) ,_7))
<span class="lineno" id=line9></span>      """</span>;
<span class="lineno" id=line10></span>  
<span class="lineno" id=line11></span>    <span class="doccomment">Anonymous function (lamda).</span>
<span class="lineno" id=line12></span>    x[slambda_pri] := sadjectives <span class="fstring">"fun"</span> stvarlist slambda_fun_args fun_return_type <span class="fstring">"=&gt;"</span> sexpr =&gt;#
<span class="lineno" id=line13></span>      <span class="fstring">"""
<span class="lineno" id=line14></span>      `(ast_lambda ,_sr (,_3 ,_4 ,(first (first _5)) ((ast_fun_return ,_sr ,_7))))
<span class="lineno" id=line15></span>      """</span>;
<span class="lineno" id=line16></span>  
<span class="lineno" id=line17></span>    <span class="doccomment">Anonymous function (lamda). Linear</span>
<span class="lineno" id=line18></span>    x[slambda_pri] := sadjectives <span class="fstring">"fun"</span> stvarlist slambda_fun_args fun_return_type <span class="fstring">"=&gt;."</span> sexpr =&gt;#
<span class="lineno" id=line19></span>      <span class="fstring">"""
<span class="lineno" id=line20></span>      `(ast_linearlambda ,_sr (,_3 ,_4 ,(first (first _5)) ((ast_fun_return ,_sr ,_7))))
<span class="lineno" id=line21></span>      """</span>;
<span class="lineno" id=line22></span>  
<span class="lineno" id=line23></span>  
<span class="lineno" id=line24></span>    <span class="doccomment">Anonymous generator (lamda).</span>
<span class="lineno" id=line25></span>    satom := sadjectives <span class="fstring">"gen"</span> stvarlist slambda_fun_args fun_return_type <span class="fstring">"="</span>? scompound =&gt;#
<span class="lineno" id=line26></span>      <span class="fstring">"""
<span class="lineno" id=line27></span>      `(ast_generator ,_sr (,_3 ,_4 ,(first (first _5)) ,_7))
<span class="lineno" id=line28></span>      """</span>;
<span class="lineno" id=line29></span>  
<span class="lineno" id=line30></span>    <span class="doccomment">Anonymous generator (lamda).</span>
<span class="lineno" id=line31></span>    x[slambda_pri] := sadjectives <span class="fstring">"gen"</span> stvarlist slambda_fun_args fun_return_type <span class="fstring">"=&gt;"</span> sexpr =&gt;#
<span class="lineno" id=line32></span>      <span class="fstring">"""
<span class="lineno" id=line33></span>      `(ast_generator ,_sr (,_3 ,_4 ,(first (first _5)) ((ast_fun_return ,_sr ,_7))))
<span class="lineno" id=line34></span>      """</span>;
<span class="lineno" id=line35></span>  
<span class="lineno" id=line36></span>  
<span class="lineno" id=line37></span>    <span class="doccomment">Anonymous procedure (lamda).</span>
<span class="lineno" id=line38></span>    satom := sadjectives <span class="fstring">"proc"</span> stvarlist slambda_fun_args scompound =&gt;#
<span class="lineno" id=line39></span>      <span class="fstring">"""
<span class="lineno" id=line40></span>      `(ast_lambda ,_sr (,_3 ,_4 (ast_void ,_sr) ,_5))
<span class="lineno" id=line41></span>      """</span>;
<span class="lineno" id=line42></span>  
<span class="lineno" id=line43></span>    <span class="doccomment">Anonymous procedure (lamda).</span>
<span class="lineno" id=line44></span>    satom  := sadjectives <span class="fstring">"proc"</span> stvarlist scompound =&gt;#
<span class="lineno" id=line45></span>      <span class="fstring">"""
<span class="lineno" id=line46></span>      `(ast_lambda ,_sr (,_3 ((() none)) (ast_void ,_sr) ,_4))
<span class="lineno" id=line47></span>      """</span>;
<span class="lineno" id=line48></span>  
<span class="lineno" id=line49></span>    <span class="doccomment">Anonymous object constructor (lamda).</span>
<span class="lineno" id=line50></span>    <span class="doccomment">UGLY.</span>
<span class="lineno" id=line51></span>    satom := sadjectives <span class="fstring">"object"</span> stvarlist slambda_fun_args fun_return_type <span class="fstring">"="</span>? scompound =&gt;#
<span class="lineno" id=line52></span>      <span class="fstring">"""
<span class="lineno" id=line53></span>      `(ast_object ,_sr (,_3 ,_4 ,(first (first _5)) ,_7))
<span class="lineno" id=line54></span>      """</span>;
<span class="lineno" id=line55></span>  
<span class="lineno" id=line56></span>    <span class="doccomment">Function adjective (prefix property) inline.</span>
<span class="lineno" id=line57></span>    sadjective := <span class="fstring">"inline"</span> =&gt;# <span class="fstring">"'InlineFunction"</span>;
<span class="lineno" id=line58></span>  
<span class="lineno" id=line59></span>    <span class="doccomment">Function adjective (prefix property) noinline.</span>
<span class="lineno" id=line60></span>    sadjective := <span class="fstring">"noinline"</span> =&gt;# <span class="fstring">"'NoInlineFunction"</span>;
<span class="lineno" id=line61></span>    <span class="comment">//sadjective := "static" =&gt;# "'Static";</span>
<span class="lineno" id=line62></span>  
<span class="lineno" id=line63></span>    <span class="doccomment">Function adjective (prefix property) extern.</span>
<span class="lineno" id=line64></span>    sadjective := <span class="fstring">"extern"</span> =&gt;# <span class="fstring">"'NoInlineFunction"</span>;
<span class="lineno" id=line65></span>  
<span class="lineno" id=line66></span>    <span class="doccomment">Function adjective (prefix property) virtual.</span>
<span class="lineno" id=line67></span>    <span class="doccomment">In classes only. Specifies an overrideable function.</span>
<span class="lineno" id=line68></span>    sadjective := <span class="fstring">"virtual"</span> =&gt;# <span class="fstring">"'Virtual"</span>;
<span class="lineno" id=line69></span>  
<span class="lineno" id=line70></span>    <span class="doccomment">Function dependent on its arguments only,</span>
<span class="lineno" id=line71></span>    <span class="doccomment">not dependent on any variables in its enclosing context.</span>
<span class="lineno" id=line72></span>    sadjective := <span class="fstring">"pure"</span> =&gt;# <span class="fstring">"'Pure"</span>;
<span class="lineno" id=line73></span>  
<span class="lineno" id=line74></span>    <span class="doccomment">Function which fails  to evaluate argument </span>
<span class="lineno" id=line75></span>    <span class="doccomment">if and only if its argument fails, </span>
<span class="lineno" id=line76></span>    <span class="doccomment">i.e. f (error) = error</span>
<span class="lineno" id=line77></span>    sadjective := <span class="fstring">"strict"</span> =&gt;# <span class="fstring">"'Strict"</span>;
<span class="lineno" id=line78></span>  
<span class="lineno" id=line79></span>    <span class="doccomment">Function which fails  to evaluate argument </span>
<span class="lineno" id=line80></span>    <span class="doccomment">if and only if its argument fails, </span>
<span class="lineno" id=line81></span>    <span class="doccomment">i.e. f (error) = error</span>
<span class="lineno" id=line82></span>    sadjective := <span class="fstring">"nonstrict"</span> =&gt;# <span class="fstring">"'NonStrict"</span>;
<span class="lineno" id=line83></span>  
<span class="lineno" id=line84></span>  
<span class="lineno" id=line85></span>    <span class="doccomment">Function may be dependent on variables in its enclosing context.</span>
<span class="lineno" id=line86></span>    sadjective := <span class="fstring">"impure"</span> =&gt;# <span class="fstring">"'Impure"</span>;
<span class="lineno" id=line87></span>  
<span class="lineno" id=line88></span>    <span class="doccomment">Function returns a result for all argument values.</span>
<span class="lineno" id=line89></span>    sadjective := <span class="fstring">"total"</span> =&gt;# <span class="fstring">"'Total"</span>;
<span class="lineno" id=line90></span>  
<span class="lineno" id=line91></span>    <span class="doccomment">Function may fail for some argument values.</span>
<span class="lineno" id=line92></span>    <span class="doccomment">Equivalent to a function with a non-tautologous but unknown pre-condition.</span>
<span class="lineno" id=line93></span>    sadjective := <span class="fstring">"partial"</span> =&gt;# <span class="fstring">"'Partial"</span>;
<span class="lineno" id=line94></span>  
<span class="lineno" id=line95></span>    <span class="doccomment">Specifies a method, in an object definition only.</span>
<span class="lineno" id=line96></span>    sadjective := <span class="fstring">"method"</span> =&gt;# <span class="fstring">"'Method"</span>;
<span class="lineno" id=line97></span>  
<span class="lineno" id=line98></span>    <span class="doccomment">Specifies function is to be exported under its Felix name.</span>
<span class="lineno" id=line99></span>    <span class="doccomment">Function must be top level and non-polymorphic.</span>
<span class="lineno" id=line100></span>    <span class="doccomment">Top level means the global space or a non-polymorphic class</span>
<span class="lineno" id=line101></span>    <span class="doccomment">nested in a top level space (recursively).</span>
<span class="lineno" id=line102></span>    sadjective := <span class="fstring">"export"</span> =&gt;# <span class="fstring">"'Export"</span>;
<span class="lineno" id=line103></span>    sadjective := <span class="fstring">"export"</span> sstring =&gt;# <span class="fstring">"`(NamedExport ,_2)"</span>;
<span class="lineno" id=line104></span>  
<span class="lineno" id=line105></span>    sadjectives := sadjective* =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line106></span>  
<span class="lineno" id=line107></span>    slambda_fun_arg := <span class="fstring">"("</span> sparameter_comma_list <span class="fstring">"when"</span> sexpr <span class="fstring">")"</span> =&gt;# <span class="fstring">"`(,_2 (some ,_4))"</span>;
<span class="lineno" id=line108></span>    slambda_fun_arg := <span class="fstring">"("</span> sparameter_comma_list <span class="fstring">")"</span> =&gt;# <span class="fstring">"`(,_2 none)"</span>;
<span class="lineno" id=line109></span>    slambda_fun_args := slambda_fun_arg+ =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line110></span>  
<span class="lineno" id=line111></span>    <span class="doccomment">Function return type specification with post-condition.</span>
<span class="lineno" id=line112></span>    fun_return_type := <span class="fstring">":"</span> stypeexpr <span class="fstring">"expect"</span> sexpr =&gt;# <span class="fstring">"`((,_2 (some ,_4)) ,dflteffects)"</span>;
<span class="lineno" id=line113></span>    fun_return_type := <span class="fstring">":"</span> <span class="fstring">"["</span> stypeexpr <span class="fstring">"]"</span> stypeexpr <span class="fstring">"expect"</span> sexpr =&gt;# <span class="fstring">"`((,_5 (some ,_7)) ,_3)"</span>;
<span class="lineno" id=line114></span>  
<span class="lineno" id=line115></span>    <span class="doccomment">Function return type specification without post-condition.</span>
<span class="lineno" id=line116></span>    fun_return_type := <span class="fstring">":"</span> stypeexpr =&gt;# <span class="fstring">"`((,_2 none) ,dflteffects)"</span>;
<span class="lineno" id=line117></span>    fun_return_type := <span class="fstring">":"</span> <span class="fstring">"["</span> stypeexpr <span class="fstring">"]"</span> stypeexpr =&gt;# <span class="fstring">"`((,_5 none) ,_3)"</span>;
<span class="lineno" id=line118></span>  
<span class="lineno" id=line119></span>    <span class="doccomment">Function return postcondition without type.</span>
<span class="lineno" id=line120></span>    fun_return_type := <span class="fstring">"expect"</span> sexpr =&gt;# <span class="fstring">"`((typ_none (some ,_2)) ,dflteffects)"</span>;
<span class="lineno" id=line121></span>    fun_return_type := <span class="fstring">":"</span> <span class="fstring">"["</span> stypeexpr <span class="fstring">"]"</span> <span class="fstring">"expect"</span> sexpr =&gt;# <span class="fstring">"`((typ_none (some ,_6)) ,_3)"</span>;
<span class="lineno" id=line122></span>  
<span class="lineno" id=line123></span>    <span class="doccomment">No return type.</span>
<span class="lineno" id=line124></span>    fun_return_type := <span class="fstring">":"</span> <span class="fstring">"["</span> stypeexpr <span class="fstring">"]"</span> =&gt;# <span class="fstring">"`((typ_none none) ,_3)"</span>;
<span class="lineno" id=line125></span>    fun_return_type := sepsilon =&gt;# <span class="fstring">"`((typ_none none) ,dflteffects)"</span>;
<span class="lineno" id=line126></span>  
<span class="lineno" id=line127></span>    <span class="doccomment">Object factory return type.</span>
<span class="lineno" id=line128></span>    object_return_type := stypeexpr =&gt;# <span class="fstring">"`(,_1 none)"</span>;
<span class="lineno" id=line129></span>  
<span class="lineno" id=line130></span>    <span class="doccomment">Object invariant</span>
<span class="lineno" id=line131></span>    sfunction := <span class="fstring">"invariant"</span> sexpr <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_invariant, _sr, _2)"</span>;
<span class="lineno" id=line132></span>  
<span class="lineno" id=line133></span>    <span class="doccomment">Function parameter with type and default value.</span>
<span class="lineno" id=line134></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sparameter := sparam_qual sname <span class="fstring">":"</span> t[sarrow_pri] <span class="fstring">"="</span> x[sor_condition_pri] =&gt;# <span class="fstring">"`(,_sr ,_1 ,_2 ,_4 (some ,_6))"</span>;
<span class="lineno" id=line135></span>  
<span class="lineno" id=line136></span>    <span class="doccomment">Function parameter with type.</span>
<span class="lineno" id=line137></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sparameter := sparam_qual sname <span class="fstring">":"</span> t[sarrow_pri] =&gt;# <span class="fstring">"`(,_sr ,_1 ,_2 ,_4 none)"</span>;
<span class="lineno" id=line138></span>   
<span class="lineno" id=line139></span>    <span class="doccomment">Function parameter without type.</span>
<span class="lineno" id=line140></span>    <span class="doccomment">Defaults to polymorphic in unnamed type variable.</span>
<span class="lineno" id=line141></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sparameter := sparam_qual sname =&gt;# <span class="fstring">"`(,_sr ,_1 ,_2 typ_none none)"</span>;
<span class="lineno" id=line142></span>  
<span class="lineno" id=line143></span>    <span class="doccomment">Empty parameter tuple.</span>
<span class="lineno" id=line144></span>    <span class="comment">//private sparameter_comma_list = list::commalist0&lt;sparameter&gt;;</span>
<span class="lineno" id=line145></span>  
<span class="lineno" id=line146></span>    <span class="comment">// parameter list including nested params</span>
<span class="lineno" id=line147></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sxparam := sparameter =&gt;# <span class="fstring">"`(Satom ,_1)"</span>;
<span class="lineno" id=line148></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sxparam := <span class="fstring">"("</span> <span class="library" title="functional, singly linked list">list</span>::commalist0&lt;sxparam&gt; <span class="fstring">")"</span> =&gt;# <span class="fstring">"`(Slist ,_2)"</span>;
<span class="lineno" id=line149></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sparameter_comma_list := <span class="library" title="functional, singly linked list">list</span>::commalist0&lt;sxparam&gt; =&gt;# <span class="fstring">"`(Slist ,_1)"</span>;
<span class="lineno" id=line150></span>  
<span class="lineno" id=line151></span>    <span class="doccomment">Parameter qualifier: val.</span>
<span class="lineno" id=line152></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sparam_qual := <span class="fstring">"val"</span> =&gt;# <span class="fstring">"'PVal"</span>;
<span class="lineno" id=line153></span>  
<span class="lineno" id=line154></span>    <span class="doccomment">Parameter qualifier: var.</span>
<span class="lineno" id=line155></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sparam_qual := <span class="fstring">"var"</span> =&gt;# <span class="fstring">"'PVar"</span>;
<span class="lineno" id=line156></span>  
<span class="lineno" id=line157></span>    <span class="doccomment">Default parameter qualifier is val.</span>
<span class="lineno" id=line158></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sparam_qual := sepsilon =&gt;# <span class="fstring">"'PDef"</span>;
<span class="lineno" id=line159></span>  
<span class="lineno" id=line160></span>    <span class="doccomment">Function tuple parameter with pre-condition.</span>
<span class="lineno" id=line161></span>    sfun_arg :=  <span class="fstring">"("</span> sparameter_comma_list <span class="fstring">"when"</span> sexpr <span class="fstring">")"</span> =&gt;# <span class="fstring">"`(,_2 (some ,_4))"</span>;
<span class="lineno" id=line162></span>  
<span class="lineno" id=line163></span>    <span class="doccomment">Function tuple parameter without pre-condition.</span>
<span class="lineno" id=line164></span>    sfun_arg :=  <span class="fstring">"("</span> sparameter_comma_list <span class="fstring">")"</span> =&gt;# <span class="fstring">"`(,_2 none)"</span>;
<span class="lineno" id=line165></span>  
<span class="lineno" id=line166></span>    <span class="doccomment">Short form function parameter single polymorphic variable.</span>
<span class="lineno" id=line167></span>    sfun_arg :=  sname =&gt;# <span class="fstring">"`(((Satom (,_sr PVal ,_1 typ_none none))) none)"</span>;
<span class="lineno" id=line168></span>  
<span class="lineno" id=line169></span>    <span class="doccomment">Function binder: C function.</span>
<span class="lineno" id=line170></span>    <span class="doccomment">A function with C function type.</span>
<span class="lineno" id=line171></span>    sfun_kind := <span class="fstring">"cfun"</span> =&gt;# <span class="fstring">"'CFunction"</span>;
<span class="lineno" id=line172></span>  
<span class="lineno" id=line173></span>    <span class="doccomment">Function binder: Generator.</span>
<span class="lineno" id=line174></span>    <span class="doccomment">A function with side effects.</span>
<span class="lineno" id=line175></span>    sfun_kind := <span class="fstring">"gen"</span> =&gt;# <span class="fstring">"'Generator"</span>;
<span class="lineno" id=line176></span>  
<span class="lineno" id=line177></span>    <span class="doccomment">Function binder: Function.</span>
<span class="lineno" id=line178></span>    <span class="doccomment">A function without side-effects.</span>
<span class="lineno" id=line179></span>    sfun_kind := <span class="fstring">"fun"</span> =&gt;# <span class="fstring">"'Function"</span>;
<span class="lineno" id=line180></span>  
<span class="lineno" id=line181></span>    stmt := sfunction =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line182></span>  
<span class="lineno" id=line183></span>    <span class="doccomment">General function definition. Multiple tuple arguments, body is expression.</span>
<span class="lineno" id=line184></span>    <span class="doccomment">Example:</span>
<span class="lineno" id=line185></span>    <span class="doccomment"></span>
<span class="lineno" id=line186></span>    <span class="doccomment">inline fun f (x:int when x&gt;0) (y:long when y&gt;0l) : long expect result &gt; 0l =&gt; x.long + y;</span>
<span class="lineno" id=line187></span>    sfunction := sadjectives sfun_kind sdeclname sfun_arg* fun_return_type <span class="fstring">"=&gt;"</span> sexpr <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line188></span>      <span class="fstring">"""
<span class="lineno" id=line189></span>        (begin ;;(display "GENERAL FUNCTION")
<span class="lineno" id=line190></span>        (let ((body `((ast_fun_return ,_sr ,_7))))
<span class="lineno" id=line191></span>        `(ast_curry_effects ,_sr ,(first _3) ,(second _3) ,_4 ,(first _5) ,(second _5) ,(cal_funkind _1 _2) ,_1 ,body))
<span class="lineno" id=line192></span>        )
<span class="lineno" id=line193></span>      """</span>;
<span class="lineno" id=line194></span>  
<span class="lineno" id=line195></span>    sfunction := sadjectives sfun_kind sdeclname sfun_arg* fun_return_type <span class="fstring">"=&gt;."</span> sexpr <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line196></span>      <span class="fstring">"""
<span class="lineno" id=line197></span>        (begin ;;(display "LINEAR FUNCTION")
<span class="lineno" id=line198></span>        (let ((body `((ast_fun_return ,_sr ,_7))))
<span class="lineno" id=line199></span>        `(ast_curry_effects ,_sr ,(first _3) ,(second _3) ,_4 ,(first _5) ,(second _5) ,(cal_funkind _1 _2) ,(cons 'LinearFunction _1) ,body))
<span class="lineno" id=line200></span>        )
<span class="lineno" id=line201></span>      """</span>;
<span class="lineno" id=line202></span>  
<span class="lineno" id=line203></span>  
<span class="lineno" id=line204></span>    <span class="doccomment">General function definition. Multiple tuple arguments, body of statements.</span>
<span class="lineno" id=line205></span>    <span class="doccomment">inline fun f (x:int when x&gt;0) (y:long when y&gt;0l) : long expect result &gt; 0l { return x.long + y; }</span>
<span class="lineno" id=line206></span>    sfunction := sadjectives sfun_kind sdeclname sfun_arg* fun_return_type <span class="fstring">"="</span>? scompound =&gt;#
<span class="lineno" id=line207></span>      <span class="fstring">"""
<span class="lineno" id=line208></span>        (begin ;;(display "COMPOUND FUNCTION")
<span class="lineno" id=line209></span>        `(ast_curry_effects ,_sr ,(first _3) ,(second _3) ,_4 ,(first _5) ,(second _5) ,(cal_funkind _1 _2) ,_1 ,_7))
<span class="lineno" id=line210></span>      """</span>;
<span class="lineno" id=line211></span>  
<span class="lineno" id=line212></span>    <span class="doccomment">Object factory definition with interface type.</span>
<span class="lineno" id=line213></span>    sfunction := <span class="fstring">"object"</span> sdeclname sfun_arg* <span class="fstring">"implements"</span> object_return_type <span class="fstring">"="</span>? scompound =&gt;#
<span class="lineno" id=line214></span>      <span class="fstring">"""
<span class="lineno" id=line215></span>        `(ast_curry ,_sr ,(first _2) ,(second _2) ,_3 ,_5 Object () ,_7)
<span class="lineno" id=line216></span>      """</span>;
<span class="lineno" id=line217></span>  
<span class="lineno" id=line218></span>    <span class="doccomment">Object factory definition without interface type.</span>
<span class="lineno" id=line219></span>    sfunction := <span class="fstring">"object"</span> sdeclname sfun_arg*  <span class="fstring">"="</span>? scompound =&gt;#
<span class="lineno" id=line220></span>      <span class="fstring">"""
<span class="lineno" id=line221></span>        `(ast_curry ,_sr ,(first _2) ,(second _2) ,_3 (typ_none none) Object () ,_5)
<span class="lineno" id=line222></span>      """</span>;
<span class="lineno" id=line223></span>  
<span class="lineno" id=line224></span>    <span class="doccomment">Object factory definition with inherited methods and</span>
<span class="lineno" id=line225></span>    <span class="doccomment">interface type.</span>
<span class="lineno" id=line226></span>    sfunction := 
<span class="lineno" id=line227></span>      <span class="fstring">"object"</span> sdeclname sfun_arg* <span class="fstring">"extends"</span> expr_comma_list 
<span class="lineno" id=line228></span>      <span class="fstring">"implements"</span> object_return_type <span class="fstring">"="</span>? scompound 
<span class="lineno" id=line229></span>    =&gt;#
<span class="lineno" id=line230></span>      <span class="fstring">"""
<span class="lineno" id=line231></span>     (begin ;; (display "object function1\n")
<span class="lineno" id=line232></span>     (let*  
<span class="lineno" id=line233></span>       (
<span class="lineno" id=line234></span>         (d `(ast_object ,_sr (,dfltvs (,unitparam) typ_none ,_9)))  ;; extension function
<span class="lineno" id=line235></span>         (a `(ast_apply ,_sr (,d ()))) ;; applied to unit
<span class="lineno" id=line236></span>         (x `(ast_extension ,_sr ,_5 ,a)) ;; actual extension expression
<span class="lineno" id=line237></span>         (retst `(ast_fun_return ,_sr ,x))
<span class="lineno" id=line238></span>         (body `(,retst))
<span class="lineno" id=line239></span>       )
<span class="lineno" id=line240></span>       `(ast_curry ,_sr ,(first _2) ,(second _2) ,_3 ,_7 Function () ,body)
<span class="lineno" id=line241></span>      ))
<span class="lineno" id=line242></span>      """</span>;
<span class="lineno" id=line243></span>  
<span class="lineno" id=line244></span>    <span class="doccomment">Object factory definition with inherited methods.</span>
<span class="lineno" id=line245></span>    sfunction := <span class="fstring">"object"</span> sdeclname sfun_arg*  <span class="fstring">"extends"</span> expr_comma_list <span class="fstring">"="</span> scompound =&gt;#
<span class="lineno" id=line246></span>      <span class="fstring">"""
<span class="lineno" id=line247></span>     (begin ;; (display "object function2\n")
<span class="lineno" id=line248></span>     (let*  
<span class="lineno" id=line249></span>       (
<span class="lineno" id=line250></span>         (noretype `(typ_none none))
<span class="lineno" id=line251></span>         (d `(ast_object ,_sr (,dfltvs (,unitparam) typ_none ,_7)))  ;; extension function
<span class="lineno" id=line252></span>         (a `(ast_apply ,_sr (,d ()))) ;; applied to unit
<span class="lineno" id=line253></span>         (x `(ast_extension ,_sr ,_5 ,a)) ;; actual extension expression
<span class="lineno" id=line254></span>         (retst `(ast_fun_return ,_sr ,x))
<span class="lineno" id=line255></span>         (body `(,retst))
<span class="lineno" id=line256></span>       )
<span class="lineno" id=line257></span>       `(ast_curry ,_sr ,(first _2) ,(second _2) ,_3 ,noretype Function () ,body)
<span class="lineno" id=line258></span>      ))
<span class="lineno" id=line259></span>      """</span>;
<span class="lineno" id=line260></span>  
<span class="lineno" id=line261></span>  
<span class="lineno" id=line262></span>    sopt_cstring := <span class="fstring">"="</span> scode_spec =&gt;# <span class="fstring">"`(some ,_2)"</span>;
<span class="lineno" id=line263></span>    sopt_cstring := sepsilon =&gt;# <span class="fstring">"'none"</span>;
<span class="lineno" id=line264></span>  
<span class="lineno" id=line265></span>    <span class="doccomment">Short form function definition. Example:</span>
<span class="lineno" id=line266></span>    <span class="doccomment">  //$ fun f : int -&gt; int = | 0 =&gt; 0 | _ =&gt; 1;</span>
<span class="lineno" id=line267></span>  <span class="comment">/*
<span class="lineno" id=line268></span>    sfunction := sadjectives sfun_kind sdeclname fun_return_type "=" smatching+ ";" =&gt;#
<span class="lineno" id=line269></span>      """
<span class="lineno" id=line270></span>       (let
<span class="lineno" id=line271></span>         (
<span class="lineno" id=line272></span>          (t (first _4))
<span class="lineno" id=line273></span>          (traint (second _4))
<span class="lineno" id=line274></span>         )
<span class="lineno" id=line275></span>        (begin ;;(display "MATCHING ftype=")(display t)(display "\\n")
<span class="lineno" id=line276></span>        (if (eq? 'typ_arrow (first t))
<span class="lineno" id=line277></span>          (let
<span class="lineno" id=line278></span>            (
<span class="lineno" id=line279></span>              (argt (caadr t))
<span class="lineno" id=line280></span>              (ret (cadadr t))
<span class="lineno" id=line281></span>              (body `((ast_fun_return ,_sr (ast_match ,_sr (,(noi '_a) ,_6)))))
<span class="lineno" id=line282></span>            )
<span class="lineno" id=line283></span>            `(ast_curry ,_sr ,(first _3) ,(second _3)
<span class="lineno" id=line284></span>              (
<span class="lineno" id=line285></span>                (((,_sr PVal _a ,argt none)) none)
<span class="lineno" id=line286></span>              )
<span class="lineno" id=line287></span>              (,ret ,traint)
<span class="lineno" id=line288></span>              ,(cal_funkind _1 _2) ,_1 ,body)
<span class="lineno" id=line289></span>          )
<span class="lineno" id=line290></span>          (begin (display "ERROR MATCHINGS FUNDEF ")(display _sr) 'ERROR)
<span class="lineno" id=line291></span>         )
<span class="lineno" id=line292></span>         )
<span class="lineno" id=line293></span>       )
<span class="lineno" id=line294></span>      """;
<span class="lineno" id=line295></span>  */</span>
<span class="lineno" id=line296></span>  
<span class="lineno" id=line297></span>    sfunction := sadjectives sfun_kind sdeclname <span class="fstring">":"</span> stypeexpr <span class="fstring">"="</span> smatching+ <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line298></span>      <span class="fstring">"""
<span class="lineno" id=line299></span>       (let
<span class="lineno" id=line300></span>         (
<span class="lineno" id=line301></span>          (t _5)
<span class="lineno" id=line302></span>         )
<span class="lineno" id=line303></span>        (begin ;;(display "MATCHING ftype=")(display t)(display "\n")
<span class="lineno" id=line304></span>          (let
<span class="lineno" id=line305></span>            (
<span class="lineno" id=line306></span>              (argt `(typ_apply ,_sr (,(nos "dom") ,t)))
<span class="lineno" id=line307></span>              (ret `(typ_apply ,_sr (,(nos "cod") ,t)))
<span class="lineno" id=line308></span>              (body `((ast_fun_return ,_sr (ast_match ,_sr (,(noi '_a) ,_7)))))
<span class="lineno" id=line309></span>            )
<span class="lineno" id=line310></span>            `(ast_curry ,_sr ,(first _3) ,(second _3)
<span class="lineno" id=line311></span>              (
<span class="lineno" id=line312></span>                ((Satom (,_sr PVal _a ,argt none)) none)
<span class="lineno" id=line313></span>              )
<span class="lineno" id=line314></span>              (,ret none)
<span class="lineno" id=line315></span>              ,(cal_funkind _1 _2) ,_1 ,body)
<span class="lineno" id=line316></span>          )
<span class="lineno" id=line317></span>         )
<span class="lineno" id=line318></span>       )
<span class="lineno" id=line319></span>      """</span>;
<span class="lineno" id=line320></span>  
<span class="lineno" id=line321></span>  
<span class="lineno" id=line322></span>    sfunction := sadjectives sfun_kind sdeclname <span class="fstring">"="</span> sexpr <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line323></span>     <span class="fstring">""" 
<span class="lineno" id=line324></span>        (let*
<span class="lineno" id=line325></span>          (
<span class="lineno" id=line326></span>            (traint 'none)
<span class="lineno" id=line327></span>            (t `(ast_apply ,_sr (,(nos "typeof") ,_5)))
<span class="lineno" id=line328></span>            (apl `(ast_apply ,_sr (,_5 ,(noi '_a))))
<span class="lineno" id=line329></span>            (argt `(ast_apply ,_sr (,(nos "dom") ,t)))
<span class="lineno" id=line330></span>            (ret `(ast_apply ,_sr (,(nos "cod") ,t)))
<span class="lineno" id=line331></span>            (body `((ast_fun_return ,_sr ,apl )))
<span class="lineno" id=line332></span>            (result `(ast_curry ,_sr ,(first _3) ,(second _3)
<span class="lineno" id=line333></span>              (
<span class="lineno" id=line334></span>                ((Satom (,_sr PVal _a ,argt none)) none)
<span class="lineno" id=line335></span>              )
<span class="lineno" id=line336></span>              (,ret ,traint)
<span class="lineno" id=line337></span>              ,(cal_funkind _1 _2) ,_1 ,body)
<span class="lineno" id=line338></span>            )
<span class="lineno" id=line339></span>          )
<span class="lineno" id=line340></span>          result
<span class="lineno" id=line341></span>       )
<span class="lineno" id=line342></span>      """</span>;
<span class="lineno" id=line343></span>  
<span class="lineno" id=line344></span>  
<span class="lineno" id=line345></span>    <span class="doccomment">Procedure binder.</span>
<span class="lineno" id=line346></span>    sproc_kind := <span class="fstring">"proc"</span> =&gt;# <span class="fstring">"'Function"</span>;
<span class="lineno" id=line347></span>  
<span class="lineno" id=line348></span>    <span class="doccomment">C procedure binder. </span>
<span class="lineno" id=line349></span>    <span class="doccomment">Procedure has C function type (with void result type).</span>
<span class="lineno" id=line350></span>    sproc_kind := <span class="fstring">"cproc"</span> =&gt;# <span class="fstring">"'CFunction"</span>;
<span class="lineno" id=line351></span>  
<span class="lineno" id=line352></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sopt_traint_eq:= <span class="fstring">"expect"</span> sexpr <span class="fstring">"="</span> =&gt;# <span class="fstring">"`((some ,_2) ,dflteffects)"</span>;
<span class="lineno" id=line353></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sopt_traint_eq:= <span class="fstring">"="</span> =&gt;# <span class="fstring">"`(none ,dflteffects)"</span>;
<span class="lineno" id=line354></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sopt_traint_eq:= sepsilon =&gt;# <span class="fstring">"`(none ,dflteffects)"</span>;
<span class="lineno" id=line355></span>  
<span class="lineno" id=line356></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sopt_traint_eq:= <span class="fstring">"expect"</span> sexpr <span class="fstring">":"</span> <span class="fstring">"["</span> stypeexpr <span class="fstring">"]"</span> <span class="fstring">"="</span> =&gt;# <span class="fstring">"`((some ,_2) ,_5)"</span>;
<span class="lineno" id=line357></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sopt_traint_eq:= <span class="fstring">":"</span> <span class="fstring">"["</span> stypeexpr <span class="fstring">"]"</span> <span class="fstring">"="</span> =&gt;# <span class="fstring">"`(none ,_3)"</span>;
<span class="lineno" id=line358></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sopt_traint_eq:= <span class="fstring">":"</span> <span class="fstring">"["</span> stypeexpr <span class="fstring">"]"</span> =&gt;# <span class="fstring">"`(none ,_3)"</span>;
<span class="lineno" id=line359></span>  
<span class="lineno" id=line360></span>  
<span class="lineno" id=line361></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sopt_traint:= <span class="fstring">"expect"</span> sexpr =&gt;# <span class="fstring">"`((some ,_2) ,dflteffects)"</span>;
<span class="lineno" id=line362></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sopt_traint:= sepsilon =&gt;# <span class="fstring">"`(none ,dflteffects)"</span>;
<span class="lineno" id=line363></span>  
<span class="lineno" id=line364></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sopt_traint:= <span class="fstring">"expect"</span> sexpr <span class="fstring">":"</span> <span class="fstring">"["</span> stypeexpr <span class="fstring">"]"</span> =&gt;# <span class="fstring">"`((some ,_2) ,_5)"</span>;
<span class="lineno" id=line365></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sopt_traint:= <span class="fstring">":"</span> <span class="fstring">"["</span> stypeexpr <span class="fstring">"]"</span> =&gt;# <span class="fstring">"`(none ,_3)"</span>;
<span class="lineno" id=line366></span>  
<span class="lineno" id=line367></span>    <span class="doccomment">Short form constructor function.</span>
<span class="lineno" id=line368></span>    <span class="doccomment">The name of the function must be a type name.</span>
<span class="lineno" id=line369></span>    <span class="doccomment">The return type is taken as the type with the name of the function.</span>
<span class="lineno" id=line370></span>    sfunction := <span class="fstring">"ctor"</span> stvarlist squalified_name sfun_arg+ sopt_traint_eq scompound =&gt;#
<span class="lineno" id=line371></span>      <span class="fstring">"""
<span class="lineno" id=line372></span>      (let*
<span class="lineno" id=line373></span>        (
<span class="lineno" id=line374></span>          (name (string-append "_ctor_" (base_of_qualified_name _3)))
<span class="lineno" id=line375></span>          (vs _2)
<span class="lineno" id=line376></span>          (ret _3)
<span class="lineno" id=line377></span>          (traint (first _5))
<span class="lineno" id=line378></span>          (effects (second _5))
<span class="lineno" id=line379></span>          (body _6)
<span class="lineno" id=line380></span>          (args _4)
<span class="lineno" id=line381></span>        )
<span class="lineno" id=line382></span>        `(ast_curry_effects ,_sr ,name ,vs ,args (,ret ,traint) ,effects Function () ,body))
<span class="lineno" id=line383></span>      """</span>;
<span class="lineno" id=line384></span>    sfunction := <span class="fstring">"supertype"</span> stvarlist squalified_name sfun_arg+ sopt_traint_eq scompound =&gt;#
<span class="lineno" id=line385></span>      <span class="fstring">"""
<span class="lineno" id=line386></span>      (let*
<span class="lineno" id=line387></span>        (
<span class="lineno" id=line388></span>          (name (string-append "_supertype_" (base_of_qualified_name _3)))
<span class="lineno" id=line389></span>          (vs _2)
<span class="lineno" id=line390></span>          (ret _3)
<span class="lineno" id=line391></span>          (traint (first _5))
<span class="lineno" id=line392></span>          (effects (second _5))
<span class="lineno" id=line393></span>          (body _6)
<span class="lineno" id=line394></span>          (args _4)
<span class="lineno" id=line395></span>        )
<span class="lineno" id=line396></span>        `(ast_curry_effects ,_sr ,name ,vs ,args (,ret ,traint) ,effects Function (Subtype) ,body))
<span class="lineno" id=line397></span>      """</span>;
<span class="lineno" id=line398></span>    sfunction := <span class="fstring">"supertype"</span> stvarlist <span class="fstring">"&amp;"</span> squalified_name sfun_arg+ sopt_traint_eq scompound =&gt;#
<span class="lineno" id=line399></span>      <span class="fstring">"""
<span class="lineno" id=line400></span>      (let*
<span class="lineno" id=line401></span>        (
<span class="lineno" id=line402></span>          (name (string-append "_supertype_" (base_of_qualified_name _4)))
<span class="lineno" id=line403></span>          (vs _2)
<span class="lineno" id=line404></span>          (ret `(typ_ref ,_sr ,_4))
<span class="lineno" id=line405></span>          (traint (first _6))
<span class="lineno" id=line406></span>          (effects (second _6))
<span class="lineno" id=line407></span>          (body _7)
<span class="lineno" id=line408></span>          (args _5)
<span class="lineno" id=line409></span>        )
<span class="lineno" id=line410></span>        `(ast_curry_effects ,_sr ,name ,vs ,args (,ret ,traint) ,effects Function (Subtype) ,body))
<span class="lineno" id=line411></span>      """</span>;
<span class="lineno" id=line412></span>  
<span class="lineno" id=line413></span>  
<span class="lineno" id=line414></span>    <span class="doccomment">Short form constructor function.</span>
<span class="lineno" id=line415></span>    <span class="doccomment">The name of the function must be a type name.</span>
<span class="lineno" id=line416></span>    <span class="doccomment">The return type is taken as the type with the name of the function.</span>
<span class="lineno" id=line417></span>    sfunction := <span class="fstring">"ctor"</span> stvarlist squalified_name sfun_arg+ sopt_traint <span class="fstring">"=&gt;"</span> sexpr <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line418></span>      <span class="fstring">"""
<span class="lineno" id=line419></span>      (let*
<span class="lineno" id=line420></span>        (
<span class="lineno" id=line421></span>          (name (string-append "_ctor_" (base_of_qualified_name _3)))
<span class="lineno" id=line422></span>          (vs _2)
<span class="lineno" id=line423></span>          (ret _3)
<span class="lineno" id=line424></span>          (traint (first _5))
<span class="lineno" id=line425></span>          (effects (second _5))
<span class="lineno" id=line426></span>          (body `((ast_fun_return ,_sr ,_7)))
<span class="lineno" id=line427></span>          (args _4)
<span class="lineno" id=line428></span>        )
<span class="lineno" id=line429></span>        `(ast_curry_effects ,_sr ,name ,vs ,args (,ret ,traint) ,effects Function () ,body))
<span class="lineno" id=line430></span>      """</span>;
<span class="lineno" id=line431></span>    sfunction := <span class="fstring">"supertype"</span> stvarlist squalified_name sfun_arg+ sopt_traint <span class="fstring">"=&gt;"</span> sexpr <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line432></span>      <span class="fstring">"""
<span class="lineno" id=line433></span>      (let*
<span class="lineno" id=line434></span>        (
<span class="lineno" id=line435></span>          (name (string-append "_supertype_" (base_of_qualified_name _3)))
<span class="lineno" id=line436></span>          (vs _2)
<span class="lineno" id=line437></span>          (ret _3)
<span class="lineno" id=line438></span>          (traint (first _5))
<span class="lineno" id=line439></span>          (effects (second _5))
<span class="lineno" id=line440></span>          (body `((ast_fun_return ,_sr ,_7)))
<span class="lineno" id=line441></span>          (args _4)
<span class="lineno" id=line442></span>        )
<span class="lineno" id=line443></span>        `(ast_curry_effects ,_sr ,name ,vs ,args (,ret ,traint) ,effects Function (Subtype) ,body))
<span class="lineno" id=line444></span>      """</span>;
<span class="lineno" id=line445></span>    sfunction := <span class="fstring">"supertype"</span> stvarlist <span class="fstring">"&amp;"</span> squalified_name sfun_arg+ sopt_traint <span class="fstring">"=&gt;"</span> sexpr <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line446></span>      <span class="fstring">"""
<span class="lineno" id=line447></span>      (let*
<span class="lineno" id=line448></span>        (
<span class="lineno" id=line449></span>          (name (string-append "_supertype_" (base_of_qualified_name _4)))
<span class="lineno" id=line450></span>          (vs _2)
<span class="lineno" id=line451></span>          (ret `(typ_ref ,_sr ,_4))
<span class="lineno" id=line452></span>          (traint (first _6))
<span class="lineno" id=line453></span>          (effects (second _6))
<span class="lineno" id=line454></span>          (body `((ast_fun_return ,_sr ,_8)))
<span class="lineno" id=line455></span>          (args _5)
<span class="lineno" id=line456></span>        )
<span class="lineno" id=line457></span>        `(ast_curry_effects ,_sr ,name ,vs ,args (,ret ,traint) ,effects Function (Subtype) ,body))
<span class="lineno" id=line458></span>      """</span>;
<span class="lineno" id=line459></span>  
<span class="lineno" id=line460></span>  
<span class="lineno" id=line461></span>  
<span class="lineno" id=line462></span>    <span class="doccomment">Procedure definition, general form.</span>
<span class="lineno" id=line463></span>    sfunction := sadjectives sproc_kind sdeclname sfun_arg* sopt_traint_eq scompound =&gt;#
<span class="lineno" id=line464></span>      <span class="fstring">"""
<span class="lineno" id=line465></span>        `(ast_curry_effects ,_sr ,(first _3) ,(second _3) ,_4 ((ast_void ,_sr) ,(first _5)) ,(second _5)
<span class="lineno" id=line466></span>           ,(cal_funkind _1 _2) ,_1 ,_6)
<span class="lineno" id=line467></span>      """</span>;
<span class="lineno" id=line468></span>  
<span class="lineno" id=line469></span>    <span class="doccomment">Procedure definition, short form (one statement).</span>
<span class="lineno" id=line470></span>    sfunction := sadjectives sproc_kind sdeclname sfun_arg* sopt_traint <span class="fstring">"=&gt;"</span> stmt =&gt;#
<span class="lineno" id=line471></span>      <span class="fstring">"""
<span class="lineno" id=line472></span>        `(ast_curry_effects ,_sr ,(first _3) ,(second _3) ,_4 ((ast_void ,_sr) ,(first _5)) ,(second _5) 
<span class="lineno" id=line473></span>           ,(cal_funkind _1 _2) ,_1 (,_7))
<span class="lineno" id=line474></span>      """</span>;
<span class="lineno" id=line475></span>  
<span class="lineno" id=line476></span>    <span class="doccomment">Routine definition, general form.</span>
<span class="lineno" id=line477></span>    sfunction := sadjectives <span class="fstring">"routine"</span> sdeclname sfun_arg* sopt_traint_eq scompound =&gt;#
<span class="lineno" id=line478></span>      <span class="fstring">"""
<span class="lineno" id=line479></span>        `(ast_curry_effects ,_sr ,(first _3) ,(second _3) ,_4 (,(noi 'any) ,(first _5)) ,(second _5)
<span class="lineno" id=line480></span>           Function ,_1 ,_6)
<span class="lineno" id=line481></span>      """</span>;
<span class="lineno" id=line482></span>  
<span class="lineno" id=line483></span>    <span class="doccomment">Routine definition, short form (one statement).</span>
<span class="lineno" id=line484></span>    sfunction := sadjectives <span class="fstring">"routine"</span> sdeclname sfun_arg* sopt_traint <span class="fstring">"=&gt;"</span> stmt =&gt;#
<span class="lineno" id=line485></span>      <span class="fstring">"""
<span class="lineno" id=line486></span>        `(ast_curry_effects ,_sr ,(first _3) ,(second _3) ,_4 (,(noi 'any) ,(first _5)) ,(second _5) 
<span class="lineno" id=line487></span>           Function ,_1 (,_7))
<span class="lineno" id=line488></span>      """</span>;
<span class="lineno" id=line489></span>  }
<span class="lineno" id=line490></span>  
</pre></p></div><h2 id='Standard_include_file_list_h'><img src='/share/src/web/images/minus.gif' id='Standard include file list' onclick='toggle(this,"Standard_include_file_list_d")' alt='+'/> 2.11 Standard include file list</h2><div id='Standard_include_file_list_d' style='display:block'>
<p>For files generated by this package. Includes <code>grammar/extra.files</code>
for extensions in other packages.
</p><pre class='inclusion'>
share/lib/grammar/grammar.files</pre>
<p><pre class="prefmtbg">grammar/utility.fsyn
grammar/grammar_scheme_support.fsyn
grammar/blocks.fsyn
grammar/variables.fsyn
grammar/patterns.fsyn
grammar/functions.fsyn
grammar/cgram.fsyn
grammar/control.fsyn
grammar/statements.fsyn
grammar/plugins.fsyn
grammar/assertions.fsyn
grammar/cbind.fsyn
grammar/grammar_float_lexer.fsyn
grammar/namespaces.fsyn
grammar/swapop.fsyn
grammar/macros.fsyn
grammar/grammar_string_lexer.fsyn
grammar/brackets.fsyn
grammar/texsyms.fsyn
grammar/grammar_regdefs.fsyn
grammar/debug.fsyn
grammar/types.fsyn
grammar/assignment.fsyn
grammar/executable.fsyn
grammar/chips.fsyn
grammar/loops.fsyn
grammar/requirements.fsyn
grammar/grammar_int_lexer.fsyn
grammar/conditional.fsyn
grammar/grammar_ident_lexer.fsyn
grammar/pfor.fsyn
grammar/grammar_lexer.fsyn
grammar/expressions.fsyn
grammar/type_decls.fsyn
std/strings/parser_syn.fsyn
std/strings/stringexpr.fsyn
std/datatype/tupleexpr.fsyn
std/datatype/listexpr.fsyn
std/regex/regexps.fsyn
std/objc/objc.fsyn
std/scalar/boolexpr.fsyn
std/control/exceptions.fsyn
std/control/spipeexpr.fsyn
std/algebra/tordcmpexpr.fsyn
std/algebra/mulexpr.fsyn
std/algebra/pordcmpexpr.fsyn
std/algebra/cmpexpr.fsyn
std/algebra/bitexpr.fsyn
std/algebra/addexpr.fsyn
std/algebra/setexpr.fsyn
std/algebra/divexpr.fsyn
grammar/felix.fsyn
grammar/save.fsyn
</pre></p></div><h2 id='Identifier_Lexer_h'><img src='/share/src/web/images/minus.gif' id='Identifier Lexer' onclick='toggle(this,"Identifier_Lexer_d")' alt='+'/> 2.12 Identifier Lexer</h2><div id='Identifier_Lexer_d' style='display:block'>
<pre class='inclusion'>
share/lib/grammar/grammar_ident_lexer.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> felix_ident_lexer {
<span class="lineno" id=line2></span>    <span class="comment">/* identifiers */</span>
<span class="lineno" id=line3></span>    <span class="big_keyword" title="define named regular expression">regdef</span> ucn =
<span class="lineno" id=line4></span>        <span class="fstring">"\u"</span> hexdigit hexdigit hexdigit hexdigit
<span class="lineno" id=line5></span>      | <span class="fstring">"\U"</span> hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit;
<span class="lineno" id=line6></span>  
<span class="lineno" id=line7></span>    <span class="big_keyword" title="define named regular expression">regdef</span> prime = <span class="fstring">"'"</span>;
<span class="lineno" id=line8></span>    <span class="big_keyword" title="define named regular expression">regdef</span> dash = <span class="fstring">'-'</span>;
<span class="lineno" id=line9></span>    <span class="big_keyword" title="define named regular expression">regdef</span> idletter = letter | underscore | hichar | ucn;
<span class="lineno" id=line10></span>    <span class="big_keyword" title="define named regular expression">regdef</span> alphnum = idletter | digit;
<span class="lineno" id=line11></span>    <span class="big_keyword" title="define named regular expression">regdef</span> innerglyph = idletter | digit | dash;
<span class="lineno" id=line12></span>    <span class="big_keyword" title="define named regular expression">regdef</span> flx_ident = idletter (innerglyph ? (alphnum | prime) +)* prime*;
<span class="lineno" id=line13></span>    <span class="big_keyword" title="define named regular expression">regdef</span> tex_ident = slosh letter+;
<span class="lineno" id=line14></span>    <span class="big_keyword" title="define named regular expression">regdef</span> sym_ident =
<span class="lineno" id=line15></span>      <span class="fstring">"+"</span> | <span class="fstring">"-"</span> | <span class="fstring">"*"</span> | <span class="fstring">"/"</span> | <span class="fstring">"%"</span> | <span class="fstring">"^"</span> | <span class="fstring">"~"</span> | 
<span class="lineno" id=line16></span>      <span class="fstring">"\&amp;"</span> | <span class="fstring">"\|"</span> | <span class="fstring">"\^"</span> |
<span class="lineno" id=line17></span>      <span class="comment">/* mutator */</span>
<span class="lineno" id=line18></span>      <span class="fstring">"&amp;="</span> | <span class="fstring">"|="</span> | <span class="fstring">"+="</span> | <span class="fstring">"-="</span> | <span class="fstring">"*="</span> | <span class="fstring">"/="</span> | <span class="fstring">"%="</span> | <span class="fstring">"^="</span> | <span class="fstring">"&lt;&lt;="</span> | <span class="fstring">"&gt;&gt;="</span> |
<span class="lineno" id=line19></span>      <span class="comment">/* comparison */</span>
<span class="lineno" id=line20></span>      <span class="fstring">"&lt;"</span> | <span class="fstring">"&gt;"</span> | <span class="fstring">"=="</span> | <span class="fstring">"!="</span> | <span class="fstring">"&lt;="</span> | <span class="fstring">"&gt;="</span> | <span class="fstring">"&lt;&lt;"</span> | <span class="fstring">"&gt;&gt;"</span> | <span class="fstring">"&lt;&gt;"</span>
<span class="lineno" id=line21></span>    ;
<span class="lineno" id=line22></span>  
<span class="lineno" id=line23></span>    <span class="comment">/* NOTE: upgrade to support n"wird + name" strings */</span>
<span class="lineno" id=line24></span>    <span class="big_keyword" title="define literal">literal</span> flx_ident =&gt;# <span class="fstring">"(utf8-&gt;ucn _1)"</span>;
<span class="lineno" id=line25></span>    <span class="big_keyword" title="define literal">literal</span> tex_ident =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line26></span>    <span class="big_keyword" title="define literal">literal</span> sym_ident =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line27></span>  
<span class="lineno" id=line28></span>    sname := flx_ident =&gt;# <span class="fstring">"_1"</span> | tex_ident =&gt;# <span class="fstring">"_1"</span> | sym_ident =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line29></span>  
<span class="lineno" id=line30></span>  }
<span class="lineno" id=line31></span>  
</pre></p><pre class='inclusion'>
share/lib/grammar/grammar_lexer.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  
<span class="lineno" id=line3></span>  
<span class="lineno" id=line4></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line5></span>  (define (stripus s) ; strip underscores and primes in numbers
<span class="lineno" id=line6></span>    (let*
<span class="lineno" id=line7></span>      ( 
<span class="lineno" id=line8></span>        (chrs (string-&gt;list s))
<span class="lineno" id=line9></span>        (chrs (filter (lambda (x) (not (char=? x (integer-&gt;char 95)))) chrs)) ; strip underscores
<span class="lineno" id=line10></span>        (chrs (filter (lambda (x) (not (char=? x (integer-&gt;char 39)))) chrs)) ; strip primes
<span class="lineno" id=line11></span>      )
<span class="lineno" id=line12></span>      (list-&gt;string chrs)
<span class="lineno" id=line13></span>    )
<span class="lineno" id=line14></span>  )
<span class="lineno" id=line15></span>  """</span>;
<span class="lineno" id=line16></span>  
<span class="lineno" id=line17></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line18></span>  (define (tolower-char c) ; convert one character to lower case
<span class="lineno" id=line19></span>    (let* 
<span class="lineno" id=line20></span>      (
<span class="lineno" id=line21></span>        (i (char-&gt;integer c))
<span class="lineno" id=line22></span>        (i (if (and (&gt;= i 65) (&lt;= i 90)) (+ i 32) i))
<span class="lineno" id=line23></span>      ) 
<span class="lineno" id=line24></span>      (integer-&gt;char i)
<span class="lineno" id=line25></span>    )
<span class="lineno" id=line26></span>  )
<span class="lineno" id=line27></span>  """</span>;
<span class="lineno" id=line28></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line29></span>  (define (tolower-string s) ; convert a whole string to lower case
<span class="lineno" id=line30></span>    (let*
<span class="lineno" id=line31></span>      (
<span class="lineno" id=line32></span>        (chrs (string-&gt;list s))
<span class="lineno" id=line33></span>        (chrs (map tolower-char chrs))
<span class="lineno" id=line34></span>      )
<span class="lineno" id=line35></span>      (list-&gt;string chrs)
<span class="lineno" id=line36></span>    )
<span class="lineno" id=line37></span>  )
<span class="lineno" id=line38></span>  """</span>;
<span class="lineno" id=line39></span>  
<span class="lineno" id=line40></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> lexer {
<span class="lineno" id=line41></span>    <span class="big_keyword" title="specify requirements">requires</span> global_regdefs;
<span class="lineno" id=line42></span>    <span class="big_keyword" title="specify requirements">requires</span> felix_ident_lexer;
<span class="lineno" id=line43></span>    <span class="big_keyword" title="specify requirements">requires</span> felix_int_lexer;
<span class="lineno" id=line44></span>    <span class="big_keyword" title="specify requirements">requires</span> felix_float_lexer;
<span class="lineno" id=line45></span>    <span class="big_keyword" title="specify requirements">requires</span> felix_string_lexer;
<span class="lineno" id=line46></span>  }
</pre></p></div><h2 id='Regular_Definitions_DSSL_h'><img src='/share/src/web/images/minus.gif' id='Regular Definitions DSSL' onclick='toggle(this,"Regular_Definitions_DSSL_d")' alt='+'/> 2.13 Regular Definitions DSSL</h2><div id='Regular_Definitions_DSSL_d' style='display:block'>
<p>Regular expressions and regular definitions for use with
Google RE2 package via Felix binding library.
</p><pre class='inclusion'>
share/lib/grammar/grammar_regdefs.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> global_regdefs {
<span class="lineno" id=line2></span>    <span class="comment">/* ====================== REGULAR DEFINITIONS ============================ */</span>
<span class="lineno" id=line3></span>    <span class="comment">/* special characters */</span>
<span class="lineno" id=line4></span>    <span class="big_keyword" title="define named regular expression">regdef</span> quote = <span class="fstring">"'"</span>;
<span class="lineno" id=line5></span>    <span class="big_keyword" title="define named regular expression">regdef</span> dquote = <span class="fstring">'"'</span>;
<span class="lineno" id=line6></span>    <span class="big_keyword" title="define named regular expression">regdef</span> slosh = <span class="fstring">'\'</span>;
<span class="lineno" id=line7></span>    <span class="big_keyword" title="define named regular expression">regdef</span> hash = <span class="fstring">'#'</span>;
<span class="lineno" id=line8></span>    <span class="big_keyword" title="define named regular expression">regdef</span> linefeed = 10;
<span class="lineno" id=line9></span>    <span class="big_keyword" title="define named regular expression">regdef</span> tab = 9;
<span class="lineno" id=line10></span>    <span class="big_keyword" title="define named regular expression">regdef</span> space = <span class="fstring">' '</span>;
<span class="lineno" id=line11></span>    <span class="big_keyword" title="define named regular expression">regdef</span> formfeed = 12;
<span class="lineno" id=line12></span>    <span class="big_keyword" title="define named regular expression">regdef</span> vtab = 11;
<span class="lineno" id=line13></span>    <span class="big_keyword" title="define named regular expression">regdef</span> carriage_return = 13;
<span class="lineno" id=line14></span>    <span class="big_keyword" title="define named regular expression">regdef</span> underscore = <span class="fstring">'_'</span>;
<span class="lineno" id=line15></span>  
<span class="lineno" id=line16></span>    <span class="comment">/* character sets */</span>
<span class="lineno" id=line17></span>    <span class="big_keyword" title="define named regular expression">regdef</span> bindigit = [<span class="fstring">'01'</span>];
<span class="lineno" id=line18></span>    <span class="big_keyword" title="define named regular expression">regdef</span> octdigit = [<span class="fstring">'01234567'</span>];
<span class="lineno" id=line19></span>    <span class="big_keyword" title="define named regular expression">regdef</span> digit = [<span class="fstring">'0123456789'</span>];
<span class="lineno" id=line20></span>    <span class="big_keyword" title="define named regular expression">regdef</span> hexdigit = [<span class="fstring">"0123456789ABCDEFabcdef"</span>];
<span class="lineno" id=line21></span>    <span class="big_keyword" title="define named regular expression">regdef</span> lower = [<span class="fstring">'abcdefghijklmnopqrstuvwxyz'</span>];
<span class="lineno" id=line22></span>    <span class="big_keyword" title="define named regular expression">regdef</span> upper = [<span class="fstring">'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>];
<span class="lineno" id=line23></span>    <span class="big_keyword" title="define named regular expression">regdef</span> letter = lower | upper;
<span class="lineno" id=line24></span>    <span class="big_keyword" title="define named regular expression">regdef</span> hichar = [128-255];
<span class="lineno" id=line25></span>    <span class="big_keyword" title="define named regular expression">regdef</span> white = space | tab;
<span class="lineno" id=line26></span>    <span class="big_keyword" title="define named regular expression">regdef</span> dsep = underscore | quote;
<span class="lineno" id=line27></span>  
<span class="lineno" id=line28></span>    <span class="comment">/* nasty: form control characters */</span>
<span class="lineno" id=line29></span>    <span class="big_keyword" title="define named regular expression">regdef</span> form_control = linefeed | carriage_return | vtab | formfeed;
<span class="lineno" id=line30></span>    <span class="big_keyword" title="define named regular expression">regdef</span> newline_prefix = linefeed | carriage_return;
<span class="lineno" id=line31></span>    <span class="big_keyword" title="define named regular expression">regdef</span> newline = formfeed | linefeed  | carriage_return linefeed;
<span class="lineno" id=line32></span>    <span class="big_keyword" title="define named regular expression">regdef</span> hash = <span class="fstring">'#'</span>;
<span class="lineno" id=line33></span>  
<span class="lineno" id=line34></span>    <span class="big_keyword" title="define named regular expression">regdef</span> ordinary = letter | digit | hichar |
<span class="lineno" id=line35></span>      <span class="fstring">'!'</span> | <span class="fstring">'$'</span> | <span class="fstring">'%'</span> | <span class="fstring">'&amp;'</span> | <span class="fstring">'('</span> | <span class="fstring">')'</span> | <span class="fstring">'*'</span> |
<span class="lineno" id=line36></span>      <span class="fstring">'+'</span> | <span class="fstring">','</span> | <span class="fstring">'-'</span> | <span class="fstring">'.'</span> | <span class="fstring">'/'</span> | <span class="fstring">':'</span> | <span class="fstring">';'</span> | <span class="fstring">'&lt;'</span> |
<span class="lineno" id=line37></span>      <span class="fstring">'='</span> | <span class="fstring">'&gt;'</span> | <span class="fstring">'?'</span> | <span class="fstring">'@'</span> | <span class="fstring">'['</span> | <span class="fstring">']'</span> | <span class="fstring">'^'</span> | <span class="fstring">'_'</span> |
<span class="lineno" id=line38></span>      <span class="fstring">'`'</span> | <span class="fstring">'{'</span> | <span class="fstring">'|'</span> | <span class="fstring">'}'</span> | <span class="fstring">'~'</span>;
<span class="lineno" id=line39></span>  
<span class="lineno" id=line40></span>    <span class="big_keyword" title="define named regular expression">regdef</span> printable = ordinary | quote | dquote | slosh | hash;
<span class="lineno" id=line41></span>  }
<span class="lineno" id=line42></span>  
</pre></p></div><h2 id='Utility_Scheme_definitions._h'><img src='/share/src/web/images/minus.gif' id='Utility Scheme definitions.' onclick='toggle(this,"Utility_Scheme_definitions._d")' alt='+'/> 2.14 Utility Scheme definitions.</h2><div id='Utility_Scheme_definitions._d' style='display:block'>
<p>For use in the action codes of the grammar.
</p><pre class='inclusion'>
share/lib/grammar/grammar_scheme_support.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""(define counter 100)"""</span>;
<span class="lineno" id=line2></span>  
<span class="lineno" id=line3></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""(define (fresh_int x)(begin (set! counter (+ counter 1)) counter))"""</span>;
<span class="lineno" id=line4></span>  
<span class="lineno" id=line5></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""(define (fresh_name x)(string-append "_" x "_" _filebase "_" (number-&gt;string (fresh_int()))))"""</span>;
<span class="lineno" id=line6></span>  
<span class="lineno" id=line7></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line8></span>  (begin
<span class="lineno" id=line9></span>    ;; lists
<span class="lineno" id=line10></span>    (define (first x)(car x))
<span class="lineno" id=line11></span>    (define (second x)(cadr x))
<span class="lineno" id=line12></span>    (define (third x)(caddr x))
<span class="lineno" id=line13></span>    (define (fourth x)(cadddr x))
<span class="lineno" id=line14></span>    (define (tail x)(cdr x))
<span class="lineno" id=line15></span>    (define fold_left
<span class="lineno" id=line16></span>      (lambda (f acc lst)
<span class="lineno" id=line17></span>        (if (null? lst) acc (fold_left f (f acc (first lst)) (tail lst)))))
<span class="lineno" id=line18></span>  
<span class="lineno" id=line19></span>    ;; list of pairs
<span class="lineno" id=line20></span>    (define (myassoc elt alst)
<span class="lineno" id=line21></span>      (let ((r (assoc elt alst)))
<span class="lineno" id=line22></span>      (if r (second r) `(MISMATCHED_BRACKET ,elt ,alst))))
<span class="lineno" id=line23></span>  
<span class="lineno" id=line24></span>    (define (list-mem? item lst) (fold_left (lambda (acc elt)(or acc (eq? elt item))) #f lst))
<span class="lineno" id=line25></span>    ;; name term constructor
<span class="lineno" id=line26></span>    (define (nos x)`(ast_name ,_sr ,x ()))
<span class="lineno" id=line27></span>    (define (tnos x)`(ast_name ,_sr ,x ()))
<span class="lineno" id=line28></span>    (define (noi x)`(ast_name ,_sr ,(symbol-&gt;string x) ()))
<span class="lineno" id=line29></span>    (define (qnoi c x)`(ast_lookup (,(noi c) ,(symbol-&gt;string x) ())))
<span class="lineno" id=line30></span>  
<span class="lineno" id=line31></span>    ;; polymorphic parameters
<span class="lineno" id=line32></span>    (define dummysr '("dummysr" 0 0 0 0))
<span class="lineno" id=line33></span>    (define (typesoftvarlist x) (map nos (map first (first x))))
<span class="lineno" id=line34></span>  
<span class="lineno" id=line35></span>  
<span class="lineno" id=line36></span>    (define tunit `(typ_tuple ,dummysr ())) ;; unit type
<span class="lineno" id=line37></span>    (define ttrue `(ast_name ,dummysr "TRUE" ()))
<span class="lineno" id=line38></span>    (define dfltaux `(,ttrue ())) ;; constraint TRUE, typeclass list empty
<span class="lineno" id=line39></span>    (define dfltvs `( () ,dfltaux)) ;; vs list: name list and constraint pair
<span class="lineno" id=line40></span>    (define unitparam '((Slist ()) none))
<span class="lineno" id=line41></span>    (define dfltparams `(,unitparam))
<span class="lineno" id=line42></span>    (define dflteffects tunit)
<span class="lineno" id=line43></span>  )
<span class="lineno" id=line44></span>  """</span>;
<span class="lineno" id=line45></span>  
<span class="lineno" id=line46></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line47></span>  (define (isvoid? x) 
<span class="lineno" id=line48></span>    (if 
<span class="lineno" id=line49></span>      (list? x)
<span class="lineno" id=line50></span>        (equal? 'ast_void (first x))
<span class="lineno" id=line51></span>         #f
<span class="lineno" id=line52></span>     ))
<span class="lineno" id=line53></span>  """</span>;
<span class="lineno" id=line54></span>  
<span class="lineno" id=line55></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line56></span>  (begin
<span class="lineno" id=line57></span>    (define (base_of_ast_lookup qn) (second (second qn)))
<span class="lineno" id=line58></span>    (define (base_of_ast_name n) (third n))
<span class="lineno" id=line59></span>    (define (base_of_qualified_name qn)
<span class="lineno" id=line60></span>      (cond 
<span class="lineno" id=line61></span>        ((eq? (first qn) 'ast_lookup) (base_of_ast_lookup qn))
<span class="lineno" id=line62></span>        ((eq? (first qn) 'ast_name) (base_of_ast_name qn))
<span class="lineno" id=line63></span>        (else (begin (display "QUALIFIED_NAME_EXPECTED got:")(display qn)))
<span class="lineno" id=line64></span>      )
<span class="lineno" id=line65></span>    )
<span class="lineno" id=line66></span>  )
<span class="lineno" id=line67></span>  """</span>;
<span class="lineno" id=line68></span>  
<span class="lineno" id=line69></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line70></span>  ;; lambda terms
<span class="lineno" id=line71></span>  (begin
<span class="lineno" id=line72></span>    (define (lazy stmts) `(ast_lambda ,_sr (,dfltvs ,dfltparams typ_none ,stmts)))
<span class="lineno" id=line73></span>    (define (lazy_proc stmts) `(ast_lambda ,_sr (,dfltvs ,dfltparams (ast_void ,_sr) ,stmts)))
<span class="lineno" id=line74></span>    (define (block_stmts stmts)`(ast_call ,_sr ,(lazy_proc stmts) ()))
<span class="lineno" id=line75></span>    (define (block_expr stmts) `(ast_apply ,_sr (,(lazy stmts) ())))
<span class="lineno" id=line76></span>    (define call (lambda (f a) `(ast_call ,_sr (ast_name ,_sr ,f ()) ,a)))
<span class="lineno" id=line77></span>  )
<span class="lineno" id=line78></span>  """</span>;
<span class="lineno" id=line79></span>  
<span class="lineno" id=line80></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line81></span>  ;; split an application term apply (f a) into list (f a)
<span class="lineno" id=line82></span>  (define (splitapply x)
<span class="lineno" id=line83></span>    (if (pair? x)
<span class="lineno" id=line84></span>      (if (eq? (first x) 'ast_apply)
<span class="lineno" id=line85></span>        (if (pair? (cddr x))
<span class="lineno" id=line86></span>          (begin
<span class="lineno" id=line87></span>  ;;           (display "f=")(display (caaddr x))
<span class="lineno" id=line88></span>  ;;           (display " arg=")(display (cadaddr x))
<span class="lineno" id=line89></span>  ;;           (display " pair=")(display (caddr x))
<span class="lineno" id=line90></span>             (caddr x))
<span class="lineno" id=line91></span>          (list x ()))
<span class="lineno" id=line92></span>        (list x ()))
<span class="lineno" id=line93></span>      (list ()))
<span class="lineno" id=line94></span>  )
<span class="lineno" id=line95></span>  """</span>;
<span class="lineno" id=line96></span>  
<span class="lineno" id=line97></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line98></span>  (define (mkexlist x)
<span class="lineno" id=line99></span>    (begin
<span class="lineno" id=line100></span>    ;;(display "mkexlist x=")(display x)
<span class="lineno" id=line101></span>    (if (pair? x)
<span class="lineno" id=line102></span>      (if (eq? (first x) 'ast_tuple)
<span class="lineno" id=line103></span>        (if (pair? (cddr x)) (caddr x) (list x))
<span class="lineno" id=line104></span>        (list x))
<span class="lineno" id=line105></span>      (list x)))
<span class="lineno" id=line106></span>  )
<span class="lineno" id=line107></span>  """</span>;
<span class="lineno" id=line108></span>  
<span class="lineno" id=line109></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line110></span>  (define (mktylist x)
<span class="lineno" id=line111></span>    (begin
<span class="lineno" id=line112></span>    ;;(display "mktylist x=")(display x)(display "\n")
<span class="lineno" id=line113></span>    (if (pair? x)
<span class="lineno" id=line114></span>      (if (eq? (first x) 'typ_tuple )
<span class="lineno" id=line115></span>        (if (pair? (cddr x)) (caddr x) (list x))
<span class="lineno" id=line116></span>        (list x))
<span class="lineno" id=line117></span>      (list x)))
<span class="lineno" id=line118></span>  )
<span class="lineno" id=line119></span>  """</span>;
<span class="lineno" id=line120></span>  
<span class="lineno" id=line121></span>  
<span class="lineno" id=line122></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line123></span>  (define (cal_funkind adjs fk)
<span class="lineno" id=line124></span>    (if (eq? fk 'CFunction)'CFunction
<span class="lineno" id=line125></span>    (if (and (eq? fk 'Generator)(list-mem? 'Method adjs))'GeneratorMethod
<span class="lineno" id=line126></span>    (if (eq? fk 'Generator)'Generator
<span class="lineno" id=line127></span>    (if (list-mem? 'NoInlineFunction adjs)'NoInlineFunction
<span class="lineno" id=line128></span>    (if (list-mem? 'InlineFunction adjs)'InlineFunction
<span class="lineno" id=line129></span>    (if (list-mem? 'Method adjs)'Method
<span class="lineno" id=line130></span>    (if (list-mem? 'Ctor adjs)'Ctor
<span class="lineno" id=line131></span>    (if (list-mem? 'Virtual adjs)'Virtual
<span class="lineno" id=line132></span>    'Function
<span class="lineno" id=line133></span>  )))))))))
<span class="lineno" id=line134></span>  """</span>;
<span class="lineno" id=line135></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line136></span>  (define (tvfixup_folder vsct vtc)
<span class="lineno" id=line137></span>    (begin ;;(display "\n*********\ntvfixup_folder vsct=")(display vsct)(display ", vtc=")(display vtc)(display "\n")
<span class="lineno" id=line138></span>    (let*
<span class="lineno" id=line139></span>      (
<span class="lineno" id=line140></span>        (vs (first vsct))  ;; variable name
<span class="lineno" id=line141></span>        (ct (second vsct)) ;; individual constraint
<span class="lineno" id=line142></span>        (v (first vtc))    ;; 
<span class="lineno" id=line143></span>        (t (second vtc))
<span class="lineno" id=line144></span>        (c (third vtc))
<span class="lineno" id=line145></span>        (variance (fourth vtc))
<span class="lineno" id=line146></span>        (ct2
<span class="lineno" id=line147></span>          (cond
<span class="lineno" id=line148></span>            ((eq? 'NoConstraint c) ct )
<span class="lineno" id=line149></span>            ((eq? 'Eq (first c)) ;; type  valconstraint
<span class="lineno" id=line150></span>              `(typ_andchain
<span class="lineno" id=line151></span>                ;;((ast_type_match ,_sr ((ast_name ,_sr ,v ()) ((,(second c) (typ_tuple ,_sr ())))))
<span class="lineno" id=line152></span>                ((ast_type_match ,_sr ((ast_name ,_sr ,v ()) ((,(second c) ,ttrue))))
<span class="lineno" id=line153></span>                ,ct)
<span class="lineno" id=line154></span>              )
<span class="lineno" id=line155></span>            )
<span class="lineno" id=line156></span>            ((eq? 'In (first c)) ;; type constraint
<span class="lineno" id=line157></span>              `(typ_andchain
<span class="lineno" id=line158></span>                ((typ_isin ((ast_name ,_sr ,v ()) ,(second c)))
<span class="lineno" id=line159></span>                ,ct)
<span class="lineno" id=line160></span>              )
<span class="lineno" id=line161></span>            )
<span class="lineno" id=line162></span>          (else (display "ERROR!!!"))
<span class="lineno" id=line163></span>          )
<span class="lineno" id=line164></span>        )
<span class="lineno" id=line165></span>      )
<span class="lineno" id=line166></span>      (begin
<span class="lineno" id=line167></span>      ;; (display "vs=")(display vs)
<span class="lineno" id=line168></span>      ;; (display "\nct=")(display ct)
<span class="lineno" id=line169></span>      ;; (display "\nv=")(display v)
<span class="lineno" id=line170></span>      ;; (display "\nt=")(display t)
<span class="lineno" id=line171></span>      ;; (display "\nc=")(display c)
<span class="lineno" id=line172></span>      ;; (display "\nct2=")(display ct2)
<span class="lineno" id=line173></span>      ;; (display "\n")
<span class="lineno" id=line174></span>      (list (cons `(,v ,t ,variance) vs) ct2))
<span class="lineno" id=line175></span>  ))))
<span class="lineno" id=line176></span>  """</span>;
<span class="lineno" id=line177></span>  
<span class="lineno" id=line178></span>  <span class="comment">//</span>
<span class="lineno" id=line179></span>  <span class="comment">// rti = rtc:type constraint, rtr:class requirement list</span>
<span class="lineno" id=line180></span>  <span class="comment">//</span>
<span class="lineno" id=line181></span>  
<span class="lineno" id=line182></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line183></span>  (define (tvfixup tv ct)
<span class="lineno" id=line184></span>    (begin ;;(display "tvfixup tv=")(display tv)(display ", ct=")(display ct)(display "\\n")
<span class="lineno" id=line185></span>    (let*
<span class="lineno" id=line186></span>      (
<span class="lineno" id=line187></span>        ;;(vscs (fold_left tvfixup_folder `(() (typ_tuple ,_sr ())) tv))
<span class="lineno" id=line188></span>        (vscs (fold_left tvfixup_folder `(() ,ttrue ) tv))
<span class="lineno" id=line189></span>        (vs (first vscs))
<span class="lineno" id=line190></span>        (cs (second vscs))
<span class="lineno" id=line191></span>        (rtc (first ct))
<span class="lineno" id=line192></span>        (rtr (second ct))
<span class="lineno" id=line193></span>        (ct `((typ_andchain (,rtc ,cs)) ,rtr))
<span class="lineno" id=line194></span>      )
<span class="lineno" id=line195></span>      (begin
<span class="lineno" id=line196></span>      ;;  (display "\nvs=")(display vs)
<span class="lineno" id=line197></span>      ;;  (display "\\ncs=")(display cs)
<span class="lineno" id=line198></span>      ;;  (display "\\nrtc=")(display rtc)
<span class="lineno" id=line199></span>      ;;  (display "\\nrtr=")(display rtr)
<span class="lineno" id=line200></span>      ;;  (display "\\nct=")(display ct)
<span class="lineno" id=line201></span>      ;;  (display "\\n")
<span class="lineno" id=line202></span>      (list (reverse vs) ct))
<span class="lineno" id=line203></span>    )
<span class="lineno" id=line204></span>  ))
<span class="lineno" id=line205></span>  """</span>;
<span class="lineno" id=line206></span>  
<span class="lineno" id=line207></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line208></span>    (define (maybe k)(if (null? k)'none `(some ,(first k))))
<span class="lineno" id=line209></span>  """</span>;
<span class="lineno" id=line210></span>  
<span class="lineno" id=line211></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line212></span>    (define (strap a b)
<span class="lineno" id=line213></span>    (if(null? b)a(if(equal? b "")a(if(equal? a "")b(string-append a " " b)))))
<span class="lineno" id=line214></span>  """</span>;
<span class="lineno" id=line215></span>  
<span class="lineno" id=line216></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line217></span>    (define (strcat ls)(fold_left strap "" ls))
<span class="lineno" id=line218></span>  """</span>;
<span class="lineno" id=line219></span>  
<span class="lineno" id=line220></span>  <span class="comment">// chain 'and (x) yields just x,</span>
<span class="lineno" id=line221></span>  <span class="comment">// chain 'and (x y) yields ('and _sr (x y))</span>
<span class="lineno" id=line222></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line223></span>    (define (chain op hd tl)
<span class="lineno" id=line224></span>      (
<span class="lineno" id=line225></span>        if (equal? tl ())
<span class="lineno" id=line226></span>        hd
<span class="lineno" id=line227></span>        `(,op ,_sr ,(cons hd (map second tl)))
<span class="lineno" id=line228></span>      )
<span class="lineno" id=line229></span>    )
<span class="lineno" id=line230></span>  """</span>;
<span class="lineno" id=line231></span>  
<span class="lineno" id=line232></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line233></span>    (define (infix op) `(ast_apply ,_sr (,(noi op) (ast_tuple ,_sr (,_1 ,_3)))))
<span class="lineno" id=line234></span>  """</span>;
<span class="lineno" id=line235></span>  
<span class="lineno" id=line236></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line237></span>    (define (binop f a b)`(ast_apply ,_sr (,f (ast_tuple ,_sr (,a ,b)))))
<span class="lineno" id=line238></span>  """</span>;
<span class="lineno" id=line239></span>  
<span class="lineno" id=line240></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line241></span>    (define (tbinop f a b)`(typ_apply ,_sr (,f (typ_type_tuple ,_sr (,a ,b)))))
<span class="lineno" id=line242></span>  """</span>;
<span class="lineno" id=line243></span>   
<span class="lineno" id=line244></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line245></span>    (define (prefix op) `(ast_apply ,_sr (,(noi op) ,_2)))
<span class="lineno" id=line246></span>  """</span>;
<span class="lineno" id=line247></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line248></span>    (define (tprefix op) `(typ_apply ,_sr (,(noi op) ,_2)))
<span class="lineno" id=line249></span>  """</span>;
<span class="lineno" id=line250></span>  
<span class="lineno" id=line251></span>  
<span class="lineno" id=line252></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line253></span>    (define (suffix op) `(ast_apply ,_sr (,(noi op) ,_1)))
<span class="lineno" id=line254></span>  """</span>;
<span class="lineno" id=line255></span>  
<span class="lineno" id=line256></span>  
<span class="lineno" id=line257></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line258></span>    (define (Prefix) `(ast_apply ,_sr (,(nos _1) ,_2)))
<span class="lineno" id=line259></span>  """</span>;
<span class="lineno" id=line260></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line261></span>    (define (tPrefix) `(typ_apply ,_sr (,(nos _1) ,_2)))
<span class="lineno" id=line262></span>  """</span>;
<span class="lineno" id=line263></span>  
<span class="lineno" id=line264></span>  
<span class="lineno" id=line265></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line266></span>    (define (Infix) (binop (nos _2) _1 _3))
<span class="lineno" id=line267></span>  """</span>;
<span class="lineno" id=line268></span>  
<span class="lineno" id=line269></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line270></span>    (define (tInfix) (tbinop (nos _2) _1 _3))
<span class="lineno" id=line271></span>  """</span>;
<span class="lineno" id=line272></span>  
<span class="lineno" id=line273></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line274></span>    (define (filter pred lst) 
<span class="lineno" id=line275></span>      (reverse 
<span class="lineno" id=line276></span>        (fold_left 
<span class="lineno" id=line277></span>          (lambda (acc val) (if (pred val) (cons val acc) acc))
<span class="lineno" id=line278></span>          ()
<span class="lineno" id=line279></span>          lst
<span class="lineno" id=line280></span>        )
<span class="lineno" id=line281></span>      )
<span class="lineno" id=line282></span>    )
<span class="lineno" id=line283></span>  """</span>;
<span class="lineno" id=line284></span>  
<span class="lineno" id=line285></span>  
<span class="lineno" id=line286></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line287></span>    (define (filter_first sym lst) 
<span class="lineno" id=line288></span>      (reverse 
<span class="lineno" id=line289></span>        (fold_left 
<span class="lineno" id=line290></span>          (lambda (acc val) (if (equal? (first val) sym) (cons (tail val) acc) acc))
<span class="lineno" id=line291></span>          ()
<span class="lineno" id=line292></span>          lst
<span class="lineno" id=line293></span>        )
<span class="lineno" id=line294></span>      )
<span class="lineno" id=line295></span>    )
<span class="lineno" id=line296></span>  """</span>;
<span class="lineno" id=line297></span>  
<span class="lineno" id=line298></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line299></span>    (define (prefix? p s) 
<span class="lineno" id=line300></span>      (let
<span class="lineno" id=line301></span>        (
<span class="lineno" id=line302></span>          (pl (string-length p))
<span class="lineno" id=line303></span>          (sl (string-length s))
<span class="lineno" id=line304></span>        )
<span class="lineno" id=line305></span>        (if (&lt; pl sl) (equal? p (substring s 0 pl)) #f)
<span class="lineno" id=line306></span>      )
<span class="lineno" id=line307></span>    )
<span class="lineno" id=line308></span>  """</span>;
<span class="lineno" id=line309></span>  
<span class="lineno" id=line310></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line311></span>    (define (suffix? p s) 
<span class="lineno" id=line312></span>      (let
<span class="lineno" id=line313></span>        (
<span class="lineno" id=line314></span>          (pl (string-length p))
<span class="lineno" id=line315></span>          (sl (string-length s))
<span class="lineno" id=line316></span>        )
<span class="lineno" id=line317></span>        (if (&lt; pl sl) (equal? p (substring s (- sl pl) sl)) #f)
<span class="lineno" id=line318></span>      )
<span class="lineno" id=line319></span>    )
<span class="lineno" id=line320></span>  """</span>;
<span class="lineno" id=line321></span>  
<span class="lineno" id=line322></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line323></span>    (define (make_private s) `(ast_private ,_sr ,s))
<span class="lineno" id=line324></span>  """</span>;
<span class="lineno" id=line325></span>  
<span class="lineno" id=line326></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line327></span>    (define (SUBST term vals) 
<span class="lineno" id=line328></span>      (cond
<span class="lineno" id=line329></span>        ((symbol? term) term)
<span class="lineno" id=line330></span>        ((number? term) term)
<span class="lineno" id=line331></span>        ((string? term) term)
<span class="lineno" id=line332></span>        ((null? term) term)
<span class="lineno" id=line333></span>        ((list? term) 
<span class="lineno" id=line334></span>          (if (eq? (car term) 'PARSER_ARGUMENT)
<span class="lineno" id=line335></span>            (vector-ref vals (cadr term) )
<span class="lineno" id=line336></span>            (map (lambda (term) (SUBST term vals)) term)
<span class="lineno" id=line337></span>          )
<span class="lineno" id=line338></span>        )
<span class="lineno" id=line339></span>      ) 
<span class="lineno" id=line340></span>    )
<span class="lineno" id=line341></span>  """</span>;
<span class="lineno" id=line342></span>  
<span class="lineno" id=line343></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line344></span>    (define (stringof s) 
<span class="lineno" id=line345></span>      `(ast_literal ,_sr "string" ,s ,(string-append "::std::string(\"" s "\")"))
<span class="lineno" id=line346></span>    )
<span class="lineno" id=line347></span>  """</span>;
<span class="lineno" id=line348></span>  
</pre></p></div><h2 id='String_like_literals._h'><img src='/share/src/web/images/minus.gif' id='String like literals.' onclick='toggle(this,"String_like_literals._d")' alt='+'/> 2.15 String like literals.</h2><div id='String_like_literals._d' style='display:block'>
<p>Note some of these forms are not strings.
</p><pre class='inclusion'>
share/lib/grammar/grammar_string_lexer.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line3></span>  (define (decode-string s) 
<span class="lineno" id=line4></span>    (begin 
<span class="lineno" id=line5></span>      (adjust-linecount s)
<span class="lineno" id=line6></span>      (let* 
<span class="lineno" id=line7></span>        (
<span class="lineno" id=line8></span>          (n (string-length s))
<span class="lineno" id=line9></span>          (result 
<span class="lineno" id=line10></span>            (cond
<span class="lineno" id=line11></span>              ((prefix? "@'''" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line12></span>              ((prefix? "w'''" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line13></span>              ((prefix? "W'''" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line14></span>              ((prefix? "c'''" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line15></span>              ((prefix? "C'''" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line16></span>              ((prefix? "u'''" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line17></span>              ((prefix? "U'''" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line18></span>              ((prefix? "f'''" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line19></span>              ((prefix? "F'''" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line20></span>              ((prefix? "q'''" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line21></span>              ((prefix? "Q'''" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line22></span>              ((prefix? "n'''" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line23></span>              ((prefix? "N'''" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line24></span>              ((prefix? "r'''" s)(substring s 4 (- n 3)))
<span class="lineno" id=line25></span>              ((prefix? "R'''" s)(substring s 4 (- n 3)))
<span class="lineno" id=line26></span>              ((prefix? "'''" s)(unescape (substring s 3 (- n 3))))
<span class="lineno" id=line27></span>  
<span class="lineno" id=line28></span>              ((prefix? "@\"\"\"" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line29></span>              ((prefix? "w\"\"\"" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line30></span>              ((prefix? "W\"\"\"" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line31></span>              ((prefix? "c\"\"\"" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line32></span>              ((prefix? "C\"\"\"" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line33></span>              ((prefix? "u\"\"\"" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line34></span>              ((prefix? "U\"\"\"" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line35></span>              ((prefix? "f\"\"\"" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line36></span>              ((prefix? "F\"\"\"" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line37></span>              ((prefix? "q\"\"\"" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line38></span>              ((prefix? "Q\"\"\"" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line39></span>              ((prefix? "n\"\"\"" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line40></span>              ((prefix? "N\"\"\"" s)(unescape (substring s 4 (- n 3))))
<span class="lineno" id=line41></span>              ((prefix? "r\"\"\"" s)(substring s 4 (- n 3)))
<span class="lineno" id=line42></span>              ((prefix? "R\"\"\"" s)(substring s 4 (- n 3)))
<span class="lineno" id=line43></span>              ((prefix? "\"\"\"" s)(unescape (substring s 3 (- n 3))))
<span class="lineno" id=line44></span>  
<span class="lineno" id=line45></span>              ((prefix? "@'" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line46></span>              ((prefix? "w'" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line47></span>              ((prefix? "W'" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line48></span>              ((prefix? "c'" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line49></span>              ((prefix? "C'" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line50></span>              ((prefix? "u'" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line51></span>              ((prefix? "U'" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line52></span>              ((prefix? "f'" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line53></span>              ((prefix? "F'" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line54></span>              ((prefix? "q'" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line55></span>              ((prefix? "Q'" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line56></span>              ((prefix? "n'" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line57></span>              ((prefix? "N'" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line58></span>              ((prefix? "r'" s)(substring s 2 (- n 1)))
<span class="lineno" id=line59></span>              ((prefix? "R'" s)(substring s 2 (- n 1)))
<span class="lineno" id=line60></span>              ((prefix? "'" s)(unescape (substring s 1 (- n 1))))
<span class="lineno" id=line61></span>  
<span class="lineno" id=line62></span>              ((prefix? "@\"" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line63></span>              ((prefix? "w\"" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line64></span>              ((prefix? "W\"" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line65></span>              ((prefix? "c\"" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line66></span>              ((prefix? "C\"" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line67></span>              ((prefix? "u\"" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line68></span>              ((prefix? "U\"" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line69></span>              ((prefix? "f\"" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line70></span>              ((prefix? "F\"" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line71></span>              ((prefix? "q\"" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line72></span>              ((prefix? "Q\"" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line73></span>              ((prefix? "n\"" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line74></span>              ((prefix? "N\"" s)(unescape (substring s 2 (- n 1))))
<span class="lineno" id=line75></span>              ((prefix? "r\"" s)(substring s 2 (- n 1)))
<span class="lineno" id=line76></span>              ((prefix? "R\"" s)(substring s 2 (- n 1)))
<span class="lineno" id=line77></span>              ((prefix? "\"" s)(unescape (substring s 1 (- n 1))))
<span class="lineno" id=line78></span>  
<span class="lineno" id=line79></span>              (else error) 
<span class="lineno" id=line80></span>            )
<span class="lineno" id=line81></span>          )
<span class="lineno" id=line82></span>        )
<span class="lineno" id=line83></span>        ;;(begin 
<span class="lineno" id=line84></span>        ;;   (newline)(display "string=")(display s)
<span class="lineno" id=line85></span>        ;;   (newline)(display "text=")(display result)
<span class="lineno" id=line86></span>           result
<span class="lineno" id=line87></span>        ;;)
<span class="lineno" id=line88></span>      )
<span class="lineno" id=line89></span>    )
<span class="lineno" id=line90></span>  )
<span class="lineno" id=line91></span>  """</span>;
<span class="lineno" id=line92></span>  
<span class="lineno" id=line93></span>  <span class="comment">// Scheme string to Felix string literal</span>
<span class="lineno" id=line94></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line95></span>  (define (strlit s) 
<span class="lineno" id=line96></span>      `(ast_literal ,_sr "string" ,s ,(string-append "::std::string(" (c-quote-string s) ")"))
<span class="lineno" id=line97></span>  )
<span class="lineno" id=line98></span>  """</span>;
<span class="lineno" id=line99></span>  
<span class="lineno" id=line100></span>  <span class="doccomment">String literals.</span>
<span class="lineno" id=line101></span>  <span class="doccomment">//$ Generaly we follow Python here.</span>
<span class="lineno" id=line102></span>  <span class="doccomment">Felix allows strings to be delimited by;</span>
<span class="lineno" id=line103></span>  <span class="doccomment">//$ single quotes '</span>
<span class="lineno" id=line104></span>  <span class="doccomment">double quotes "</span>
<span class="lineno" id=line105></span>  <span class="doccomment">triped single quotes '''</span>
<span class="lineno" id=line106></span>  <span class="doccomment">tripled double quotes """</span>
<span class="lineno" id=line107></span>  <span class="doccomment">//$ The single quote forms must be on a single line.</span>
<span class="lineno" id=line108></span>  <span class="doccomment">The triple quoted forms may span lines, and include embedded newline</span>
<span class="lineno" id=line109></span>  <span class="doccomment">characters.</span>
<span class="lineno" id=line110></span>  <span class="doccomment">//$ These forms all allows embedded escape codes.</span>
<span class="lineno" id=line111></span>  <span class="doccomment">These are:</span>
<span class="lineno" id=line112></span>  <span class="doccomment">//$  \a  -  7 : bell</span>
<span class="lineno" id=line113></span>  <span class="doccomment"> \b  -  8 : backspace</span>
<span class="lineno" id=line114></span>  <span class="doccomment"> \t  -  9 : horizontal tab</span>
<span class="lineno" id=line115></span>  <span class="doccomment"> \n  - 10 : linefeed, newline</span>
<span class="lineno" id=line116></span>  <span class="doccomment"> \r  - 13 : carriage return</span>
<span class="lineno" id=line117></span>  <span class="doccomment"> \v  - 11 : vertical tab</span>
<span class="lineno" id=line118></span>  <span class="doccomment"> \f  - 12 :form feed</span>
<span class="lineno" id=line119></span>  <span class="doccomment"> \e  - 27 : escape</span>
<span class="lineno" id=line120></span>  <span class="doccomment"> \\  - \  : slosh</span>
<span class="lineno" id=line121></span>  <span class="doccomment"> \"  - "  : double quote</span>
<span class="lineno" id=line122></span>  <span class="doccomment"> \'  - '  : single quote</span>
<span class="lineno" id=line123></span>  <span class="doccomment"> \   - 32 : space</span>
<span class="lineno" id=line124></span>  <span class="doccomment">//$  \xFF - hexadecimal character code</span>
<span class="lineno" id=line125></span>  <span class="doccomment"> \o7 \o77 \o777 -- octal character code (stops on count of 3 or non-octal character)</span>
<span class="lineno" id=line126></span>  <span class="doccomment"> \d9 \d99 \d999 -- decimal character code (stops on count of 3 or non-decimal character)</span>
<span class="lineno" id=line127></span>  <span class="doccomment"> \uFFFF - utf8 encoding of specified hex value</span>
<span class="lineno" id=line128></span>  <span class="doccomment"> \UFFFFFFFF - utf8 encoding of specified hex value</span>
<span class="lineno" id=line129></span>  <span class="doccomment">//$ A prefix "r" or "R" on a double quoted string</span>
<span class="lineno" id=line130></span>  <span class="doccomment">or triple double quoted string suppresses escape processing,</span>
<span class="lineno" id=line131></span>  <span class="doccomment">this is called a raw string literal.</span>
<span class="lineno" id=line132></span>  <span class="doccomment">NOTE: single quoted string cannot be used!</span>
<span class="lineno" id=line133></span>  <span class="doccomment">//$ A prefix "w" or "W" specifies a wide character string,</span>
<span class="lineno" id=line134></span>  <span class="doccomment">of character type wchar. DEPRECATED.</span>
<span class="lineno" id=line135></span>  <span class="doccomment">//$ A prefix of "u" or "U" specifes a string of uint32.</span>
<span class="lineno" id=line136></span>  <span class="doccomment">This is a full Unicode string. </span>
<span class="lineno" id=line137></span>  <span class="doccomment">THIS FEATURE WILL BE DEPRECATED.</span>
<span class="lineno" id=line138></span>  <span class="doccomment">IT WILL BE REPLACED BY C++11 Unicode compliant strings.</span>
<span class="lineno" id=line139></span>  <span class="doccomment">//$ A prefix of "c" or "C" specifies a C NTBS (Nul terminated</span>
<span class="lineno" id=line140></span>  <span class="doccomment">byte string) be generated instead of a C++ string.</span>
<span class="lineno" id=line141></span>  <span class="doccomment">Such a string has type +char rather than string.</span>
<span class="lineno" id=line142></span>  <span class="doccomment"></span>
<span class="lineno" id=line143></span>  <span class="doccomment">A literal prefixed by "q" or "Q" is a Perl interpolation</span>
<span class="lineno" id=line144></span>  <span class="doccomment">string. Such strings are actually functions.</span>
<span class="lineno" id=line145></span>  <span class="doccomment">Each occurrence of $(varname) in the string is replaced</span>
<span class="lineno" id=line146></span>  <span class="doccomment">at run time by the value "str varname". The type of the</span>
<span class="lineno" id=line147></span>  <span class="doccomment">variable must provide an overload of "str" which returns</span>
<span class="lineno" id=line148></span>  <span class="doccomment">a C++ string for this to work.</span>
<span class="lineno" id=line149></span>  <span class="doccomment">//$ A literal prefixed by a "f" or "F" is a C format string.</span>
<span class="lineno" id=line150></span>  <span class="doccomment">Such strings are actually functions.</span>
<span class="lineno" id=line151></span>  <span class="doccomment">The string contains code such as "%d" or other supported</span>
<span class="lineno" id=line152></span>  <span class="doccomment">C format string. Variable field width specifiers "*" are</span>
<span class="lineno" id=line153></span>  <span class="doccomment">not permitted. The additional format specification %S</span>
<span class="lineno" id=line154></span>  <span class="doccomment">is supported and requires a C++ string argument.</span>
<span class="lineno" id=line155></span>  <span class="doccomment">Such functions accept a tuple of values like this:</span>
<span class="lineno" id=line156></span>  <span class="doccomment">//$ f"%d-%S" (42, "Hello")</span>
<span class="lineno" id=line157></span>  <span class="doccomment">//$ If vsnprintf is available on the local platform it is used</span>
<span class="lineno" id=line158></span>  <span class="doccomment">to provide an implementation which cannot overrun.</span>
<span class="lineno" id=line159></span>  <span class="doccomment">If it is not, vsprintf is used instead with a 1000 character</span>
<span class="lineno" id=line160></span>  <span class="doccomment">buffer.</span>
<span class="lineno" id=line161></span>  <span class="doccomment"></span>
<span class="lineno" id=line162></span>  <span class="doccomment">The argument types and code types are fully checked for type safety.</span>
<span class="lineno" id=line163></span>  <span class="doccomment">//$ The special literal with a "n" or "N" prefix is a way to encode</span>
<span class="lineno" id=line164></span>  <span class="doccomment">an arbitrary sequence of characters as an identifer in a context</span>
<span class="lineno" id=line165></span>  <span class="doccomment">where the parser might interpret it otherwise.</span>
<span class="lineno" id=line166></span>  <span class="doccomment">It can be used, for example, to define special characters as functions.</span>
<span class="lineno" id=line167></span>  <span class="doccomment">For example:</span>
<span class="lineno" id=line168></span>  <span class="doccomment">//$ typedef fun n"@" (T:TYPE) : TYPE =&gt; cptr[T]; </span>
<span class="lineno" id=line169></span>  <span class="doccomment">syntax felix_string_lexer {</span>
<span class="lineno" id=line170></span>    <span class="comment">/* Python strings */</span>
<span class="lineno" id=line171></span>    <span class="big_keyword" title="define named regular expression">regdef</span> qqq = quote quote quote;
<span class="lineno" id=line172></span>    <span class="big_keyword" title="define named regular expression">regdef</span> ddd = dquote dquote dquote;
<span class="lineno" id=line173></span>  
<span class="lineno" id=line174></span>    <span class="big_keyword" title="define named regular expression">regdef</span> escape = slosh _;
<span class="lineno" id=line175></span>  
<span class="lineno" id=line176></span>    <span class="big_keyword" title="define named regular expression">regdef</span> dddnormal = ordinary | hash | quote | escape | white | newline;
<span class="lineno" id=line177></span>    <span class="big_keyword" title="define named regular expression">regdef</span> dddspecial = dddnormal | dquote dddnormal | dquote dquote dddnormal;
<span class="lineno" id=line178></span>  
<span class="lineno" id=line179></span>    <span class="big_keyword" title="define named regular expression">regdef</span> qqqnormal = ordinary | hash | dquote | escape | white | newline;
<span class="lineno" id=line180></span>    <span class="big_keyword" title="define named regular expression">regdef</span> qqqspecial = qqqnormal | quote qqqnormal | quote quote qqqnormal;
<span class="lineno" id=line181></span>  
<span class="lineno" id=line182></span>    <span class="big_keyword" title="define named regular expression">regdef</span> qstring_tail = (ordinary | hash | dquote | escape | white) * quote;
<span class="lineno" id=line183></span>    <span class="big_keyword" title="define named regular expression">regdef</span> dstring_tail = (ordinary | hash | quote | escape | white) * dquote;
<span class="lineno" id=line184></span>    <span class="big_keyword" title="define named regular expression">regdef</span> qqqstring_tail = qqqspecial * qqq;
<span class="lineno" id=line185></span>    <span class="big_keyword" title="define named regular expression">regdef</span> dddstring_tail = dddspecial * ddd;
<span class="lineno" id=line186></span>  
<span class="lineno" id=line187></span>    <span class="big_keyword" title="define named regular expression">regdef</span> qstring = quote qstring_tail;
<span class="lineno" id=line188></span>    <span class="big_keyword" title="define named regular expression">regdef</span> dstring = dquote dstring_tail;
<span class="lineno" id=line189></span>    <span class="big_keyword" title="define named regular expression">regdef</span> qqqstring = qqq qqqstring_tail;
<span class="lineno" id=line190></span>    <span class="big_keyword" title="define named regular expression">regdef</span> dddstring = ddd dddstring_tail;
<span class="lineno" id=line191></span>  
<span class="lineno" id=line192></span>  
<span class="lineno" id=line193></span>    <span class="big_keyword" title="define named regular expression">regdef</span> raw_dddnormal = ordinary | hash | quote | slosh | white | newline;
<span class="lineno" id=line194></span>    <span class="big_keyword" title="define named regular expression">regdef</span> raw_dddspecial = raw_dddnormal | dquote raw_dddnormal | dquote dquote raw_dddnormal;
<span class="lineno" id=line195></span>  
<span class="lineno" id=line196></span>    <span class="big_keyword" title="define named regular expression">regdef</span> raw_qqqnormal = ordinary | hash | dquote | slosh | space | newline;
<span class="lineno" id=line197></span>    <span class="big_keyword" title="define named regular expression">regdef</span> raw_qqqspecial = raw_qqqnormal | quote raw_qqqnormal | quote quote raw_qqqnormal;
<span class="lineno" id=line198></span>  
<span class="lineno" id=line199></span>    <span class="big_keyword" title="define named regular expression">regdef</span> raw = <span class="fstring">'r'</span> | <span class="fstring">'R'</span>;
<span class="lineno" id=line200></span>  
<span class="lineno" id=line201></span>    <span class="big_keyword" title="define named regular expression">regdef</span> raw_dstring_tail =  (ordinary | hash | quote | escape | white) * dquote;
<span class="lineno" id=line202></span>    <span class="big_keyword" title="define named regular expression">regdef</span> raw_qqqstring_tail = raw_qqqspecial * qqq;
<span class="lineno" id=line203></span>    <span class="big_keyword" title="define named regular expression">regdef</span> raw_dddstring_tail = raw_dddspecial * ddd;
<span class="lineno" id=line204></span>  
<span class="lineno" id=line205></span>    <span class="big_keyword" title="define named regular expression">regdef</span> raw_dstring = raw dquote dstring_tail;
<span class="lineno" id=line206></span>    <span class="big_keyword" title="define named regular expression">regdef</span> raw_qqqstring = raw qqq qqqstring_tail;
<span class="lineno" id=line207></span>    <span class="big_keyword" title="define named regular expression">regdef</span> raw_dddstring = raw ddd dddstring_tail;
<span class="lineno" id=line208></span>  
<span class="lineno" id=line209></span>    <span class="big_keyword" title="define named regular expression">regdef</span> plain_string_literal = dstring | qqqstring | dddstring;
<span class="lineno" id=line210></span>    <span class="big_keyword" title="define named regular expression">regdef</span> raw_string_literal = raw_dstring | raw_qqqstring | raw_dddstring;
<span class="lineno" id=line211></span>  
<span class="lineno" id=line212></span>    <span class="big_keyword" title="define named regular expression">regdef</span> string_literal = plain_string_literal | qstring | raw_string_literal;
<span class="lineno" id=line213></span>  
<span class="lineno" id=line214></span>    <span class="big_keyword" title="define named regular expression">regdef</span> NSString_literal = <span class="fstring">'@'</span> plain_string_literal; 
<span class="lineno" id=line215></span>    <span class="big_keyword" title="define named regular expression">regdef</span> wstring_literal = (<span class="fstring">'w'</span> | <span class="fstring">'W'</span>) plain_string_literal; 
<span class="lineno" id=line216></span>    <span class="big_keyword" title="define named regular expression">regdef</span> ustring_literal = (<span class="fstring">'u'</span> | <span class="fstring">'U'</span>) plain_string_literal; 
<span class="lineno" id=line217></span>    <span class="big_keyword" title="define named regular expression">regdef</span> cstring_literal = (<span class="fstring">'c'</span> | <span class="fstring">'C'</span>) plain_string_literal; 
<span class="lineno" id=line218></span>    <span class="big_keyword" title="define named regular expression">regdef</span> qstring_literal = (<span class="fstring">'q'</span> | <span class="fstring">'Q'</span>) plain_string_literal; 
<span class="lineno" id=line219></span>    <span class="big_keyword" title="define named regular expression">regdef</span> fstring_literal = (<span class="fstring">'f'</span> | <span class="fstring">'F'</span>) plain_string_literal; 
<span class="lineno" id=line220></span>    <span class="big_keyword" title="define named regular expression">regdef</span> nstring_literal = (<span class="fstring">'n'</span> | <span class="fstring">'N'</span>) plain_string_literal; 
<span class="lineno" id=line221></span>  
<span class="lineno" id=line222></span>     <span class="comment">// String as name.</span>
<span class="lineno" id=line223></span>    <span class="big_keyword" title="define literal">literal</span> nstring_literal =&gt;# <span class="fstring">"(decode-string _1)"</span>;
<span class="lineno" id=line224></span>    sname := nstring_literal =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line225></span>  
<span class="lineno" id=line226></span>    <span class="comment">// String for pattern or code template.</span>
<span class="lineno" id=line227></span>    <span class="big_keyword" title="define named regular expression">regdef</span> sstring = string_literal;
<span class="lineno" id=line228></span>    <span class="big_keyword" title="define literal">literal</span> sstring =&gt;# <span class="fstring">"(decode-string _1)"</span>;
<span class="lineno" id=line229></span>  
<span class="lineno" id=line230></span>    <span class="comment">// Cstring for code.</span>
<span class="lineno" id=line231></span>    <span class="big_keyword" title="define named regular expression">regdef</span> scstring = cstring_literal;
<span class="lineno" id=line232></span>    <span class="big_keyword" title="define literal">literal</span> scstring =&gt;# <span class="fstring">"(decode-string _1)"</span>;
<span class="lineno" id=line233></span>  
<span class="lineno" id=line234></span>    <span class="comment">// String for string parser.</span>
<span class="lineno" id=line235></span>    <span class="big_keyword" title="define named regular expression">regdef</span> strstring = string_literal;
<span class="lineno" id=line236></span>    <span class="big_keyword" title="define literal">literal</span> strstring =&gt;# <span class="fstring">"(c-quote-string (decode-string _1))"</span>;
<span class="lineno" id=line237></span>  
<span class="lineno" id=line238></span>    <span class="comment">// String like literals.</span>
<span class="lineno" id=line239></span>    <span class="big_keyword" title="define named regular expression">regdef</span> String = string_literal;
<span class="lineno" id=line240></span>    <span class="big_keyword" title="define literal">literal</span> String =&gt;# <span class="fstring">"""
<span class="lineno" id=line241></span>      (let*
<span class="lineno" id=line242></span>        (
<span class="lineno" id=line243></span>          (ftype "string")
<span class="lineno" id=line244></span>          (iv (decode-string _1))
<span class="lineno" id=line245></span>          (cv (c-quote-string iv))
<span class="lineno" id=line246></span>          (cv (string-append "::std::string(" cv ")"))
<span class="lineno" id=line247></span>        )
<span class="lineno" id=line248></span>        `(ast_literal ,_sr ,ftype ,iv ,cv)
<span class="lineno" id=line249></span>      )
<span class="lineno" id=line250></span>    """</span>;
<span class="lineno" id=line251></span>    sliteral := String =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line252></span>  
<span class="lineno" id=line253></span>    <span class="comment">// String like literals.</span>
<span class="lineno" id=line254></span>    <span class="big_keyword" title="define named regular expression">regdef</span> NSString = NSString_literal;
<span class="lineno" id=line255></span>    <span class="big_keyword" title="define literal">literal</span> NSString =&gt;# <span class="fstring">"""
<span class="lineno" id=line256></span>      (let*
<span class="lineno" id=line257></span>        (
<span class="lineno" id=line258></span>          (ftype "NSString")
<span class="lineno" id=line259></span>          (iv (decode-string _1))
<span class="lineno" id=line260></span>          (cv (c-quote-string iv))
<span class="lineno" id=line261></span>          (cv (string-append "@" cv))
<span class="lineno" id=line262></span>        )
<span class="lineno" id=line263></span>        `(ast_literal ,_sr ,ftype ,iv ,cv)
<span class="lineno" id=line264></span>      )
<span class="lineno" id=line265></span>    """</span>;
<span class="lineno" id=line266></span>    sliteral := NSString =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line267></span>  
<span class="lineno" id=line268></span>    <span class="big_keyword" title="define named regular expression">regdef</span> Wstring = wstring_literal;
<span class="lineno" id=line269></span>    <span class="big_keyword" title="define literal">literal</span> Wstring =&gt;# <span class="fstring">"""
<span class="lineno" id=line270></span>      (let*
<span class="lineno" id=line271></span>        (
<span class="lineno" id=line272></span>          (ftype "wstring")
<span class="lineno" id=line273></span>          (iv (decode-string _1))
<span class="lineno" id=line274></span>          (cv (c-quote-string iv))
<span class="lineno" id=line275></span>          (cv (string-append "wstring(" cv ")"))
<span class="lineno" id=line276></span>        )
<span class="lineno" id=line277></span>        `(ast_literal ,_sr ,ftype ,iv ,cv)
<span class="lineno" id=line278></span>      )
<span class="lineno" id=line279></span>    """</span>;
<span class="lineno" id=line280></span>    sliteral := Wstring =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line281></span>  
<span class="lineno" id=line282></span>    <span class="big_keyword" title="define named regular expression">regdef</span> Ustring = ustring_literal;
<span class="lineno" id=line283></span>    <span class="big_keyword" title="define literal">literal</span> Ustring =&gt;# <span class="fstring">"""
<span class="lineno" id=line284></span>      (let*
<span class="lineno" id=line285></span>        (
<span class="lineno" id=line286></span>          (ftype "ustring")
<span class="lineno" id=line287></span>          (iv (decode-string _1))
<span class="lineno" id=line288></span>          (cv (c-quote-string iv))
<span class="lineno" id=line289></span>          (cv (string-append "ustring(" cv ")"))
<span class="lineno" id=line290></span>        )
<span class="lineno" id=line291></span>        `(ast_literal ,_sr ,ftype ,iv ,cv)
<span class="lineno" id=line292></span>      )
<span class="lineno" id=line293></span>    """</span>;
<span class="lineno" id=line294></span>    sliteral := Ustring =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line295></span>  
<span class="lineno" id=line296></span>    <span class="big_keyword" title="define named regular expression">regdef</span> Cstring = cstring_literal;
<span class="lineno" id=line297></span>    <span class="big_keyword" title="define literal">literal</span> Cstring =&gt;#
<span class="lineno" id=line298></span>    <span class="fstring">"""
<span class="lineno" id=line299></span>      (let*
<span class="lineno" id=line300></span>        (
<span class="lineno" id=line301></span>          (ftype "cstring")
<span class="lineno" id=line302></span>          (iv (decode-string _1))
<span class="lineno" id=line303></span>          (cv (c-quote-string iv))
<span class="lineno" id=line304></span>        )
<span class="lineno" id=line305></span>        `(ast_literal ,_sr ,ftype ,iv ,cv)
<span class="lineno" id=line306></span>      )
<span class="lineno" id=line307></span>    """</span>; 
<span class="lineno" id=line308></span>    sliteral := Cstring =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line309></span>  
<span class="lineno" id=line310></span>    <span class="big_keyword" title="define named regular expression">regdef</span> Qstring = qstring_literal;
<span class="lineno" id=line311></span>    <span class="big_keyword" title="define literal">literal</span> Qstring =&gt;# <span class="fstring">"`(ast_interpolate ,_sr ,(decode-string _1))"</span>;
<span class="lineno" id=line312></span>    sliteral := Qstring =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line313></span>  
<span class="lineno" id=line314></span>    <span class="big_keyword" title="define named regular expression">regdef</span> Fstring = fstring_literal;
<span class="lineno" id=line315></span>    <span class="big_keyword" title="define literal">literal</span> Fstring =&gt;# <span class="fstring">"`(ast_vsprintf ,_sr ,(decode-string _1))"</span>;
<span class="lineno" id=line316></span>    sliteral := Fstring =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line317></span>  
<span class="lineno" id=line318></span>  }
<span class="lineno" id=line319></span>  
</pre></p></div><h2 id='Loops_h'><img src='/share/src/web/images/minus.gif' id='Loops' onclick='toggle(this,"Loops_d")' alt='+'/> 2.16 Loops</h2><div id='Loops_d' style='display:block'>
<pre class='inclusion'>
share/lib/grammar/loops.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line2></span>      (define (notnumeric s) (fold_left notdigit #f (string-&gt;list s)))
<span class="lineno" id=line3></span>    """</span>;
<span class="lineno" id=line4></span>  
<span class="lineno" id=line5></span>    <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line6></span>      (define (check-label first last term) 
<span class="lineno" id=line7></span>        (if 
<span class="lineno" id=line8></span>          (notnumeric first) 
<span class="lineno" id=line9></span>          (if 
<span class="lineno" id=line10></span>            (equal? first last) 
<span class="lineno" id=line11></span>            term 
<span class="lineno" id=line12></span>            (begin   
<span class="lineno" id=line13></span>              (display (string-append first " != " last " giveup\n"))
<span class="lineno" id=line14></span>              (giveup)
<span class="lineno" id=line15></span>            )
<span class="lineno" id=line16></span>          )
<span class="lineno" id=line17></span>          (if 
<span class="lineno" id=line18></span>            (equal? "" last) 
<span class="lineno" id=line19></span>            term
<span class="lineno" id=line20></span>            (begin   
<span class="lineno" id=line21></span>              (display (string-append first " != " last " giveup\n"))
<span class="lineno" id=line22></span>              (giveup)
<span class="lineno" id=line23></span>            )
<span class="lineno" id=line24></span>          )
<span class="lineno" id=line25></span>        )
<span class="lineno" id=line26></span>      )
<span class="lineno" id=line27></span>      """</span>;
<span class="lineno" id=line28></span>     
<span class="lineno" id=line29></span>  <span class="doccomment">Primary looping contructs.</span>
<span class="lineno" id=line30></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line31></span>     (define (assign_incluploop)
<span class="lineno" id=line32></span>      `(ast_seq ,_sr
<span class="lineno" id=line33></span>        ,(append 
<span class="lineno" id=line34></span>          `((ast_assign ,_sr _set ((Expr ,_sr (ast_name ,_sr ,_3 ())) none) ,_5))
<span class="lineno" id=line35></span>          `((ast_label ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line36></span>          `((ast_unlikely_ifnotgoto ,_sr
<span class="lineno" id=line37></span>            ,(binop (noi '&lt;=) `(ast_name ,_sr ,_3 ()) _7)
<span class="lineno" id=line38></span>            ,(string-append "break_" _1)
<span class="lineno" id=line39></span>          ))
<span class="lineno" id=line40></span>          `(,_8)
<span class="lineno" id=line41></span>          `((ast_label ,_sr ,(string-append "continue_" _1)))
<span class="lineno" id=line42></span>          `((ast_unlikely_ifgoto ,_sr 
<span class="lineno" id=line43></span>            ,(binop (noi '==) `(ast_name ,_sr ,_3 ()) _7) ;; unfortunate but necessary to stop incrementing past the bound
<span class="lineno" id=line44></span>            ,(string-append "break_" _1)
<span class="lineno" id=line45></span>          ))
<span class="lineno" id=line46></span>          `((ast_call ,_sr ,(noi 'pre_incr) (ast_ref ,_sr (ast_name ,_sr ,_3()))))
<span class="lineno" id=line47></span>          `((ast_goto ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line48></span>          `((ast_label ,_sr ,(string-append "break_" _1)))
<span class="lineno" id=line49></span>         ))
<span class="lineno" id=line50></span>      )
<span class="lineno" id=line51></span>      """</span>;
<span class="lineno" id=line52></span>  
<span class="lineno" id=line53></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line54></span>     (define (define_incluploop)
<span class="lineno" id=line55></span>      `(ast_seq ,_sr
<span class="lineno" id=line56></span>        ,(append 
<span class="lineno" id=line57></span>          `((ast_var_decl ,_sr ,_3 ,dfltvs none (some ,_5)))
<span class="lineno" id=line58></span>          `((ast_label ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line59></span>          `((ast_unlikely_ifnotgoto ,_sr
<span class="lineno" id=line60></span>            ,(binop (noi '&lt;=) `(ast_name ,_sr ,_3 ()) _7)
<span class="lineno" id=line61></span>            ,(string-append "break_" _1)
<span class="lineno" id=line62></span>          ))
<span class="lineno" id=line63></span>          `(,_8)
<span class="lineno" id=line64></span>          `((ast_label ,_sr ,(string-append "continue_" _1)))
<span class="lineno" id=line65></span>          `((ast_unlikely_ifgoto ,_sr 
<span class="lineno" id=line66></span>            ,(binop (noi '==) `(ast_name ,_sr ,_3 ()) _7) ;; unfortunate but necessary to stop incrementing past the bound
<span class="lineno" id=line67></span>            ,(string-append "break_" _1)
<span class="lineno" id=line68></span>          ))
<span class="lineno" id=line69></span>          `((ast_call ,_sr ,(noi 'pre_incr) (ast_ref ,_sr (ast_name ,_sr ,_3()))))
<span class="lineno" id=line70></span>          `((ast_goto ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line71></span>          `((ast_label ,_sr ,(string-append "break_" _1)))
<span class="lineno" id=line72></span>         ))
<span class="lineno" id=line73></span>    )
<span class="lineno" id=line74></span>    """</span>;
<span class="lineno" id=line75></span>  
<span class="lineno" id=line76></span>  <span class="comment">//  loop_stmt := optlabel "for" sname "in" sexpr "..&lt;" sexpr block =&gt;# "(define_excluploop)";</span>
<span class="lineno" id=line77></span>  <span class="comment">//                   1           3          5            7     8</span>
<span class="lineno" id=line78></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line79></span>     (define (define_excluploop)
<span class="lineno" id=line80></span>      `(ast_seq ,_sr
<span class="lineno" id=line81></span>        ,(append 
<span class="lineno" id=line82></span>          `((ast_var_decl ,_sr ,_3 ,dfltvs none (some ,_5)))
<span class="lineno" id=line83></span>          `((ast_label ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line84></span>          `((ast_unlikely_ifnotgoto ,_sr
<span class="lineno" id=line85></span>            ,(binop (noi '&lt;) `(ast_name ,_sr ,_3 ()) _7)
<span class="lineno" id=line86></span>            ,(string-append "break_" _1)
<span class="lineno" id=line87></span>          ))
<span class="lineno" id=line88></span>          `(,_8)
<span class="lineno" id=line89></span>          `((ast_label ,_sr ,(string-append "continue_" _1)))
<span class="lineno" id=line90></span>          `((ast_call ,_sr ,(noi 'pre_incr) (ast_ref ,_sr (ast_name ,_sr ,_3()))))
<span class="lineno" id=line91></span>          `((ast_goto ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line92></span>          `((ast_label ,_sr ,(string-append "break_" _1)))
<span class="lineno" id=line93></span>         ))
<span class="lineno" id=line94></span>      )
<span class="lineno" id=line95></span>      """</span>;
<span class="lineno" id=line96></span>  
<span class="lineno" id=line97></span>  
<span class="lineno" id=line98></span>  
<span class="lineno" id=line99></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line100></span>    (define iterator_recursive_loop 
<span class="lineno" id=line101></span>      (lambda (loopname cvar iterator body) 
<span class="lineno" id=line102></span>        (begin (display "Eval iterator recursive loop\n")
<span class="lineno" id=line103></span>        (let* 
<span class="lineno" id=line104></span>          (
<span class="lineno" id=line105></span>            (proc_string_name (fresh_name "proc"))
<span class="lineno" id=line106></span>            (proc_call_name (nos proc_string_name))
<span class="lineno" id=line107></span>            (proc_param dfltparams)
<span class="lineno" id=line108></span>            (proc_ret `((ast_void ,_sr) none))
<span class="lineno" id=line109></span>            (proc_adjectives `())
<span class="lineno" id=line110></span>            (proccall `(ast_call ,_sr ,proc_call_name (ast_tuple ,_sr ())))
<span class="lineno" id=line111></span>            (generator_string_name (fresh_name "generator" ))
<span class="lineno" id=line112></span>            (generator_call_name (nos generator_string_name))
<span class="lineno" id=line113></span>            (generator_init `(ast_apply ,_sr (,(nos "iterator") ,iterator )))
<span class="lineno" id=line114></span>            (generator_call `(ast_apply ,_sr (,generator_call_name ())))
<span class="lineno" id=line115></span>            (some_pattern `(pat_nonconst_ctor ,_sr ,(nos "Some") (pat_as ,_sr (pat_any ,_sr) ,cvar) ))
<span class="lineno" id=line116></span>            (some_exit proccall) 
<span class="lineno" id=line117></span>            (some_handler (append `(,body) `(,some_exit)))
<span class="lineno" id=line118></span>            (none_pattern `(pat_const_ctor ,_sr ,(nos "None")))
<span class="lineno" id=line119></span>            (none_handler `((ast_nop ,_sr, "drop thru")))
<span class="lineno" id=line120></span>            (some_item `(,some_pattern ,some_handler))
<span class="lineno" id=line121></span>            (none_item `(,none_pattern ,none_handler))
<span class="lineno" id=line122></span>            (matchings `(,some_item ,none_item))
<span class="lineno" id=line123></span>            (proc_body 
<span class="lineno" id=line124></span>              `( ast_seq ,_sr 
<span class="lineno" id=line125></span>                (
<span class="lineno" id=line126></span>                  (ast_label ,_sr ,(string-append "continue_" loopname))
<span class="lineno" id=line127></span>                  (ast_stmt_match (,_sr ,generator_call ,matchings))
<span class="lineno" id=line128></span>                  (ast_label ,_sr ,(string-append "break_" loopname))
<span class="lineno" id=line129></span>                )
<span class="lineno" id=line130></span>              )
<span class="lineno" id=line131></span>            )
<span class="lineno" id=line132></span>            (vardef `(ast_var_decl ,_sr ,generator_string_name ,dfltvs none (some ,generator_init)))
<span class="lineno" id=line133></span>            (procdef 
<span class="lineno" id=line134></span>              `(
<span class="lineno" id=line135></span>                ast_curry_effects ,_sr ,proc_string_name ,dfltvs ,proc_param ,proc_ret ,dflteffects 
<span class="lineno" id=line136></span>                Function ,proc_adjectives (,proc_body)
<span class="lineno" id=line137></span>              )
<span class="lineno" id=line138></span>            )
<span class="lineno" id=line139></span>          )
<span class="lineno" id=line140></span>          `(ast_seq ,_sr (,vardef ,procdef ,proccall))
<span class="lineno" id=line141></span>        )
<span class="lineno" id=line142></span>        ) ;;display
<span class="lineno" id=line143></span>      )
<span class="lineno" id=line144></span>    )
<span class="lineno" id=line145></span>  """</span>;
<span class="lineno" id=line146></span>  
<span class="lineno" id=line147></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> loops
<span class="lineno" id=line148></span>  {
<span class="lineno" id=line149></span>    <span class="big_keyword" title="specify requirements">requires</span> blocks;
<span class="lineno" id=line150></span>    <span class="comment">// ----------------------------------------------------------------------------------</span>
<span class="lineno" id=line151></span>    <span class="comment">// Synopsis of loop forms</span>
<span class="lineno" id=line152></span>    <span class="comment">// ----------------------------------------------------------------------------------</span>
<span class="lineno" id=line153></span>    stmt = escape_stmt;
<span class="lineno" id=line154></span>    block = loop_stmt;
<span class="lineno" id=line155></span>  
<span class="lineno" id=line156></span>    <span class="comment">// ----------------------------------------------------------------------------------</span>
<span class="lineno" id=line157></span>    <span class="doccomment">Statement groups controlled by loops</span>
<span class="lineno" id=line158></span>    <span class="comment">// ----------------------------------------------------------------------------------</span>
<span class="lineno" id=line159></span>  
<span class="lineno" id=line160></span>    <span class="comment">// ----------------------------------------------------------------------------------</span>
<span class="lineno" id=line161></span>    <span class="comment">// Escape statements for deviant processing</span>
<span class="lineno" id=line162></span>    <span class="comment">// ----------------------------------------------------------------------------------</span>
<span class="lineno" id=line163></span>    <span class="doccomment">Labelled break.</span>
<span class="lineno" id=line164></span>    <span class="doccomment">Use to exit from the loop with the specified label.</span>
<span class="lineno" id=line165></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> escape_stmt := <span class="fstring">"break"</span> sname =&gt;# <span class="fstring">'`(ast_goto ,_sr ,(string-append "break_" _2))'</span>;
<span class="lineno" id=line166></span>  
<span class="lineno" id=line167></span>    <span class="doccomment">Labelled continue.</span>
<span class="lineno" id=line168></span>    <span class="doccomment">Use to continue with the next iteration of the loop with the specified label.</span>
<span class="lineno" id=line169></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> escape_stmt := <span class="fstring">"continue"</span> sname =&gt;# <span class="fstring">'`(ast_goto ,_sr ,(string-append "continue_" _2))'</span>;
<span class="lineno" id=line170></span>  
<span class="lineno" id=line171></span>    <span class="doccomment">Labelled redo.</span>
<span class="lineno" id=line172></span>    <span class="doccomment">Use to restart this iteration of the loop with the specified label.</span>
<span class="lineno" id=line173></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> escape_stmt := <span class="fstring">"redo"</span> sname =&gt;# <span class="fstring">'`(ast_goto ,_sr ,(string-append "redo_" _2))'</span>;
<span class="lineno" id=line174></span>  
<span class="lineno" id=line175></span>    <span class="comment">// ----------------------------------------------------------------------------------</span>
<span class="lineno" id=line176></span>    <span class="doccomment">Syntax for a loop label. Used by escapes to indicate which loop.</span>
<span class="lineno" id=line177></span>    <span class="comment">// ----------------------------------------------------------------------------------</span>
<span class="lineno" id=line178></span>    <span class="doccomment">Use just before the loop.</span>
<span class="lineno" id=line179></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> optlabel := sname <span class="fstring">":"</span> =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line180></span>  
<span class="lineno" id=line181></span>    <span class="doccomment">Loop labels aren't required.</span>
<span class="lineno" id=line182></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> optlabel := sepsilon =&gt;# <span class="fstring">'(fresh_name "ll")'</span>;
<span class="lineno" id=line183></span>  
<span class="lineno" id=line184></span>    <span class="comment">// ----------------------------------------------------------------------------------</span>
<span class="lineno" id=line185></span>    <span class="comment">// the loops</span>
<span class="lineno" id=line186></span>    <span class="comment">// ----------------------------------------------------------------------------------</span>
<span class="lineno" id=line187></span>    <span class="doccomment">Standard while loop.</span>
<span class="lineno" id=line188></span>    loop_stmt := optlabel <span class="fstring">"while"</span> sexpr block =&gt;#
<span class="lineno" id=line189></span>      <span class="fstring">""" 
<span class="lineno" id=line190></span>      `(ast_seq ,_sr
<span class="lineno" id=line191></span>        ,(list
<span class="lineno" id=line192></span>          `(ast_label ,_sr ,(string-append "continue_" _1))
<span class="lineno" id=line193></span>          `(ast_unlikely_ifnotgoto ,_sr ,_3 ,(string-append "break_" _1))
<span class="lineno" id=line194></span>          _4
<span class="lineno" id=line195></span>          `(ast_goto ,_sr ,(string-append "continue_" _1))
<span class="lineno" id=line196></span>          `(ast_label ,_sr ,(string-append "break_" _1))
<span class="lineno" id=line197></span>      ))
<span class="lineno" id=line198></span>      """</span>;
<span class="lineno" id=line199></span>  
<span class="lineno" id=line200></span>    <span class="doccomment">repeat loop.</span>
<span class="lineno" id=line201></span>    loop_stmt := optlabel <span class="fstring">"repeat"</span> block =&gt;#
<span class="lineno" id=line202></span>      <span class="fstring">""" 
<span class="lineno" id=line203></span>      `(ast_seq ,_sr
<span class="lineno" id=line204></span>        ,(list
<span class="lineno" id=line205></span>          `(ast_label ,_sr ,(string-append "continue_" _1))
<span class="lineno" id=line206></span>          _3
<span class="lineno" id=line207></span>          `(ast_goto ,_sr ,(string-append "continue_" _1))
<span class="lineno" id=line208></span>          `(ast_label ,_sr ,(string-append "break_" _1))
<span class="lineno" id=line209></span>      ))
<span class="lineno" id=line210></span>      """</span>;
<span class="lineno" id=line211></span>  
<span class="lineno" id=line212></span>  
<span class="lineno" id=line213></span>    <span class="doccomment">Negated while loop.</span>
<span class="lineno" id=line214></span>    loop_stmt := optlabel <span class="fstring">"until"</span> sexpr block =&gt;#
<span class="lineno" id=line215></span>      <span class="fstring">"""
<span class="lineno" id=line216></span>      `(ast_seq ,_sr
<span class="lineno" id=line217></span>        ,(append 
<span class="lineno" id=line218></span>          `(( ast_label ,_sr ,(string-append "continue_" _1)))
<span class="lineno" id=line219></span>          `(( ast_unlikely_ifgoto ,_sr ,_3 ,(string-append "break_" _1)))
<span class="lineno" id=line220></span>          `(,_4)
<span class="lineno" id=line221></span>          `(( ast_goto ,_sr ,(string-append "continue_" _1)))
<span class="lineno" id=line222></span>          `(( ast_label ,_sr ,(string-append "break_" _1)))
<span class="lineno" id=line223></span>      ))
<span class="lineno" id=line224></span>      """</span>;
<span class="lineno" id=line225></span>  
<span class="lineno" id=line226></span>    loop_stmt := optlabel <span class="fstring">"for"</span> <span class="fstring">"("</span> stmt sexpr <span class="fstring">";"</span> stmt <span class="fstring">")"</span> stmt =&gt;#
<span class="lineno" id=line227></span>    <span class="fstring">"""
<span class="lineno" id=line228></span>    (begin 
<span class="lineno" id=line229></span>      `(ast_seq ,_sr
<span class="lineno" id=line230></span>        ,(append 
<span class="lineno" id=line231></span>          `(,_4)
<span class="lineno" id=line232></span>          `((ast_label ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line233></span>          `((ast_unlikely_ifnotgoto ,_sr ,_5 ,(string-append "break_" _1)))
<span class="lineno" id=line234></span>          `(,_9)
<span class="lineno" id=line235></span>          `((ast_label ,_sr ,(string-append "continue_" _1)))
<span class="lineno" id=line236></span>          `(,_7)
<span class="lineno" id=line237></span>          `((ast_goto ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line238></span>          `((ast_label ,_sr ,(string-append "break_" _1)))
<span class="lineno" id=line239></span>        )
<span class="lineno" id=line240></span>      )
<span class="lineno" id=line241></span>    )
<span class="lineno" id=line242></span>    """</span>;
<span class="lineno" id=line243></span>  
<span class="lineno" id=line244></span>    loop_stmt := optlabel <span class="fstring">"for"</span> stmt <span class="fstring">"while"</span> sexpr <span class="fstring">";"</span> <span class="fstring">"next"</span> stmt block =&gt;#
<span class="lineno" id=line245></span>    <span class="fstring">"""
<span class="lineno" id=line246></span>    (begin 
<span class="lineno" id=line247></span>      `(ast_seq ,_sr
<span class="lineno" id=line248></span>        ,(append 
<span class="lineno" id=line249></span>          `(,_3)
<span class="lineno" id=line250></span>          `((ast_label ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line251></span>          `((ast_unlikely_ifnotgoto ,_sr ,_5 ,(string-append "break_" _1)))
<span class="lineno" id=line252></span>          `(,_9)
<span class="lineno" id=line253></span>          `((ast_label ,_sr ,(string-append "continue_" _1)))
<span class="lineno" id=line254></span>          `(,_8)
<span class="lineno" id=line255></span>          `((ast_goto ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line256></span>          `((ast_label ,_sr ,(string-append "break_" _1)))
<span class="lineno" id=line257></span>        )
<span class="lineno" id=line258></span>      )
<span class="lineno" id=line259></span>    )
<span class="lineno" id=line260></span>    """</span>;
<span class="lineno" id=line261></span>  
<span class="lineno" id=line262></span>  
<span class="lineno" id=line263></span>    loop_stmt := optlabel <span class="fstring">"for"</span> stmt <span class="fstring">"until"</span> sexpr <span class="fstring">";"</span> <span class="fstring">"next"</span> stmt block =&gt;#
<span class="lineno" id=line264></span>    <span class="fstring">"""
<span class="lineno" id=line265></span>    (begin 
<span class="lineno" id=line266></span>      `(ast_seq ,_sr
<span class="lineno" id=line267></span>        ,(append 
<span class="lineno" id=line268></span>          `(,_3)
<span class="lineno" id=line269></span>          `((ast_label ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line270></span>          `((ast_unlikely_ifgoto ,_sr ,_5 ,(string-append "break_" _1)))
<span class="lineno" id=line271></span>          `(,_9)
<span class="lineno" id=line272></span>          `((ast_label ,_sr ,(string-append "continue_" _1)))
<span class="lineno" id=line273></span>          `(,_8)
<span class="lineno" id=line274></span>          `((ast_goto ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line275></span>          `((ast_label ,_sr ,(string-append "break_" _1)))
<span class="lineno" id=line276></span>        )
<span class="lineno" id=line277></span>      )
<span class="lineno" id=line278></span>    )
<span class="lineno" id=line279></span>    """</span>;
<span class="lineno" id=line280></span>  
<span class="lineno" id=line281></span>    <span class="doccomment">Numeric upwards for loop, existing control variable.</span>
<span class="lineno" id=line282></span>    <span class="doccomment">Ranges are inclusive. This is essential in case</span>
<span class="lineno" id=line283></span>    <span class="doccomment">the loops if over the complete domain of the control variable type.</span>
<span class="lineno" id=line284></span>    <span class="doccomment">The start and end argument types and the declared control variable type must be the same.</span>
<span class="lineno" id=line285></span>  
<span class="lineno" id=line286></span>    <span class="comment">// Unfortunately we have to have TWO comparisons with the terminating value</span>
<span class="lineno" id=line287></span>    <span class="comment">// the first to see if the body is to execute and the second to see if </span>
<span class="lineno" id=line288></span>    <span class="comment">// the incr/decr is to be done, this is because it might be the max/min value</span>
<span class="lineno" id=line289></span>    <span class="comment">// in the range and the incr/decr would be invalid.</span>
<span class="lineno" id=line290></span>  
<span class="lineno" id=line291></span>    loop_stmt := optlabel <span class="fstring">"for"</span> sname <span class="fstring">"in"</span> sexpr <span class="fstring">".."</span> sexpr block =&gt;# <span class="fstring">"(define_incluploop)"</span>;
<span class="lineno" id=line292></span>    loop_stmt := optlabel <span class="fstring">"for"</span> sname <span class="fstring">"in"</span> sexpr <span class="fstring">"upto"</span> sexpr block =&gt;# <span class="fstring">"(assign_incluploop)"</span>;
<span class="lineno" id=line293></span>    loop_stmt := optlabel <span class="fstring">"for"</span> sname <span class="fstring">"in"</span> sexpr <span class="fstring">"..&lt;"</span> sexpr block =&gt;# <span class="fstring">"(define_excluploop)"</span>;
<span class="lineno" id=line294></span>   
<span class="lineno" id=line295></span>  
<span class="lineno" id=line296></span>    <span class="doccomment">Numeric upwards for loop, also declares the control variable with type.</span>
<span class="lineno" id=line297></span>    <span class="doccomment">The control variable is local to the enclosing context, </span>
<span class="lineno" id=line298></span>    <span class="doccomment">NOT the loop, so it can be inspected in code following the loop.</span>
<span class="lineno" id=line299></span>    <span class="doccomment">Ranges are inclusive. This is essential in case</span>
<span class="lineno" id=line300></span>    <span class="doccomment">the loops if over the complete domain of the control variable type.</span>
<span class="lineno" id=line301></span>    <span class="doccomment">The start and end argument types and the declared control variable type must be the same.</span>
<span class="lineno" id=line302></span>    loop_stmt := optlabel <span class="fstring">"for"</span> <span class="fstring">"var"</span> sname <span class="fstring">":"</span> sexpr <span class="fstring">"in"</span> sexpr <span class="fstring">"upto"</span> sexpr block =&gt;#
<span class="lineno" id=line303></span>      <span class="fstring">"""
<span class="lineno" id=line304></span>      `(ast_seq ,_sr
<span class="lineno" id=line305></span>        ,(append 
<span class="lineno" id=line306></span>          `((ast_var_decl ,_sr ,_4 ,dfltvs (some ,_6) (some ,_8)))
<span class="lineno" id=line307></span>          `((ast_label ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line308></span>          `((ast_unlikely_ifnotgoto ,_sr
<span class="lineno" id=line309></span>           ,(binop (noi '&lt;=) `(ast_name ,_sr ,_4 ()) _10)
<span class="lineno" id=line310></span>            ,(string-append "break_" _1)
<span class="lineno" id=line311></span>          ))
<span class="lineno" id=line312></span>          `(,_11)
<span class="lineno" id=line313></span>          `((ast_label ,_sr ,(string-append "continue_" _1)))
<span class="lineno" id=line314></span>          `((ast_call ,_sr ,(noi 'pre_incr) (ast_ref ,_sr (ast_name ,_sr ,_4()))))
<span class="lineno" id=line315></span>          `((ast_goto ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line316></span>          `((ast_label ,_sr ,(string-append "break_" _1)))
<span class="lineno" id=line317></span>         ))
<span class="lineno" id=line318></span>      """</span>;
<span class="lineno" id=line319></span>  
<span class="lineno" id=line320></span>    <span class="doccomment">Numeric upwards for loop, also declares the control variable.</span>
<span class="lineno" id=line321></span>    <span class="doccomment">The control variable is local to the enclosing context, </span>
<span class="lineno" id=line322></span>    <span class="doccomment">NOT the loop, so it can be inspected in code following the loop.</span>
<span class="lineno" id=line323></span>    <span class="doccomment">Ranges are inclusive. This is essential in case</span>
<span class="lineno" id=line324></span>    <span class="doccomment">the loops if over the complete domain of the control variable type.</span>
<span class="lineno" id=line325></span>    <span class="doccomment">The start and end argument types must be the same.</span>
<span class="lineno" id=line326></span>    loop_stmt := optlabel <span class="fstring">"for"</span> <span class="fstring">"var"</span> sname <span class="fstring">"in"</span> sexpr <span class="fstring">"upto"</span> sexpr block =&gt;#
<span class="lineno" id=line327></span>      <span class="fstring">"""
<span class="lineno" id=line328></span>      `(ast_seq ,_sr
<span class="lineno" id=line329></span>        ,(append 
<span class="lineno" id=line330></span>          `((ast_var_decl ,_sr ,_4 ,dfltvs none (some ,_6)))
<span class="lineno" id=line331></span>          `((ast_label ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line332></span>          `((ast_unlikely_ifnotgoto ,_sr
<span class="lineno" id=line333></span>            ,(binop (noi '&lt;=) `(ast_name ,_sr ,_4 ()) _8)
<span class="lineno" id=line334></span>            ,(string-append "break_" _1)
<span class="lineno" id=line335></span>          ))
<span class="lineno" id=line336></span>          `(,_9)
<span class="lineno" id=line337></span>          `((ast_label ,_sr ,(string-append "continue_" _1)))
<span class="lineno" id=line338></span>          `((ast_call ,_sr ,(noi 'pre_incr) (ast_ref ,_sr (ast_name ,_sr ,_4()))))
<span class="lineno" id=line339></span>          `((ast_goto ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line340></span>          `((ast_label ,_sr ,(string-append "break_" _1)))
<span class="lineno" id=line341></span>         ))
<span class="lineno" id=line342></span>      """</span>;
<span class="lineno" id=line343></span>  
<span class="lineno" id=line344></span>  
<span class="lineno" id=line345></span>    <span class="doccomment">Numeric downwards for loop, existing control variable.</span>
<span class="lineno" id=line346></span>    <span class="doccomment">Ranges are inclusive. This is essential in case</span>
<span class="lineno" id=line347></span>    <span class="doccomment">the loops if over the complete domain of the control variable type.</span>
<span class="lineno" id=line348></span>    <span class="doccomment">The start and end argument types and the declared control variable type must be the same.</span>
<span class="lineno" id=line349></span>    loop_stmt := optlabel <span class="fstring">"for"</span> sname <span class="fstring">"in"</span> sexpr <span class="fstring">"downto"</span> sexpr block =&gt;#
<span class="lineno" id=line350></span>      <span class="fstring">"""
<span class="lineno" id=line351></span>      `(ast_seq ,_sr
<span class="lineno" id=line352></span>        ,(append 
<span class="lineno" id=line353></span>          `((ast_assign ,_sr _set ((Expr ,_sr (ast_name ,_sr ,_3 ())) none) ,_5))
<span class="lineno" id=line354></span>          `((ast_call ,_sr ,(noi 'pre_incr) (ast_ref ,_sr (ast_name ,_sr ,_3()))))
<span class="lineno" id=line355></span>          `((ast_label ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line356></span>          `((ast_unlikely_ifnotgoto ,_sr
<span class="lineno" id=line357></span>            ,(binop (noi '&gt;) `(ast_name ,_sr ,_3 ()) _7)
<span class="lineno" id=line358></span>            ,(string-append "break_" _1)
<span class="lineno" id=line359></span>          ))
<span class="lineno" id=line360></span>          `((ast_call ,_sr ,(noi 'pre_decr) (ast_ref ,_sr (ast_name ,_sr ,_3()))))
<span class="lineno" id=line361></span>          `(,_8)
<span class="lineno" id=line362></span>          `((ast_label ,_sr ,(string-append "continue_" _1)))
<span class="lineno" id=line363></span>          `((ast_goto ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line364></span>          `((ast_label ,_sr ,(string-append "break_" _1)))
<span class="lineno" id=line365></span>         ))
<span class="lineno" id=line366></span>      """</span>;
<span class="lineno" id=line367></span>  
<span class="lineno" id=line368></span>    <span class="doccomment">Numeric downwards for loop, also declares the control variable with type.</span>
<span class="lineno" id=line369></span>    <span class="doccomment">The control variable is local to the enclosing context, </span>
<span class="lineno" id=line370></span>    <span class="doccomment">NOT the loop, so it can be inspected in code following the loop.</span>
<span class="lineno" id=line371></span>    <span class="doccomment">Ranges are inclusive. This is essential in case</span>
<span class="lineno" id=line372></span>    <span class="doccomment">the loops if over the complete domain of the control variable type.</span>
<span class="lineno" id=line373></span>    <span class="doccomment">The start and end argument types and the declared control variable type must be the same.</span>
<span class="lineno" id=line374></span>    loop_stmt := optlabel <span class="fstring">"for"</span> <span class="fstring">"var"</span> sname <span class="fstring">":"</span> sexpr <span class="fstring">"in"</span> sexpr <span class="fstring">"downto"</span> sexpr block =&gt;#
<span class="lineno" id=line375></span>      <span class="fstring">"""
<span class="lineno" id=line376></span>      `(ast_seq ,_sr
<span class="lineno" id=line377></span>        ,(append 
<span class="lineno" id=line378></span>          `((ast_var_decl ,_sr ,_4 ,dfltvs (some ,_6) (some ,_8)))
<span class="lineno" id=line379></span>          `((ast_call ,_sr ,(noi 'pre_incr) (ast_ref ,_sr (ast_name ,_sr ,_4()))))
<span class="lineno" id=line380></span>          `((ast_label ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line381></span>          `((ast_unlikely_ifnotgoto ,_sr
<span class="lineno" id=line382></span>            ,(binop (noi '&gt;) `(ast_name ,_sr ,_4 ()) _10)
<span class="lineno" id=line383></span>            ,(string-append "break_" _1)
<span class="lineno" id=line384></span>          ))
<span class="lineno" id=line385></span>          `((ast_call ,_sr ,(noi 'pre_decr) (ast_ref ,_sr (ast_name ,_sr ,_4()))))
<span class="lineno" id=line386></span>          `(,_11)
<span class="lineno" id=line387></span>          `((ast_label ,_sr ,(string-append "continue_" _1)))
<span class="lineno" id=line388></span>          `((ast_goto ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line389></span>          `((ast_label ,_sr ,(string-append "break_" _1)))
<span class="lineno" id=line390></span>         ))
<span class="lineno" id=line391></span>      """</span>;
<span class="lineno" id=line392></span>  
<span class="lineno" id=line393></span>    <span class="doccomment">Numeric downwards for loop, also declares the control variable.</span>
<span class="lineno" id=line394></span>    <span class="doccomment">The control variable is local to the enclosing context, </span>
<span class="lineno" id=line395></span>    <span class="doccomment">NOT the loop, so it can be inspected in code following the loop.</span>
<span class="lineno" id=line396></span>    <span class="doccomment">Ranges are inclusive. This is essential in case</span>
<span class="lineno" id=line397></span>    <span class="doccomment">the loops if over the complete domain of the control variable type.</span>
<span class="lineno" id=line398></span>    <span class="doccomment">The start and end argument types and the declared control variable type must be the same.</span>
<span class="lineno" id=line399></span>    loop_stmt := optlabel <span class="fstring">"for"</span> <span class="fstring">"var"</span> sname <span class="fstring">"in"</span> sexpr <span class="fstring">"downto"</span> sexpr block =&gt;#
<span class="lineno" id=line400></span>      <span class="fstring">"""
<span class="lineno" id=line401></span>      `(ast_seq ,_sr
<span class="lineno" id=line402></span>        ,(append 
<span class="lineno" id=line403></span>          `((ast_var_decl ,_sr ,_4 ,dfltvs none (some ,_6)))
<span class="lineno" id=line404></span>          `((ast_call ,_sr ,(noi 'pre_incr) (ast_ref ,_sr (ast_name ,_sr ,_4()))))
<span class="lineno" id=line405></span>          `((ast_label ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line406></span>          `((ast_unlikely_ifnotgoto ,_sr
<span class="lineno" id=line407></span>            ,(binop (noi '&gt;) `(ast_name ,_sr ,_4 ()) _8)
<span class="lineno" id=line408></span>            ,(string-append "break_" _1)
<span class="lineno" id=line409></span>          ))
<span class="lineno" id=line410></span>          `((ast_call ,_sr ,(noi 'pre_decr) (ast_ref ,_sr (ast_name ,_sr ,_4()))))
<span class="lineno" id=line411></span>          `(,_9)
<span class="lineno" id=line412></span>          `((ast_label ,_sr ,(string-append "continue_" _1)))
<span class="lineno" id=line413></span>          `((ast_goto ,_sr ,(string-append "redo_" _1)))
<span class="lineno" id=line414></span>          `((ast_label ,_sr ,(string-append "break_" _1)))
<span class="lineno" id=line415></span>         ))
<span class="lineno" id=line416></span>      """</span>;
<span class="lineno" id=line417></span>  
<span class="lineno" id=line418></span>    <span class="doccomment">Basic stream consumer.</span>
<span class="lineno" id=line419></span>    <span class="doccomment">The second argument must be a value for which there is a generator: </span>
<span class="lineno" id=line420></span>    <span class="doccomment">  //$   iterator : D -&gt; unit -&gt; opt[T]</span>
<span class="lineno" id=line421></span>    <span class="doccomment">  //$ Due to a hack in std/datatype/slice.flx:</span>
<span class="lineno" id=line422></span>    <span class="doccomment">   gen iterator[t] (f:1-&gt;opt[t]) =&gt; f;</span>
<span class="lineno" id=line423></span>    <span class="doccomment">you can also use an actual iterator.</span>
<span class="lineno" id=line424></span>    <span class="doccomment"></span>
<span class="lineno" id=line425></span>    <span class="doccomment">1. The iterator function is called.</span>
<span class="lineno" id=line426></span>    <span class="doccomment">2. If the result is None, the loop exits.</span>
<span class="lineno" id=line427></span>    <span class="doccomment">3. If the result is Some ?t, then t is assigned to the </span>
<span class="lineno" id=line428></span>    <span class="doccomment">   control variable, </span>
<span class="lineno" id=line429></span>    <span class="doccomment">4. the loop body is executed, and</span>
<span class="lineno" id=line430></span>    <span class="doccomment">6. we go back to step 1.</span>
<span class="lineno" id=line431></span>    loop_stmt := optlabel <span class="fstring">"for"</span> sname <span class="fstring">"in"</span> sexpr block =&gt;#
<span class="lineno" id=line432></span>      <span class="fstring">"""
<span class="lineno" id=line433></span>      (let* (
<span class="lineno" id=line434></span>       (generator_string_name (fresh_name "generator" ))
<span class="lineno" id=line435></span>       (generator_call_name (nos generator_string_name))
<span class="lineno" id=line436></span>       (generator_init `(ast_apply ,_sr (,(nos "iterator") ,_5 )))
<span class="lineno" id=line437></span>       (generator_call `(ast_apply ,_sr (,generator_call_name ())))
<span class="lineno" id=line438></span>       (some_pattern `(pat_nonconst_ctor ,_sr ,(nos "Some") (pat_as ,_sr (pat_any ,_sr) ,_3) ))
<span class="lineno" id=line439></span>       (some_exit `(ast_goto ,_sr ,(string-append "continue_" _1))) 
<span class="lineno" id=line440></span>       (some_handler (append `(,_6) `(,some_exit)))
<span class="lineno" id=line441></span>       (none_pattern `(pat_const_ctor ,_sr ,(nos "None")))
<span class="lineno" id=line442></span>       (none_handler `((ast_nop ,_sr, "drop thru")))
<span class="lineno" id=line443></span>       (some_item `(,some_pattern ,some_handler))
<span class="lineno" id=line444></span>       (none_item `(,none_pattern ,none_handler))
<span class="lineno" id=line445></span>       (matchings `(,some_item ,none_item))
<span class="lineno" id=line446></span>      )
<span class="lineno" id=line447></span>      `(ast_seq ,_sr (
<span class="lineno" id=line448></span>          (ast_var_decl ,_sr ,generator_string_name ,dfltvs none (some ,generator_init))
<span class="lineno" id=line449></span>          (ast_label ,_sr ,(string-append "continue_" _1))
<span class="lineno" id=line450></span>          (ast_stmt_match (,_sr ,generator_call ,matchings))
<span class="lineno" id=line451></span>          (ast_label ,_sr ,(string-append "break_" _1))
<span class="lineno" id=line452></span>         )))
<span class="lineno" id=line453></span>      """</span>;
<span class="lineno" id=line454></span>  
<span class="lineno" id=line455></span>    loop_stmt := optlabel <span class="fstring">"rfor"</span> sname <span class="fstring">"in"</span> sexpr block =&gt;# <span class="fstring">'(iterator_recursive_loop _1 _3 _5 _6)'</span>;
<span class="lineno" id=line456></span>  
<span class="lineno" id=line457></span>    <span class="doccomment">Upmarket stream consumer.</span>
<span class="lineno" id=line458></span>    <span class="doccomment">The second argument must be a value for which there is a generator: </span>
<span class="lineno" id=line459></span>    <span class="doccomment">  //$   iterator : D -&gt; unit -&gt; opt[T]</span>
<span class="lineno" id=line460></span>    <span class="doccomment">  //$ Due to a hack in std/datatype/slice.flx:</span>
<span class="lineno" id=line461></span>    <span class="doccomment">   gen iterator[t] (f:1-&gt;opt[t]) =&gt; f;</span>
<span class="lineno" id=line462></span>    <span class="doccomment">you can also use an actual iterator.</span>
<span class="lineno" id=line463></span>    <span class="doccomment"></span>
<span class="lineno" id=line464></span>    <span class="doccomment">  //$ 1. The iterator function is called.</span>
<span class="lineno" id=line465></span>    <span class="doccomment">2. If the result is None, the loop exits.</span>
<span class="lineno" id=line466></span>    <span class="doccomment">3. If the result is Some ?t, </span>
<span class="lineno" id=line467></span>    <span class="doccomment">   then t is matched against the pattern.</span>
<span class="lineno" id=line468></span>    <span class="doccomment">4. If the pattern matches, loop body is executed, and</span>
<span class="lineno" id=line469></span>    <span class="doccomment">5. we go back to step 1.</span>
<span class="lineno" id=line470></span>    <span class="doccomment">6. If the pattern does not match,</span>
<span class="lineno" id=line471></span>    <span class="doccomment">7. we go back to step 1</span>
<span class="lineno" id=line472></span>    <span class="doccomment">   without executing the loop body.</span>
<span class="lineno" id=line473></span>    loop_stmt := optlabel <span class="fstring">"match"</span> spattern <span class="fstring">"in"</span> sexpr block =&gt;#
<span class="lineno" id=line474></span>      <span class="fstring">"""
<span class="lineno" id=line475></span>      (let* (
<span class="lineno" id=line476></span>       (generator_string_name (fresh_name "generator" ))
<span class="lineno" id=line477></span>       (generator_call_name (nos generator_string_name))
<span class="lineno" id=line478></span>       (generator_init `(ast_apply ,_sr (,(nos "iterator") ,_5 )))
<span class="lineno" id=line479></span>       (generator_call `(ast_apply ,_sr (,generator_call_name ())))
<span class="lineno" id=line480></span>       (some_pattern `(pat_nonconst_ctor ,_sr ,(nos "Some")  ,_3 ))
<span class="lineno" id=line481></span>       (some_exit `(ast_goto ,_sr ,(string-append "continue_" _1))) 
<span class="lineno" id=line482></span>       (some_handler (append `(,_6) `(,some_exit)))
<span class="lineno" id=line483></span>       (some_item `(,some_pattern ,some_handler))
<span class="lineno" id=line484></span>       (other_pattern `(pat_nonconst_ctor ,_sr ,(nos "Some")  (pat_any ,_sr) ))
<span class="lineno" id=line485></span>       (other_handler `(,some_exit))
<span class="lineno" id=line486></span>       (other_item `(,other_pattern ,other_handler))
<span class="lineno" id=line487></span>       (none_pattern `(pat_const_ctor ,_sr ,(nos "None")))
<span class="lineno" id=line488></span>       (none_handler `((ast_nop ,_sr, "drop thru")))
<span class="lineno" id=line489></span>       (none_item `(,none_pattern ,none_handler))
<span class="lineno" id=line490></span>       (matchings `(,some_item ,other_item ,none_item))
<span class="lineno" id=line491></span>      )
<span class="lineno" id=line492></span>      `(ast_seq ,_sr (
<span class="lineno" id=line493></span>          (ast_var_decl ,_sr ,generator_string_name ,dfltvs none (some ,generator_init))
<span class="lineno" id=line494></span>          (ast_label ,_sr ,(string-append "continue_" _1))
<span class="lineno" id=line495></span>          (ast_stmt_match (,_sr ,generator_call ,matchings))
<span class="lineno" id=line496></span>          (ast_label ,_sr ,(string-append "break_" _1))
<span class="lineno" id=line497></span>         )))
<span class="lineno" id=line498></span>      """</span>;
<span class="lineno" id=line499></span>  
<span class="lineno" id=line500></span>  
<span class="lineno" id=line501></span>  }
<span class="lineno" id=line502></span>  
</pre></p></div><h2 id='Macros_h'><img src='/share/src/web/images/minus.gif' id='Macros' onclick='toggle(this,"Macros_d")' alt='+'/> 2.17 Macros</h2><div id='Macros_d' style='display:block'>
<pre class='inclusion'>
share/lib/grammar/macros.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> macros {
<span class="lineno" id=line2></span>    <span class="big_keyword" title="specify requirements">requires</span> expressions, statements, <span class="library" title="functional, singly linked list">list</span>;
<span class="lineno" id=line3></span>    
<span class="lineno" id=line4></span>    stmt := <span class="fstring">"macro"</span> <span class="fstring">"val"</span> snames <span class="fstring">"="</span> sexpr <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line5></span>      <span class="fstring">"`(ast_macro_val ,_sr ,_3 ,_5)"</span>;
<span class="lineno" id=line6></span>  
<span class="lineno" id=line7></span>    stmt := <span class="fstring">"forall"</span> sname <span class="fstring">"in"</span> sexpr <span class="fstring">"do"</span> stmt* <span class="fstring">"done"</span> =&gt;#
<span class="lineno" id=line8></span>      <span class="fstring">"`(ast_macro_forall ,_sr (,_2) ,_4 ,_6)"</span>
<span class="lineno" id=line9></span>    ;
<span class="lineno" id=line10></span>  
<span class="lineno" id=line11></span>  }
<span class="lineno" id=line12></span>  
</pre></p></div><h2 id='Namespaces_h'><img src='/share/src/web/images/minus.gif' id='Namespaces' onclick='toggle(this,"Namespaces_d")' alt='+'/> 2.18 Namespaces</h2><div id='Namespaces_d' style='display:block'>
<pre class='inclusion'>
share/lib/grammar/namespaces.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">Felix namespace control.</span>
<span class="lineno" id=line2></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> namespaces {
<span class="lineno" id=line3></span>    <span class="big_keyword" title="specify requirements">requires</span> statements;
<span class="lineno" id=line4></span>  
<span class="lineno" id=line5></span>    stmt = namespace_stmt;
<span class="lineno" id=line6></span>  
<span class="lineno" id=line7></span>    <span class="doccomment">Create a new solo name and bind it to an existing name.</span>
<span class="lineno" id=line8></span>    <span class="doccomment">NOTE: it doesn't rename anything!</span>
<span class="lineno" id=line9></span>    <span class="doccomment">Used to inject solo names into a namespace.</span>
<span class="lineno" id=line10></span>  
<span class="lineno" id=line11></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> namespace_stmt := <span class="fstring">"rename"</span> sdeclname <span class="fstring">"="</span> squalified_name <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line12></span>      <span class="fstring">"""
<span class="lineno" id=line13></span>      `(ast_inherit ,_sr ,(first _2) ,(second _2) ,_4)
<span class="lineno" id=line14></span>      """</span>;
<span class="lineno" id=line15></span>  
<span class="lineno" id=line16></span>    <span class="doccomment">Create a new name for an existing set of function names.</span>
<span class="lineno" id=line17></span>    <span class="doccomment">NOTE: it doesn't rename anything!</span>
<span class="lineno" id=line18></span>    <span class="doccomment">Used to inject an overload set into a namespace.</span>
<span class="lineno" id=line19></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> namespace_stmt := <span class="fstring">"rename"</span> <span class="fstring">"fun"</span> sdeclname <span class="fstring">"="</span> squalified_name <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line20></span>      <span class="fstring">"""
<span class="lineno" id=line21></span>      `(ast_inherit_fun ,_sr ,(first _3) ,(second _3) ,_5)
<span class="lineno" id=line22></span>      """</span>;
<span class="lineno" id=line23></span>  
<span class="lineno" id=line24></span>    <span class="doccomment">Inject all the public members of a class or module</span>
<span class="lineno" id=line25></span>    <span class="doccomment">into a namespace.</span>
<span class="lineno" id=line26></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> namespace_stmt := <span class="fstring">"inherit"</span> stvarlist squalified_name <span class="fstring">";"</span> =&gt;# 
<span class="lineno" id=line27></span>      <span class="fstring">"`(ast_inject_module ,_sr ,_2 ,_3)"</span>;
<span class="lineno" id=line28></span>  
<span class="lineno" id=line29></span>    <span class="doccomment">Inject all the public members of a class or module</span>
<span class="lineno" id=line30></span>    <span class="doccomment">"just underneath" a namespace. Such names will be</span>
<span class="lineno" id=line31></span>    <span class="doccomment">hidden by any names actually defined or injected</span>
<span class="lineno" id=line32></span>    <span class="doccomment">into the actual namespace scope.</span>
<span class="lineno" id=line33></span>    <span class="doccomment">NOTE: The names are not public members of the namespace.</span>
<span class="lineno" id=line34></span>    <span class="doccomment">But they're not private members either, they're not</span>
<span class="lineno" id=line35></span>    <span class="doccomment">members at all.</span>
<span class="lineno" id=line36></span>    <span class="doccomment">  //$ Open makes names available for use in a namespace</span>
<span class="lineno" id=line37></span>    <span class="doccomment">without making them members for export.</span>
<span class="lineno" id=line38></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> namespace_stmt := <span class="fstring">"open"</span> stvarlist squalified_name <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line39></span>      <span class="fstring">"`(ast_open ,_sr ,_2 ,_3)"</span>;
<span class="lineno" id=line40></span>  
<span class="lineno" id=line41></span>    <span class="doccomment">Open a single name to a namespace bound to the given qualified name.</span>
<span class="lineno" id=line42></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> namespace_stmt := <span class="fstring">"use"</span> sname <span class="fstring">"="</span> squalified_name <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_use ,_sr ,_2 ,_4)"</span>;
<span class="lineno" id=line43></span>  
<span class="lineno" id=line44></span>    <span class="doccomment">A short form for opening a single name as the</span>
<span class="lineno" id=line45></span>    <span class="doccomment">base part of a qualified name.</span>
<span class="lineno" id=line46></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> namespace_stmt := <span class="fstring">"use"</span> squalified_name <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line47></span>      <span class="fstring">"""
<span class="lineno" id=line48></span>      (let ((name
<span class="lineno" id=line49></span>        (if (eq? (first _2) 'ast_lookup) (cadadr _2)
<span class="lineno" id=line50></span>          (if (eq? (first _2) 'ast_name) (second _2)
<span class="lineno" id=line51></span>          ("ERROR")))))
<span class="lineno" id=line52></span>      `(ast_use ,_sr ,name ,_2))
<span class="lineno" id=line53></span>      """</span>;
<span class="lineno" id=line54></span>  
<span class="lineno" id=line55></span>    <span class="doccomment">Define a module.</span>
<span class="lineno" id=line56></span>    <span class="doccomment">DEPRECATED. Use classes instead.</span>
<span class="lineno" id=line57></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> namespace_stmt := <span class="fstring">"module"</span> sdeclname <span class="fstring">"="</span> ? scompound =&gt;#
<span class="lineno" id=line58></span>      <span class="fstring">"""
<span class="lineno" id=line59></span>      `(ast_untyped_module ,_sr ,(first _2) ,(second _2) ,_4)
<span class="lineno" id=line60></span>       """</span>;
<span class="lineno" id=line61></span>  
<span class="lineno" id=line62></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> namespace_stmt := <span class="fstring">"library"</span> sname <span class="fstring">"="</span> ? scompound =&gt;#
<span class="lineno" id=line63></span>      <span class="fstring">"""
<span class="lineno" id=line64></span>      `(ast_library ,_sr ,_2 ,_4)
<span class="lineno" id=line65></span>       """</span>;
<span class="lineno" id=line66></span>  
<span class="lineno" id=line67></span>  
<span class="lineno" id=line68></span>    <span class="doccomment">Define a module and open in it in the current scope.</span>
<span class="lineno" id=line69></span>    <span class="doccomment">DEPRECATED: Use classes instead.</span>
<span class="lineno" id=line70></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> namespace_stmt := <span class="fstring">"open"</span> <span class="fstring">"module"</span> sdeclname <span class="fstring">"="</span> ? scompound =&gt;#
<span class="lineno" id=line71></span>      <span class="fstring">"""
<span class="lineno" id=line72></span>      `(ast_seq ,_sr (
<span class="lineno" id=line73></span>        (ast_untyped_module ,_sr ,(first _3) ,(second _3) ,_5)
<span class="lineno" id=line74></span>        (ast_open ,_sr ,dfltvs (ast_name ,_sr ,(first _3) ()))))
<span class="lineno" id=line75></span>       """</span>;
<span class="lineno" id=line76></span>  
<span class="lineno" id=line77></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> namespace_stmt := <span class="fstring">"open"</span> <span class="fstring">"library"</span> sname <span class="fstring">"="</span> ? scompound =&gt;#
<span class="lineno" id=line78></span>      <span class="fstring">"""
<span class="lineno" id=line79></span>      `(ast_seq ,_sr (
<span class="lineno" id=line80></span>        (ast_library ,_sr ,_3 ,_5)
<span class="lineno" id=line81></span>        (ast_open ,_sr ,dfltvs (ast_name ,_sr ,_3 ()))))
<span class="lineno" id=line82></span>       """</span>;
<span class="lineno" id=line83></span>  
<span class="lineno" id=line84></span>    <span class="doccomment">Define a class.</span>
<span class="lineno" id=line85></span>    <span class="doccomment">A class is a collection of constants, variables,</span>
<span class="lineno" id=line86></span>    <span class="doccomment">types, functions, and other entities.</span>
<span class="lineno" id=line87></span>    <span class="doccomment"></span>
<span class="lineno" id=line88></span>    <span class="doccomment">A polymorphic class may contain virtual functions, which are</span>
<span class="lineno" id=line89></span>    <span class="doccomment">functions which can be defined later for particular types.</span>
<span class="lineno" id=line90></span>    <span class="doccomment">This is equivalent to a specialisation of a template in C++.</span>
<span class="lineno" id=line91></span>    <span class="doccomment">  //$ NOTE: polymorphic classes may not contain variables.</span>
<span class="lineno" id=line92></span>    <span class="doccomment">Only variables of non-polymorphic classes can be instantiated.</span>
<span class="lineno" id=line93></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> namespace_stmt := <span class="fstring">"class"</span> sdeclname <span class="fstring">"="</span> ? scompound =&gt;#
<span class="lineno" id=line94></span>      <span class="fstring">"""
<span class="lineno" id=line95></span>      `(ast_typeclass ,_sr ,(first _2) ,(second _2) ,_4)
<span class="lineno" id=line96></span>      """</span>;
<span class="lineno" id=line97></span>  
<span class="lineno" id=line98></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> namespace_stmt := <span class="fstring">"class"</span> sdeclname <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line99></span>      <span class="fstring">"""
<span class="lineno" id=line100></span>      `(ast_begin_typeclass ,_sr ,(first _2) ,(second _2))
<span class="lineno" id=line101></span>      """</span>;
<span class="lineno" id=line102></span>  
<span class="lineno" id=line103></span>  
<span class="lineno" id=line104></span>    <span class="doccomment">Define a class and open it.</span>
<span class="lineno" id=line105></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> namespace_stmt := <span class="fstring">"open"</span> <span class="fstring">"class"</span> sdeclname <span class="fstring">"="</span> ? scompound =&gt;#
<span class="lineno" id=line106></span>      <span class="fstring">"""
<span class="lineno" id=line107></span>      `(ast_seq ,_sr (
<span class="lineno" id=line108></span>        (ast_typeclass ,_sr ,(first _3) ,(second _3) ,_5)
<span class="lineno" id=line109></span>        (ast_open ,_sr ,dfltvs (ast_name ,_sr ,(first _3) ()))))
<span class="lineno" id=line110></span>      """</span>;
<span class="lineno" id=line111></span>  
<span class="lineno" id=line112></span>    <span class="doccomment">Define an instance of a class.</span>
<span class="lineno" id=line113></span>    <span class="doccomment">This is a specialisation of the class which may contain</span>
<span class="lineno" id=line114></span>    <span class="doccomment">overrides of virtual functions for a subset of the possible types.</span>
<span class="lineno" id=line115></span>    <span class="doccomment"></span>
<span class="lineno" id=line116></span>    <span class="doccomment">Instances can be defined in any class scope (including and usually</span>
<span class="lineno" id=line117></span>    <span class="doccomment">at the top level of the program).</span>
<span class="lineno" id=line118></span>    <span class="doccomment">  //$ Members of instances which are not overrides are private</span>
<span class="lineno" id=line119></span>    <span class="doccomment">to the instance.</span>
<span class="lineno" id=line120></span>    <span class="doccomment">  private namespace_stmt := "instance" stvarlist squalified_name "=" ? scompound =&gt;#</span>
<span class="lineno" id=line121></span>      <span class="fstring">"""
<span class="lineno" id=line122></span>      `(ast_instance ,_sr ,_2 ,_3 ,_5)
<span class="lineno" id=line123></span>      """</span>;
<span class="lineno" id=line124></span>  
<span class="lineno" id=line125></span>  
<span class="lineno" id=line126></span>    <span class="doccomment">Provide a set of definitions in the with block</span>
<span class="lineno" id=line127></span>    <span class="doccomment">which are available in the do block but are lost</span>
<span class="lineno" id=line128></span>    <span class="doccomment">thereafter.</span>
<span class="lineno" id=line129></span>    <span class="doccomment">  //$ Effectively these definitions are private to the</span>
<span class="lineno" id=line130></span>    <span class="doccomment">do block. The with block is basically an anonymous</span>
<span class="lineno" id=line131></span>    <span class="doccomment">class which is opened in the do block. Example:</span>
<span class="lineno" id=line132></span>    <span class="doccomment"></span>
<span class="lineno" id=line133></span>    <span class="doccomment">var x = 42;</span>
<span class="lineno" id=line134></span>    <span class="doccomment">with var x = 1; do var y = x; done</span>
<span class="lineno" id=line135></span>    <span class="doccomment">println$ x; // prints 42 not 1</span>
<span class="lineno" id=line136></span>    <span class="doccomment">  //$ This is the statement form of a let expression ..</span>
<span class="lineno" id=line137></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> namespace_stmt := <span class="fstring">"with"</span> stmt+ block =&gt;#
<span class="lineno" id=line138></span>    <span class="fstring">"""
<span class="lineno" id=line139></span>    (let* 
<span class="lineno" id=line140></span>      (
<span class="lineno" id=line141></span>        (dummy_class_name (fresh_name "dummy_class"))
<span class="lineno" id=line142></span>        (decls1 (map make_private _2)) 
<span class="lineno" id=line143></span>        (decls (append decls1 `(,_3)))
<span class="lineno" id=line144></span>      )
<span class="lineno" id=line145></span>      `(ast_seq ,_sr 
<span class="lineno" id=line146></span>        (
<span class="lineno" id=line147></span>          (ast_typeclass ,_sr ,dummy_class_name ,dfltvs ,decls)
<span class="lineno" id=line148></span>          (ast_inject_module ,_sr ,dfltvs ,(nos dummy_class_name))
<span class="lineno" id=line149></span>        )
<span class="lineno" id=line150></span>      )
<span class="lineno" id=line151></span>    )
<span class="lineno" id=line152></span>    """</span>;
<span class="lineno" id=line153></span>  }
<span class="lineno" id=line154></span>  
</pre></p></div><h2 id='Patterns_h'><img src='/share/src/web/images/minus.gif' id='Patterns' onclick='toggle(this,"Patterns_d")' alt='+'/> 2.19 Patterns</h2><div id='Patterns_d' style='display:block'>
<pre class='inclusion'>
share/lib/grammar/patterns.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">Pattern matching.</span>
<span class="lineno" id=line2></span>  <span class="doccomment">//$ Pattern matching is a way to "take apart" a value according</span>
<span class="lineno" id=line3></span>  <span class="doccomment">to its structure.</span>
<span class="lineno" id=line4></span>  <span class="doccomment">//$ Matches operate "inside out".</span>
<span class="lineno" id=line5></span>  
<span class="lineno" id=line6></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> patterns {
<span class="lineno" id=line7></span>  
<span class="lineno" id=line8></span>    block = match_stmt;
<span class="lineno" id=line9></span>  
<span class="lineno" id=line10></span>    smatch_head := <span class="fstring">"chainmatch"</span> sexpr <span class="fstring">"with"</span> stmt_matching+ =&gt;# <span class="fstring">"`(,_2 ,_4)"</span>;
<span class="lineno" id=line11></span>    smatch_link := <span class="fstring">"ormatch"</span> sexpr <span class="fstring">"with"</span> stmt_matching+ =&gt;# <span class="fstring">"`(,_2 ,_4)"</span>;
<span class="lineno" id=line12></span>    smatch_chain := smatch_chain smatch_link =&gt;# <span class="fstring">"(cons _2 _1)"</span>; <span class="comment">// revsersed</span>
<span class="lineno" id=line13></span>    smatch_chain := smatch_link =&gt;# <span class="fstring">"`(,_1)"</span>;
<span class="lineno" id=line14></span>  
<span class="lineno" id=line15></span>    match_stmt := smatch_head smatch_chain <span class="fstring">"endmatch"</span> <span class="fstring">";"</span> =&gt;# 
<span class="lineno" id=line16></span>      <span class="fstring">"`(ast_stmt_chainmatch ,_sr ,(cons _1 (reverse _2)))"</span>
<span class="lineno" id=line17></span>    ; 
<span class="lineno" id=line18></span>  
<span class="lineno" id=line19></span>    match_stmt := smatch_head <span class="fstring">"endmatch"</span> <span class="fstring">";"</span> =&gt;# 
<span class="lineno" id=line20></span>      <span class="fstring">"`(ast_stmt_match (,_sr ,_1))"</span>
<span class="lineno" id=line21></span>    ; 
<span class="lineno" id=line22></span>  
<span class="lineno" id=line23></span>    <span class="doccomment">Pattern match statement.</span>
<span class="lineno" id=line24></span>    <span class="doccomment">At least one branch must match or the program aborts with a match failure.</span>
<span class="lineno" id=line25></span>    match_stmt:= <span class="fstring">"match"</span> sexpr <span class="fstring">"with"</span> stmt_matching+ <span class="fstring">"endmatch"</span> <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line26></span>      <span class="fstring">"`(ast_stmt_match (,_sr ,_2 ,_4))"</span>;
<span class="lineno" id=line27></span>  
<span class="lineno" id=line28></span>    match_stmt:= <span class="fstring">"match"</span> sexpr <span class="fstring">"do"</span> stmt_matching+ <span class="fstring">"done"</span> =&gt;#
<span class="lineno" id=line29></span>      <span class="fstring">"`(ast_stmt_match (,_sr ,_2 ,_4))"</span>;
<span class="lineno" id=line30></span>  
<span class="lineno" id=line31></span>    <span class="doccomment">A single branch of a pattern match statement.</span>
<span class="lineno" id=line32></span>    <span class="doccomment">The match argument expression is compared to the pattern.</span>
<span class="lineno" id=line33></span>    <span class="doccomment">If it matches any contained pattern variables are assigned</span>
<span class="lineno" id=line34></span>    <span class="doccomment">the values in the corresponding possition of the expression,</span>
<span class="lineno" id=line35></span>    <span class="doccomment">and the statements are executed.</span>
<span class="lineno" id=line36></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> stmt_matching := <span class="fstring">"|"</span> spattern <span class="fstring">"=&gt;"</span> stmt+ =&gt;# <span class="fstring">"`(,_2 ,_4)"</span>;
<span class="lineno" id=line37></span>  
<span class="lineno" id=line38></span>    <span class="doccomment">Pattern match expression with terminator.</span>
<span class="lineno" id=line39></span>    satom := pattern_match <span class="fstring">"endmatch"</span> =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line40></span>  
<span class="lineno" id=line41></span>    <span class="doccomment">Pattern match expression without terminator.</span>
<span class="lineno" id=line42></span>    <span class="doccomment">Match the expression against each of the branches in the matchings.</span>
<span class="lineno" id=line43></span>    <span class="doccomment">At least one branch must match or the program aborts with a match failure.</span>
<span class="lineno" id=line44></span>    pattern_match := <span class="fstring">"match"</span> sexpr <span class="fstring">"with"</span> smatching+ =&gt;#
<span class="lineno" id=line45></span>      <span class="fstring">"`(ast_match ,_sr (,_2 ,_4))"</span>;
<span class="lineno" id=line46></span>  
<span class="lineno" id=line47></span>    <span class="doccomment">The match argument expression is compared to the pattern.</span>
<span class="lineno" id=line48></span>    <span class="doccomment">If it matches any contained pattern variables are assigned</span>
<span class="lineno" id=line49></span>    <span class="doccomment">the values in the corresponding possition of the expression,</span>
<span class="lineno" id=line50></span>    <span class="doccomment">and expression is evaluated and becomes the return value</span>
<span class="lineno" id=line51></span>    <span class="doccomment">of the whole match. </span>
<span class="lineno" id=line52></span>    smatching := <span class="fstring">"|"</span> spattern <span class="fstring">"=&gt;"</span> x[let_pri] =&gt;# <span class="fstring">"`(,_2 ,_4)"</span>;
<span class="lineno" id=line53></span>  
<span class="lineno" id=line54></span>    <span class="doccomment">Match nothing.</span>
<span class="lineno" id=line55></span>    smatching := <span class="fstring">"|"</span> <span class="fstring">"=&gt;"</span> sexpr =&gt;# <span class="fstring">"`((pat_none ,_sr) ,_3)"</span>;
<span class="lineno" id=line56></span>  
<span class="lineno" id=line57></span>    spattern := sguard_pattern (<span class="fstring">"|"</span> sguard_pattern)* =&gt;# <span class="fstring">"(chain 'pat_alt _1 _2)"</span>;
<span class="lineno" id=line58></span>  
<span class="lineno" id=line59></span>    <span class="doccomment">Match with guard.</span>
<span class="lineno" id=line60></span>    <span class="doccomment">The LHS pattern is match first.</span>
<span class="lineno" id=line61></span>    <span class="doccomment">Then the RHS guard expression is evaluated,</span>
<span class="lineno" id=line62></span>    <span class="doccomment">in a context which includes any extracted match variables.</span>
<span class="lineno" id=line63></span>    <span class="doccomment">If the guard is true, the whole pattern matches,</span>
<span class="lineno" id=line64></span>    <span class="doccomment">otherwise the matching fails.</span>
<span class="lineno" id=line65></span>    sguard_pattern := swith_pattern <span class="fstring">"when"</span> x[sor_condition_pri] =&gt;# <span class="fstring">"`(pat_when ,_sr ,_1 ,_3)"</span>;
<span class="lineno" id=line66></span>    sguard_pattern := swith_pattern =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line67></span>  
<span class="lineno" id=line68></span>    swith_pattern := sas_pattern <span class="fstring">"with"</span> spat_avars =&gt;# <span class="fstring">"`(pat_with ,_sr ,_1 ,_3)"</span>;
<span class="lineno" id=line69></span>      spat_avar := sname <span class="fstring">"="</span> x[sor_condition_pri] =&gt;# <span class="fstring">"`(,_1 ,_3)"</span>;
<span class="lineno" id=line70></span>      spat_avars := <span class="library" title="functional, singly linked list">list</span>::commalist1&lt;spat_avar&gt; =&gt;# <span class="fstring">"_1"</span>; 
<span class="lineno" id=line71></span>    swith_pattern := sas_pattern =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line72></span>  
<span class="lineno" id=line73></span>    <span class="doccomment">Match with naming of subexpression.</span>
<span class="lineno" id=line74></span>    <span class="doccomment">Matches the pattern against the corresponding subexpression,</span>
<span class="lineno" id=line75></span>    <span class="doccomment">and gives it a name. </span>
<span class="lineno" id=line76></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sas_pattern := scons_pattern <span class="fstring">"as"</span> sname =&gt;# <span class="fstring">"`(pat_as ,_sr ,_1 ,_3)"</span>;
<span class="lineno" id=line77></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sas_pattern := scons_pattern =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line78></span>  
<span class="lineno" id=line79></span>    <span class="doccomment">Match a non-empty list.</span>
<span class="lineno" id=line80></span>    <span class="doccomment">The LHS is the head of the list and the RHS is the tail.</span>
<span class="lineno" id=line81></span>    <span class="doccomment">Does not match the empty list.</span>
<span class="lineno" id=line82></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> scons_pattern := stuple_cons_pattern <span class="fstring">"!"</span> scons_pattern =&gt;#
<span class="lineno" id=line83></span>      <span class="fstring">'''`(pat_nonconst_ctor ,_sr ,(nos "Cons") (pat_tuple ,_sr (,_1 ,_3)))'''</span>;
<span class="lineno" id=line84></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> scons_pattern := stuple_cons_pattern =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line85></span>  
<span class="lineno" id=line86></span>    <span class="doccomment">Match a non-empty list using standard list syntax</span>
<span class="lineno" id=line87></span>    <span class="doccomment">This allows for variables in the list syntax and bindings should "just work"</span>
<span class="lineno" id=line88></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> scons_pattern :=<span class="fstring">"["</span> slist_pattern <span class="fstring">"]"</span> =&gt;# 
<span class="lineno" id=line89></span>      <span class="fstring">"_2"</span>;
<span class="lineno" id=line90></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> slist_pattern := scoercive_pattern <span class="fstring">","</span> slist_pattern  =&gt;# 
<span class="lineno" id=line91></span>      <span class="fstring">"""`(pat_nonconst_ctor ,_sr ,(nos "Cons") (pat_tuple ,_sr (,_1 ,_3)))"""</span>;
<span class="lineno" id=line92></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> slist_pattern := scoercive_pattern =&gt;# 
<span class="lineno" id=line93></span>      <span class="fstring">"""`(pat_nonconst_ctor ,_sr ,(nos "Cons") (pat_tuple ,_sr (,_1 
<span class="lineno" id=line94></span>        (pat_const_ctor ,_sr ,(nos "Empty") ))))"""</span>;
<span class="lineno" id=line95></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> slist_pattern := scoercive_pattern <span class="fstring">",,"</span> scoercive_pattern =&gt;# 
<span class="lineno" id=line96></span>      <span class="fstring">"""`(pat_nonconst_ctor ,_sr ,(nos "Cons") (pat_tuple ,_sr (,_1 ,_3)))"""</span>;
<span class="lineno" id=line97></span>  
<span class="lineno" id=line98></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> scons_pattern :=<span class="fstring">"["</span> <span class="fstring">"]"</span> =&gt;# <span class="fstring">"""`(pat_const_ctor ,_sr ,(nos "Empty"))"""</span>;
<span class="lineno" id=line99></span>  
<span class="lineno" id=line100></span>    <span class="doccomment">Match a tuple of at least 3 elements.</span>
<span class="lineno" id=line101></span>    <span class="doccomment">The LHS is the first element of the tuple.</span>
<span class="lineno" id=line102></span>    <span class="doccomment">The RHS is the rest of the tuple.</span>
<span class="lineno" id=line103></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> stuple_cons_pattern := stuple_pattern <span class="fstring">",,"</span> stuple_cons_pattern =&gt;#
<span class="lineno" id=line104></span>      <span class="fstring">"`(pat_tuple_cons ,_sr ,_1 ,_3)"</span>;
<span class="lineno" id=line105></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> stuple_cons_pattern := stuple_pattern <span class="fstring">"&lt;,,&gt;"</span> stuple_cons_pattern =&gt;#
<span class="lineno" id=line106></span>      <span class="fstring">"`(pat_tuple_snoc ,_sr ,_1 ,_3)"</span>;
<span class="lineno" id=line107></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> stuple_cons_pattern := stuple_pattern =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line108></span>  
<span class="lineno" id=line109></span>  
<span class="lineno" id=line110></span>    <span class="doccomment">Match a tuple with 2 or more components.</span>
<span class="lineno" id=line111></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> stuple_pattern := scoercive_pattern (<span class="fstring">","</span> scoercive_pattern )* =&gt;#
<span class="lineno" id=line112></span>      <span class="fstring">"(chain 'pat_tuple _1 _2)"</span>;
<span class="lineno" id=line113></span>  
<span class="lineno" id=line114></span>    <span class="doccomment">Match a value with a coercion.</span>
<span class="lineno" id=line115></span>    <span class="doccomment">The subexpression corresponding to the LHS is compared.</span>
<span class="lineno" id=line116></span>    <span class="doccomment">If it matches the result is coerced to the RHS type expression. </span>
<span class="lineno" id=line117></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> scoercive_pattern := sapplicative_pattern <span class="fstring">"|&gt;"</span> t[sarrow_pri] =&gt;#
<span class="lineno" id=line118></span>      <span class="fstring">"`(pat_coercion ,_sr ,_1 ,_3)"</span>;
<span class="lineno" id=line119></span>  
<span class="lineno" id=line120></span>  
<span class="lineno" id=line121></span>    <span class="comment">// NOTE THIS IS A HACK I just wanted var x : t = expr to be</span>
<span class="lineno" id=line122></span>    <span class="comment">// convertable to let x : t = expr in, i.e. without having to delete the type</span>
<span class="lineno" id=line123></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> scoercive_pattern := sapplicative_pattern <span class="fstring">":"</span> t[sarrow_pri] =&gt;#
<span class="lineno" id=line124></span>      <span class="fstring">"`(pat_coercion ,_sr ,_1 ,_3)"</span>;
<span class="lineno" id=line125></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> scoercive_pattern := sapplicative_pattern =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line126></span>  
<span class="lineno" id=line127></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> scoercive_pattern := stypeexpr <span class="fstring">":&gt;&gt;"</span> sname =&gt;#
<span class="lineno" id=line128></span>      <span class="fstring">"`(pat_subtype ,_sr ,_1 ,_3)"</span>;
<span class="lineno" id=line129></span>  
<span class="lineno" id=line130></span>  
<span class="lineno" id=line131></span>    <span class="doccomment">Match a non-constant sum type constructor</span>
<span class="lineno" id=line132></span>    <span class="doccomment">that is, one with an argument.</span>
<span class="lineno" id=line133></span>    <span class="doccomment">The LHS name must match the constructor used to make the value.</span>
<span class="lineno" id=line134></span>    <span class="doccomment">The RHS pattern is matched against the argument it was constructed with.</span>
<span class="lineno" id=line135></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sapplicative_pattern := sctor_name sargument_pattern =&gt;#
<span class="lineno" id=line136></span>      <span class="fstring">"`(pat_nonconst_ctor ,_sr ,_1 ,_2)"</span>;
<span class="lineno" id=line137></span>  
<span class="lineno" id=line138></span>    <span class="comment">// NOTE: the precednece of the argument is suspect!</span>
<span class="lineno" id=line139></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sapplicative_pattern := sctor_name x[&gt;sapplication_pri]+ sargument_pattern =&gt;#
<span class="lineno" id=line140></span>      <span class="fstring">""";;(begin (display "HO PATTERN ")(display _1)(display "\n")
<span class="lineno" id=line141></span>         ;;(display "arguments=")(display _2) (display "\n")
<span class="lineno" id=line142></span>         ;;(display "pattern=")(display _3)(display "\n")
<span class="lineno" id=line143></span>         `(pat_ho_ctor ,_sr ,_1 ,_2 ,_3)
<span class="lineno" id=line144></span>         ;;)
<span class="lineno" id=line145></span>      """</span>;
<span class="lineno" id=line146></span>  
<span class="lineno" id=line147></span>  
<span class="lineno" id=line148></span>      <span class="doccomment">The sum type constructor can either be a qualified name...</span>
<span class="lineno" id=line149></span>      <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sctor_name := sname =&gt;# <span class="fstring">"`(ast_name ,_sr ,_1 ())"</span>;
<span class="lineno" id=line150></span>  
<span class="lineno" id=line151></span>      <span class="doccomment">or it can be a case literal.</span>
<span class="lineno" id=line152></span>      <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sctor_name := <span class="fstring">"case"</span> sinteger =&gt;# <span class="fstring">"`(ast_case_tag ,_sr ,_2)"</span>;
<span class="lineno" id=line153></span>      <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sctor_name := <span class="fstring">"`"</span> sinteger =&gt;# <span class="fstring">"`(ast_case_tag ,_sr ,_2)"</span>;
<span class="lineno" id=line154></span>  
<span class="lineno" id=line155></span>  
<span class="lineno" id=line156></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sapplicative_pattern := <span class="fstring">"case"</span> sname sargument_pattern =&gt;#
<span class="lineno" id=line157></span>      <span class="fstring">"`(pat_nonconst_variant ,_sr ,_2 ,_3)"</span>;
<span class="lineno" id=line158></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sapplicative_pattern := <span class="fstring">"`"</span> sname sargument_pattern =&gt;#
<span class="lineno" id=line159></span>      <span class="fstring">"`(pat_nonconst_variant ,_sr ,_2 ,_3)"</span>;
<span class="lineno" id=line160></span>  
<span class="lineno" id=line161></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sapplicative_pattern := satomic_pattern =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line162></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sargument_pattern := satomic_pattern =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line163></span>  
<span class="lineno" id=line164></span>    <span class="comment">//-----------------------------------------------------------------------</span>
<span class="lineno" id=line165></span>    <span class="comment">// atomic pattern</span>
<span class="lineno" id=line166></span>  
<span class="lineno" id=line167></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> satomic_pattern := sname =&gt;# 
<span class="lineno" id=line168></span>    <span class="fstring">"""
<span class="lineno" id=line169></span>      (if 
<span class="lineno" id=line170></span>        (char-upper-case? (string-ref _1 0))
<span class="lineno" id=line171></span>        `(pat_const_ctor ,_sr (ast_name ,_sr ,_1 ()))
<span class="lineno" id=line172></span>        `(pat_as ,_sr (pat_any ,_sr) ,_1)
<span class="lineno" id=line173></span>      )
<span class="lineno" id=line174></span>    """</span>;
<span class="lineno" id=line175></span>  
<span class="lineno" id=line176></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> satomic_pattern := <span class="fstring">"?"</span> sname =&gt;# <span class="fstring">"`(pat_as ,_sr (pat_any ,_sr) ,_2)"</span>;
<span class="lineno" id=line177></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> satomic_pattern := <span class="fstring">"val"</span> sname =&gt;# <span class="fstring">"`(pat_as ,_sr (pat_any ,_sr) ,_2)"</span>;
<span class="lineno" id=line178></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> satomic_pattern := <span class="fstring">"#"</span> sctor_name =&gt;# <span class="fstring">"`(pat_const_ctor ,_sr ,_2)"</span>;
<span class="lineno" id=line179></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> satomic_pattern := <span class="fstring">"#"</span> <span class="fstring">"case"</span> sname =&gt;# <span class="fstring">"`(pat_const_variant ,_sr ,_3)"</span>;
<span class="lineno" id=line180></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> satomic_pattern := <span class="fstring">"`"</span> sname =&gt;# <span class="fstring">"`(pat_const_variant ,_sr ,_2)"</span>;
<span class="lineno" id=line181></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> satomic_pattern := <span class="fstring">"case"</span> sinteger =&gt;# <span class="fstring">"`(pat_const_ctor ,_sr (ast_case_tag ,_sr ,_2))"</span>;
<span class="lineno" id=line182></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> satomic_pattern := <span class="fstring">"`"</span> sinteger =&gt;# <span class="fstring">"`(pat_const_ctor ,_sr (ast_case_tag ,_sr ,_2))"</span>;
<span class="lineno" id=line183></span>  
<span class="lineno" id=line184></span>  
<span class="lineno" id=line185></span>    <span class="doccomment">Match the value true = case 1 of 2.</span>
<span class="lineno" id=line186></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> satomic_pattern := <span class="fstring">"true"</span> =&gt;# <span class="fstring">"`(pat_const_ctor ,_sr (ast_case_tag ,_sr 1))"</span>;
<span class="lineno" id=line187></span>  
<span class="lineno" id=line188></span>    <span class="doccomment">Match the value false = case 0 of 2.</span>
<span class="lineno" id=line189></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> satomic_pattern := <span class="fstring">"false"</span> =&gt;# <span class="fstring">"`(pat_const_ctor ,_sr (ast_case_tag ,_sr 0))"</span>;
<span class="lineno" id=line190></span>  
<span class="lineno" id=line191></span>    <span class="doccomment">Match anything without naming the subexpression.</span>
<span class="lineno" id=line192></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> satomic_pattern := <span class="fstring">"_"</span> =&gt;# <span class="fstring">"`(pat_any ,_sr)"</span>;
<span class="lineno" id=line193></span>  
<span class="lineno" id=line194></span>    <span class="doccomment">Precedence control.</span>
<span class="lineno" id=line195></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> satomic_pattern := <span class="fstring">"("</span> spattern <span class="fstring">")"</span> =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line196></span>  
<span class="lineno" id=line197></span>    <span class="doccomment">Match the unit tuple.</span>
<span class="lineno" id=line198></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> satomic_pattern := <span class="fstring">"("</span> <span class="fstring">")"</span> =&gt;# <span class="fstring">"`(pat_tuple ,_sr ())"</span>;
<span class="lineno" id=line199></span>  
<span class="lineno" id=line200></span>    <span class="doccomment">Match a record.</span>
<span class="lineno" id=line201></span>    <span class="doccomment">The record must have fields with the given names.</span>
<span class="lineno" id=line202></span>    <span class="doccomment">It may have more fields though, these are ignored.</span>
<span class="lineno" id=line203></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> satomic_pattern :=  <span class="fstring">"("</span> spat_assign (<span class="fstring">","</span> spat_assign )* <span class="fstring">")"</span> =&gt;#
<span class="lineno" id=line204></span>      <span class="fstring">"`(pat_record ,_sr ,(cons _2 (map second _3)))"</span>
<span class="lineno" id=line205></span>    ;
<span class="lineno" id=line206></span>      <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> spat_assign := sname <span class="fstring">"="</span> spattern =&gt;# <span class="fstring">"`(,_1 ,_3)"</span>;
<span class="lineno" id=line207></span>  
<span class="lineno" id=line208></span>    <span class="doccomment">Polyrecord pattern</span>
<span class="lineno" id=line209></span>    <span class="doccomment">Matches a record with the given fields and assigns</span>
<span class="lineno" id=line210></span>    <span class="doccomment">the rest of the fields to the extension</span>
<span class="lineno" id=line211></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> satomic_pattern :=  <span class="fstring">"("</span> spat_assign (<span class="fstring">","</span> spat_assign )* <span class="fstring">"|"</span> sname <span class="fstring">")"</span> =&gt;#
<span class="lineno" id=line212></span>      <span class="fstring">"`(pat_polyrecord ,_sr ,(cons _2 (map second _3)) ,_5)"</span>
<span class="lineno" id=line213></span>    ;
<span class="lineno" id=line214></span>  
<span class="lineno" id=line215></span>    <span class="doccomment">Match an arbitrary expression.</span>
<span class="lineno" id=line216></span>    <span class="doccomment">Equivalent to </span>
<span class="lineno" id=line217></span>    <span class="doccomment">  //$  ?name when name == expr.</span>
<span class="lineno" id=line218></span>    <span class="doccomment">  private satomic_pattern := "$" "(" sexpr ")" =&gt;# "`(pat_expr ,_sr ,_3)";</span>
<span class="lineno" id=line219></span>  
<span class="lineno" id=line220></span>    <span class="doccomment">Match against any literal value.</span>
<span class="lineno" id=line221></span>    <span class="doccomment">This includes integers, strings, whatever.</span>
<span class="lineno" id=line222></span>    <span class="doccomment">The underlying type must support equality operator (==).</span>
<span class="lineno" id=line223></span>    <span class="doccomment">Usually it would be instance of class Eq.</span>
<span class="lineno" id=line224></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> satomic_pattern := sliteral =&gt;# <span class="fstring">"`(pat_literal ,_sr ,_1)"</span>;
<span class="lineno" id=line225></span>  
<span class="lineno" id=line226></span>    <span class="doccomment">Match against a range specified by two literals.</span>
<span class="lineno" id=line227></span>    <span class="doccomment">The range is inclusive.</span>
<span class="lineno" id=line228></span>    <span class="doccomment">The underlying type must support less than operator (&lt;).</span>
<span class="lineno" id=line229></span>    <span class="doccomment">Usually it would be an instance of class Tord.</span>
<span class="lineno" id=line230></span>  
<span class="lineno" id=line231></span>  <span class="comment">// FIXME: use slices!!!!</span>
<span class="lineno" id=line232></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> satomic_pattern := sliteral <span class="fstring">".."</span> sliteral =&gt;# <span class="fstring">"`(pat_range ,_sr ,_1 ,_3)"</span>;
<span class="lineno" id=line233></span>  
<span class="lineno" id=line234></span>  }
<span class="lineno" id=line235></span>  
</pre></p></div><h2 id='Plugin_Support_DSSL_h'><img src='/share/src/web/images/minus.gif' id='Plugin Support DSSL' onclick='toggle(this,"Plugin_Support_DSSL_d")' alt='+'/> 2.20 Plugin Support DSSL</h2><div id='Plugin_Support_DSSL_d' style='display:block'>
<p>Use to create a preload wrapper around programs that do dynamic
loading to statically link some libraries and then emulate dynamic loading.
Used to create standalone executables for clients from developer dynamic
link model.
</p><pre class='inclusion'>
share/lib/grammar/plugins.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="comment">// Dummy: FIXME: stupid skaller forgot to commit me, and then did a git clean -f.</span>
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line3></span>  (begin
<span class="lineno" id=line4></span>    (define (static-link-symbol lib sym) 
<span class="lineno" id=line5></span>      (let*
<span class="lineno" id=line6></span>        (
<span class="lineno" id=line7></span>           (dummy (begin (display "lib ")(display lib)(display ", symbol ") (display sym)(display "\n")))
<span class="lineno" id=line8></span>           (externc (string-append "extern \"C\" void *" sym ";\n"))
<span class="lineno" id=line9></span>           (rcode `(Str ,externc))
<span class="lineno" id=line10></span>           (hreq `(Header_req ,rcode))
<span class="lineno" id=line11></span>           (reqs `(rreq_atom ,hreq))
<span class="lineno" id=line12></span>           (address_type (nos "address"))
<span class="lineno" id=line13></span>           (address `(Str ,(string-append "&amp;" sym))) 
<span class="lineno" id=line14></span>           (const `(ast_const_decl ,_sr ,sym ,dfltvs ,address_type ,address ,reqs))
<span class="lineno" id=line15></span>           (arg `(ast_tuple ,_sr ,(list (stringof lib) (stringof sym) (nos sym))))
<span class="lineno" id=line16></span>           (addsym `(ast_call ,_sr ,(nos "add_symbol")  ,arg))
<span class="lineno" id=line17></span>        )
<span class="lineno" id=line18></span>        `(ast_seq ,_sr ,(list const addsym))
<span class="lineno" id=line19></span>      )
<span class="lineno" id=line20></span>    )
<span class="lineno" id=line21></span>    (define (plugin-syms lib) 
<span class="lineno" id=line22></span>      `(
<span class="lineno" id=line23></span>        ,(string-append lib "_create_thread_frame")
<span class="lineno" id=line24></span>        ,(string-append lib "_flx_start")
<span class="lineno" id=line25></span>        ,(string-append lib "_setup")
<span class="lineno" id=line26></span>        ,lib
<span class="lineno" id=line27></span>      )
<span class="lineno" id=line28></span>    )
<span class="lineno" id=line29></span>    (define (plugin-defs lib) 
<span class="lineno" id=line30></span>      (let*
<span class="lineno" id=line31></span>        (
<span class="lineno" id=line32></span>          (syms (plugin-syms lib))
<span class="lineno" id=line33></span>          (defs (map (lambda (sym) (static-link-symbol lib sym)) syms))
<span class="lineno" id=line34></span>        )
<span class="lineno" id=line35></span>        `(ast_seq ,_sr ,defs)
<span class="lineno" id=line36></span>      )
<span class="lineno" id=line37></span>    )
<span class="lineno" id=line38></span>  )
<span class="lineno" id=line39></span>  """</span>;
<span class="lineno" id=line40></span>  
<span class="lineno" id=line41></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> plugins
<span class="lineno" id=line42></span>  {
<span class="lineno" id=line43></span>    stmt := <span class="fstring">"static-link-symbol"</span> sname <span class="fstring">"in"</span> <span class="fstring">"plugin"</span> sname <span class="fstring">";"</span> =&gt;# <span class="fstring">"(static-link-symbol _5 _2)"</span>;
<span class="lineno" id=line44></span>  
<span class="lineno" id=line45></span>    stmt := <span class="fstring">"static-link-plugin"</span> sname (<span class="fstring">","</span> sname)* <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line46></span>    <span class="fstring">"""
<span class="lineno" id=line47></span>    (let*
<span class="lineno" id=line48></span>      ( 
<span class="lineno" id=line49></span>        (plugins (cons _2 (map second _3)))
<span class="lineno" id=line50></span>        (defs (map plugin-defs plugins))
<span class="lineno" id=line51></span>      )
<span class="lineno" id=line52></span>      `(ast_seq ,_sr ,defs)
<span class="lineno" id=line53></span>    )
<span class="lineno" id=line54></span>    """</span>;
<span class="lineno" id=line55></span>   
<span class="lineno" id=line56></span>  }
</pre></p></div><h2 id='Requirements_h'><img src='/share/src/web/images/minus.gif' id='Requirements' onclick='toggle(this,"Requirements_d")' alt='+'/> 2.21 Requirements</h2><div id='Requirements_d' style='display:block'>
<p>Used to define dependencies on external resources.
</p><pre class='inclusion'>
share/lib/grammar/requirements.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">Syntax to express and provide dependencies.</span>
<span class="lineno" id=line2></span>  <span class="doccomment">//$ Requirements operate as extensions to the usual</span>
<span class="lineno" id=line3></span>  <span class="doccomment">usage dependencies, to provide the compiler additional</span>
<span class="lineno" id=line4></span>  <span class="doccomment">information regarding C/C++ contructions used in bindings. </span>
<span class="lineno" id=line5></span>  <span class="doccomment">//$ A requirement of a C type is</span>
<span class="lineno" id=line6></span>  <span class="doccomment">activated if, and only if, that type is used</span>
<span class="lineno" id=line7></span>  <span class="doccomment">in a program (or plugin).</span>
<span class="lineno" id=line8></span>  <span class="doccomment">//$ Similarly, a requirement of a function is</span>
<span class="lineno" id=line9></span>  <span class="doccomment">activated if, and only if, the function is used.</span>
<span class="lineno" id=line10></span>  <span class="doccomment">//$ An unnamed requirement in a class is activated</span>
<span class="lineno" id=line11></span>  <span class="doccomment">if any C binding in the class is used.</span>
<span class="lineno" id=line12></span>  <span class="doccomment">Such bindings also propagate to descendent (contained) classes.</span>
<span class="lineno" id=line13></span>  <span class="doccomment">//$ A named requirement is activated only if an active</span>
<span class="lineno" id=line14></span>  <span class="doccomment">requirement requires it.</span>
<span class="lineno" id=line15></span>  <span class="doccomment">Requirements may have "tag names".</span>
<span class="lineno" id=line16></span>  <span class="doccomment">When a requirement is required by name,</span>
<span class="lineno" id=line17></span>  <span class="doccomment">all requirements with that name are activated.</span>
<span class="lineno" id=line18></span>  <span class="doccomment">Circularities in named requirements are permitted and harmless.</span>
<span class="lineno" id=line19></span>  <span class="doccomment">//$ Floating insertions (header, body) are emitted in order of writting</span>
<span class="lineno" id=line20></span>  <span class="doccomment">at fixed places in the generated C++ header and implementation files.</span>
<span class="lineno" id=line21></span>  <span class="doccomment">Floating insertions can themselves have requirements.</span>
<span class="lineno" id=line22></span>  <span class="doccomment">//$ WARNING: there are two gotchas!</span>
<span class="lineno" id=line23></span>  <span class="doccomment">//$ Gotcha 1: requirements on names cannot fail, even if no</span>
<span class="lineno" id=line24></span>  <span class="doccomment">resource is tagged wih that name. This is because requirements</span>
<span class="lineno" id=line25></span>  <span class="doccomment">activate the set of resources with the given name, and as</span>
<span class="lineno" id=line26></span>  <span class="doccomment">usual, a set may be empty.</span>
<span class="lineno" id=line27></span>  <span class="doccomment">//$ Gotcha 2; Just because you put a requires statement in a class</span>
<span class="lineno" id=line28></span>  <span class="doccomment">doesn't mean it will be activated. requirements are only</span>
<span class="lineno" id=line29></span>  <span class="doccomment">triggered by the use of C bindings! Using a Felix entity</span>
<span class="lineno" id=line30></span>  <span class="doccomment">will not trigger the requirement!</span>
<span class="lineno" id=line31></span>  
<span class="lineno" id=line32></span>  
<span class="lineno" id=line33></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> requirements {
<span class="lineno" id=line34></span>    <span class="doccomment">General form of required clause.</span>
<span class="lineno" id=line35></span>    srequires_clause := <span class="fstring">"requires"</span> srequirements =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line36></span>  
<span class="lineno" id=line37></span>    <span class="doccomment">An empty requirement is deemed satisfied.</span>
<span class="lineno" id=line38></span>    srequires_clause := sepsilon =&gt;# <span class="fstring">"'rreq_true"</span>;
<span class="lineno" id=line39></span>  
<span class="lineno" id=line40></span>    <span class="doccomment">A requirement on a requirement defined by name elsewhere.</span>
<span class="lineno" id=line41></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> srequirement:= squalified_name =&gt;# <span class="fstring">"`(Named_req ,_1)"</span>;
<span class="lineno" id=line42></span>  
<span class="lineno" id=line43></span>    <span class="doccomment">A generic "catch all" requirement or specification</span>
<span class="lineno" id=line44></span>    <span class="doccomment">of some property named by a string.</span>
<span class="lineno" id=line45></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> srequirement :=  <span class="fstring">"property"</span> sstring =&gt;# <span class="fstring">"`(Property_req ,_2)"</span>;
<span class="lineno" id=line46></span>  
<span class="lineno" id=line47></span>    <span class="doccomment">A dependency on an external package with a given name.</span>
<span class="lineno" id=line48></span>    <span class="doccomment">Also known as a resource abstraction.</span>
<span class="lineno" id=line49></span>    <span class="doccomment"></span>
<span class="lineno" id=line50></span>    <span class="doccomment">The package name refers to an entry in an external database </span>
<span class="lineno" id=line51></span>    <span class="doccomment">usually represented by directory of text files (usually called "config"),</span>
<span class="lineno" id=line52></span>    <span class="doccomment">each of which usually has extension "fpc".</span>
<span class="lineno" id=line53></span>    <span class="doccomment">  //$ Each file contains a number of fields, which</span>
<span class="lineno" id=line54></span>    <span class="doccomment">may specify a platform dependent filename for</span>
<span class="lineno" id=line55></span>    <span class="doccomment">a shared/dynamic link library, static link library,</span>
<span class="lineno" id=line56></span>    <span class="doccomment">header file, compiler option switch, or other</span>
<span class="lineno" id=line57></span>    <span class="doccomment">information.</span>
<span class="lineno" id=line58></span>    <span class="doccomment">  //$ The package construction abstracts the platform dependent</span>
<span class="lineno" id=line59></span>    <span class="doccomment">data required to locate and use a resource.</span>
<span class="lineno" id=line60></span>    <span class="doccomment"></span>
<span class="lineno" id=line61></span>    <span class="doccomment">The Felix compiler "flxg" generates a list of required</span>
<span class="lineno" id=line62></span>    <span class="doccomment">abstract resources.</span>
<span class="lineno" id=line63></span>    <span class="doccomment">  //$ The Felix command line harness "flx" queries the database</span>
<span class="lineno" id=line64></span>    <span class="doccomment">of resources using the "flx_pkgconfig" tool, and applies</span>
<span class="lineno" id=line65></span>    <span class="doccomment">the relevant arguments to the relevant steps of the </span>
<span class="lineno" id=line66></span>    <span class="doccomment">compilation process.</span>
<span class="lineno" id=line67></span>    <span class="doccomment">  //$ This allows fully automatic compilation and execution</span>
<span class="lineno" id=line68></span>    <span class="doccomment">of Felix programs without the programmer needing to</span>
<span class="lineno" id=line69></span>    <span class="doccomment">continually worry about build scripts.</span>
<span class="lineno" id=line70></span>    <span class="doccomment">  //$ Instead the system installer is required, once,</span>
<span class="lineno" id=line71></span>    <span class="doccomment">to provide the resource database.</span>
<span class="lineno" id=line72></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> srequirement :=  <span class="fstring">"package"</span> scode_spec =&gt;# <span class="fstring">"`(Package_req ,_2)"</span>;
<span class="lineno" id=line73></span>  
<span class="lineno" id=line74></span>    <span class="doccomment">The scanner requirement applies only to a C type binding.</span>
<span class="lineno" id=line75></span>    <span class="doccomment">It specifies the name of a C function which the garbage</span>
<span class="lineno" id=line76></span>    <span class="doccomment">collector can called to search a data structure for pointers.</span>
<span class="lineno" id=line77></span>    <span class="doccomment">  //$ By default, if no scanner is specified for a C type,</span>
<span class="lineno" id=line78></span>    <span class="doccomment">the type is assumed not to contain any Felix pointers.</span>
<span class="lineno" id=line79></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> srequirement :=  <span class="fstring">"scanner"</span> scode_spec =&gt;# <span class="fstring">"`(Scanner_req ,_2)"</span>;
<span class="lineno" id=line80></span>  
<span class="lineno" id=line81></span>    <span class="doccomment">The finaliser requirement applies only to a C type binding.</span>
<span class="lineno" id=line82></span>    <span class="doccomment">It specifies the name of a C function which the garbage</span>
<span class="lineno" id=line83></span>    <span class="doccomment">collector can call to finalise an object prior to freeing up</span>
<span class="lineno" id=line84></span>    <span class="doccomment">the underlying memory.</span>
<span class="lineno" id=line85></span>    <span class="doccomment">  //$ By default, if no finaliser is specifed, the C++ destructor is called.</span>
<span class="lineno" id=line86></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> srequirement :=  <span class="fstring">"finaliser"</span> scode_spec =&gt;# <span class="fstring">"`(Finaliser_req ,_2)"</span>;
<span class="lineno" id=line87></span>  
<span class="lineno" id=line88></span>    <span class="doccomment">The encoder requirement applies only to a C type binding.</span>
<span class="lineno" id=line89></span>    <span class="doccomment">It specifies the name of a C function which can be called </span>
<span class="lineno" id=line90></span>    <span class="doccomment">to serialise one element of the object.</span>
<span class="lineno" id=line91></span>    <span class="doccomment"></span>
<span class="lineno" id=line92></span>    <span class="doccomment">By default, if no encoder is specifed, memcpy is used.</span>
<span class="lineno" id=line93></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> srequirement :=  <span class="fstring">"encoder"</span> scode_spec =&gt;# <span class="fstring">"`(Encoder_req ,_2)"</span>;
<span class="lineno" id=line94></span>  
<span class="lineno" id=line95></span>    <span class="doccomment">The decoder requirement applies only to a C type binding.</span>
<span class="lineno" id=line96></span>    <span class="doccomment">It specifies the name of a C function which can be called </span>
<span class="lineno" id=line97></span>    <span class="doccomment">to deserialise one element of the object.</span>
<span class="lineno" id=line98></span>    <span class="doccomment"></span>
<span class="lineno" id=line99></span>    <span class="doccomment">By default, if no decoder is specifed, memcpy is used.</span>
<span class="lineno" id=line100></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> srequirement :=  <span class="fstring">"decoder"</span> scode_spec =&gt;# <span class="fstring">"`(Decoder_req ,_2)"</span>;
<span class="lineno" id=line101></span>  
<span class="lineno" id=line102></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> srequirement :=  <span class="fstring">"index"</span> sinteger =&gt;# <span class="fstring">"`(Index_req ,_2)"</span>;
<span class="lineno" id=line103></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> srequirement :=  <span class="fstring">"index"</span> sname =&gt;# <span class="fstring">"`(Named_index_req ,_2)"</span>;
<span class="lineno" id=line104></span>  
<span class="lineno" id=line105></span>    <span class="doccomment">Requirement expressions. Deprecated.</span>
<span class="lineno" id=line106></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> srequirement_atom:= srequirement =&gt;# <span class="fstring">"`(rreq_atom ,_1)"</span>;
<span class="lineno" id=line107></span>  
<span class="lineno" id=line108></span>    <span class="doccomment">Requirement expressions. Deprecated.</span>
<span class="lineno" id=line109></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> srequirement_atom:= <span class="fstring">"("</span> srequirements <span class="fstring">")"</span> =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line110></span>  
<span class="lineno" id=line111></span>    <span class="doccomment">Requirement expressions. Deprecated.</span>
<span class="lineno" id=line112></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> srequirement_and:= srequirement_and <span class="fstring">"and"</span> srequirement_atom =&gt;#
<span class="lineno" id=line113></span>      <span class="fstring">"`(rreq_and ,_1 ,_3)"</span>;
<span class="lineno" id=line114></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> srequirement_and:= srequirement_atom =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line115></span>  
<span class="lineno" id=line116></span>    <span class="doccomment">Requirement expressions. Deprecated.</span>
<span class="lineno" id=line117></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> srequirement_or:= srequirement_or <span class="fstring">"or"</span> srequirement_and =&gt;#
<span class="lineno" id=line118></span>      <span class="fstring">"`(rreq_or ,_1 ,_3)"</span>;
<span class="lineno" id=line119></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> srequirement_or:= srequirement_and =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line120></span>  
<span class="lineno" id=line121></span>    <span class="doccomment">Requirement expressions: a comma separated list</span>
<span class="lineno" id=line122></span>    <span class="doccomment">of requirements specified each one of the requirements</span>
<span class="lineno" id=line123></span>    <span class="doccomment">applies independently.</span>
<span class="lineno" id=line124></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> srequirements:= srequirements <span class="fstring">","</span> srequirement_or =&gt;#
<span class="lineno" id=line125></span>      <span class="fstring">"`(rreq_and ,_1 ,_3)"</span>;
<span class="lineno" id=line126></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> srequirements:= srequirement_or =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line127></span>  
<span class="lineno" id=line128></span>    <span class="doccomment">The body requirement is a floating requirement that</span>
<span class="lineno" id=line129></span>    <span class="doccomment">specifies that the given code</span>
<span class="lineno" id=line130></span>    <span class="doccomment">string be inserted into the output "near the top"</span>
<span class="lineno" id=line131></span>    <span class="doccomment">of the generated C++ body (cpp) file.</span>
<span class="lineno" id=line132></span>    <span class="doccomment">  //$ It can be used to emit utiliy functions</span>
<span class="lineno" id=line133></span>    <span class="doccomment">written in C.</span>
<span class="lineno" id=line134></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> srequirement := <span class="fstring">"body"</span> scode_spec =&gt;# <span class="fstring">"`(Body_req ,_2)"</span>;
<span class="lineno" id=line135></span>  
<span class="lineno" id=line136></span>    <span class="doccomment">The header requirement is a floating requirement that</span>
<span class="lineno" id=line137></span>    <span class="doccomment">specifies that the given code</span>
<span class="lineno" id=line138></span>    <span class="doccomment">string be inserted into the output "near the top"</span>
<span class="lineno" id=line139></span>    <span class="doccomment">of the generated C++ header (hpp) file.</span>
<span class="lineno" id=line140></span>    <span class="doccomment">  //$ It is typically used to emit a "#include" directive</span>
<span class="lineno" id=line141></span>    <span class="doccomment">so that the requiring binding has relevant types</span>
<span class="lineno" id=line142></span>    <span class="doccomment">and functions available.</span>
<span class="lineno" id=line143></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> srequirement := <span class="fstring">"header"</span> scode_spec =&gt;# <span class="fstring">"`(Header_req ,_2)"</span>;
<span class="lineno" id=line144></span>  
<span class="lineno" id=line145></span>    <span class="doccomment">A Felix string used as a code specification</span>
<span class="lineno" id=line146></span>    <span class="doccomment">is treated as a template with special coding</span>
<span class="lineno" id=line147></span>    <span class="doccomment">internally which can be replaced.</span>
<span class="lineno" id=line148></span>    <span class="doccomment">  //$ This feature supports the fact that Felix code</span>
<span class="lineno" id=line149></span>    <span class="doccomment">insertions can be polymorphic.</span>
<span class="lineno" id=line150></span>    scode_spec := sstring =&gt;# <span class="fstring">"`(StrTemplate ,_1)"</span>;
<span class="lineno" id=line151></span>  
<span class="lineno" id=line152></span>    <span class="doccomment">A c-string like c"xxxx" is emitted literally</span>
<span class="lineno" id=line153></span>    <span class="doccomment">without any substitutions.</span>
<span class="lineno" id=line154></span>    scode_spec := scstring =&gt;# <span class="fstring">"`(Str ,_1)"</span>;
<span class="lineno" id=line155></span>  
<span class="lineno" id=line156></span>    <span class="doccomment">This is a special code to make specific</span>
<span class="lineno" id=line157></span>    <span class="doccomment">that a binding is an identity which can</span>
<span class="lineno" id=line158></span>    <span class="doccomment">be optimised away.</span>
<span class="lineno" id=line159></span>    <span class="comment">//scode_spec := "ident" =&gt;# "'Identity";</span>
<span class="lineno" id=line160></span>  
<span class="lineno" id=line161></span>    <span class="doccomment">The anonymous requires statement specifies requirements which </span>
<span class="lineno" id=line162></span>    <span class="doccomment">propagates to all C bindings</span>
<span class="lineno" id=line163></span>    <span class="doccomment">in the same class, or any descendant (enclosed) class.</span>
<span class="lineno" id=line164></span>    stmt := <span class="fstring">"requires"</span> srequirements <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line165></span>      <span class="fstring">"""`(ast_insert ,_sr "_root" ,dfltvs (Str "") body ,_2)"""</span>;
<span class="lineno" id=line166></span>  
<span class="lineno" id=line167></span>    stmt := <span class="fstring">"export"</span> <span class="fstring">"requires"</span> srequirements <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line168></span>      <span class="fstring">"""`(ast_seq ,_sr 
<span class="lineno" id=line169></span>           ,(list 
<span class="lineno" id=line170></span>             `(ast_insert ,_sr "_root" ,dfltvs (Str "") body ,_3)
<span class="lineno" id=line171></span>             `(ast_export_requirement ,_sr ,_3)
<span class="lineno" id=line172></span>           )
<span class="lineno" id=line173></span>        )
<span class="lineno" id=line174></span>      """</span>;
<span class="lineno" id=line175></span>  
<span class="lineno" id=line176></span>  
<span class="lineno" id=line177></span>    <span class="doccomment">The named requires statement simply names a requirement.</span>
<span class="lineno" id=line178></span>    stmt := sname <span class="fstring">"requires"</span> srequirements <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line179></span>      <span class="fstring">"""`(ast_insert ,_sr ,_1 ,dfltvs (Str "") body ,_3)"""</span>;
<span class="lineno" id=line180></span>  
<span class="lineno" id=line181></span>    <span class="doccomment">The header statement specifies a header requirement which</span>
<span class="lineno" id=line182></span>    <span class="doccomment">propagates to all C bindings</span>
<span class="lineno" id=line183></span>    <span class="doccomment">in the same class, or any descendant (enclosed) class.</span>
<span class="lineno" id=line184></span>    stmt := <span class="fstring">"header"</span> scode_spec srequires_clause <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line185></span>      <span class="fstring">"""`(ast_insert ,_sr "_root" ,dfltvs ,_2 header ,_3))"""</span>;
<span class="lineno" id=line186></span>  
<span class="lineno" id=line187></span>    <span class="doccomment">The body statement specifies a header requirement which</span>
<span class="lineno" id=line188></span>    <span class="doccomment">propagates to all C bindings</span>
<span class="lineno" id=line189></span>    <span class="doccomment">in the same class, or any descendant (enclosed) class.</span>
<span class="lineno" id=line190></span>    stmt := <span class="fstring">"body"</span> scode_spec srequires_clause <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line191></span>      <span class="fstring">"""`(ast_insert ,_sr "_root" ,dfltvs ,_2 body ,_3))"""</span>;
<span class="lineno" id=line192></span>  
<span class="lineno" id=line193></span>    <span class="doccomment">Named header requirement.</span>
<span class="lineno" id=line194></span>    stmt := <span class="fstring">"header"</span> sdeclname <span class="fstring">"="</span> scode_spec srequires_clause <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line195></span>      <span class="fstring">"""
<span class="lineno" id=line196></span>      `(ast_insert ,_sr ,(first _2) ,(second _2) ,_4 header ,_5)
<span class="lineno" id=line197></span>       """</span>;
<span class="lineno" id=line198></span>  
<span class="lineno" id=line199></span>    <span class="doccomment">Named body requirement.</span>
<span class="lineno" id=line200></span>    stmt := <span class="fstring">"body"</span> sdeclname <span class="fstring">"="</span> scode_spec srequires_clause <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line201></span>      <span class="fstring">"""
<span class="lineno" id=line202></span>      `(ast_insert ,_sr ,(first _2) ,(second _2) ,_4 body ,_5)
<span class="lineno" id=line203></span>       """</span>;
<span class="lineno" id=line204></span>  }
<span class="lineno" id=line205></span>  
</pre></p></div><h2 id='Save_Thunk._h'><img src='/share/src/web/images/minus.gif' id='Save Thunk.' onclick='toggle(this,"Save_Thunk._d")' alt='+'/> 2.22 Save Thunk.</h2><div id='Save_Thunk._d' style='display:block'>
<p>Special code to tell the parser when to save the automaton
to disk.
</p><pre class='inclusion'>
share/lib/grammar/save.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Open a module or class">open</span> <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> felix;
<span class="lineno" id=line2></span>  SAVE;
</pre></p></div><h2 id='Statements_h'><img src='/share/src/web/images/minus.gif' id='Statements' onclick='toggle(this,"Statements_d")' alt='+'/> 2.23 Statements</h2><div id='Statements_d' style='display:block'>
<p>General statements.
</p><pre class='inclusion'>
share/lib/grammar/statements.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">A grab bag of miscellaneous statements and </span>
<span class="lineno" id=line2></span>  <span class="doccomment">nonterminals used to construct other statements.</span>
<span class="lineno" id=line3></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> statements {
<span class="lineno" id=line4></span>    <span class="big_keyword" title="specify requirements">requires</span> expressions;
<span class="lineno" id=line5></span>  
<span class="lineno" id=line6></span>    <span class="doccomment">A comment statement based on a string argument.</span>
<span class="lineno" id=line7></span>    stmt := <span class="fstring">"comment"</span> sstring <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_comment ,_sr ,_2)"</span>;
<span class="lineno" id=line8></span>  
<span class="lineno" id=line9></span>    <span class="doccomment">Statement qualifier which makes a definition</span>
<span class="lineno" id=line10></span>    <span class="doccomment">private to the containing module or class.</span>
<span class="lineno" id=line11></span>    stmt := <span class="fstring">"private"</span> stmt =&gt;# <span class="fstring">"`(ast_private ,_sr ,_2)"</span>;
<span class="lineno" id=line12></span>  
<span class="lineno" id=line13></span>    <span class="doccomment">Deprecated method of documenting a definition.</span>
<span class="lineno" id=line14></span>    stmt := <span class="fstring">"publish"</span> sstring stmt =&gt;# <span class="fstring">"_3"</span>;
<span class="lineno" id=line15></span>  
<span class="lineno" id=line16></span>    <span class="doccomment">An empty statement.</span>
<span class="lineno" id=line17></span>    stmt := <span class="fstring">";"</span> =&gt;# <span class="fstring">"""`(ast_nop ,_sr "")"""</span>;
<span class="lineno" id=line18></span>  
<span class="lineno" id=line19></span>    <span class="doccomment">Include file directive.</span>
<span class="lineno" id=line20></span>    <span class="doccomment">This is similar to C's pre-processor include except that</span>
<span class="lineno" id=line21></span>    <span class="doccomment">the file is parsed and macro processed first, entirely</span>
<span class="lineno" id=line22></span>    <span class="doccomment">independently of the including file, and then the</span>
<span class="lineno" id=line23></span>    <span class="doccomment">resulting AST is inserted into the current AST.</span>
<span class="lineno" id=line24></span>    <span class="doccomment">Thus the included file also has no influence on</span>
<span class="lineno" id=line25></span>    <span class="doccomment">the including file either: the two files are parsed</span>
<span class="lineno" id=line26></span>    <span class="doccomment">entirely independently.</span>
<span class="lineno" id=line27></span>    stmt := <span class="fstring">"include"</span> sstring <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_include ,_sr ,_2)"</span>;
<span class="lineno" id=line28></span>  
<span class="lineno" id=line29></span>    <span class="doccomment">A declarative name consists of an identifier and</span>
<span class="lineno" id=line30></span>    <span class="doccomment">an (optional) type variable specification.</span>
<span class="lineno" id=line31></span>    <span class="comment">// note: list is reversed, eg X::Y::name goes to list name, Y, Z</span>
<span class="lineno" id=line32></span>    sdeclname := sname stvarlist =&gt;# <span class="fstring">"""`(,_1 ,_2)"""</span>;
<span class="lineno" id=line33></span>  
<span class="lineno" id=line34></span>    <span class="doccomment">A way to contruct a new abstract type out of an existing type.</span>
<span class="lineno" id=line35></span>    <span class="doccomment">Only two operations are available on this new type:</span>
<span class="lineno" id=line36></span>    <span class="doccomment">  //$ _repr_ t: exposes the underlying type</span>
<span class="lineno" id=line37></span>    <span class="doccomment">make_t  : constructs the type from the underlying type.</span>
<span class="lineno" id=line38></span>    <span class="doccomment">  //$ These operations are only available in the class or module</span>
<span class="lineno" id=line39></span>    <span class="doccomment">containing the new type definition. This allows the private</span>
<span class="lineno" id=line40></span>    <span class="doccomment">details of the type to be accessed so as to define operations</span>
<span class="lineno" id=line41></span>    <span class="doccomment">on it, inside the same space as the definition, but leaves</span>
<span class="lineno" id=line42></span>    <span class="doccomment">the type abstract externally.</span>
<span class="lineno" id=line43></span>    stmt := stype_qual* <span class="fstring">"type"</span> sdeclname <span class="fstring">"="</span> <span class="fstring">"new"</span> stype <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line44></span>      <span class="fstring">"""
<span class="lineno" id=line45></span>      `(ast_newtype ,_sr ,(first _3) ,(second _3) ,_6)
<span class="lineno" id=line46></span>      """</span>;
<span class="lineno" id=line47></span>  
<span class="lineno" id=line48></span>    stmt := <span class="fstring">"instance"</span> <span class="fstring">"type"</span> sdeclname <span class="fstring">"="</span> stype <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line49></span>      <span class="fstring">"""
<span class="lineno" id=line50></span>      `(ast_instance_type ,_sr ,(first _3) ,(second _3) ,_5)
<span class="lineno" id=line51></span>      """</span>;
<span class="lineno" id=line52></span>  
<span class="lineno" id=line53></span>  
<span class="lineno" id=line54></span>    <span class="doccomment">Type constraint syntax.</span>
<span class="lineno" id=line55></span>    <span class="doccomment">Type constraints are ways to constrain possible types</span>
<span class="lineno" id=line56></span>    <span class="doccomment">which type variables may take on.</span>
<span class="lineno" id=line57></span>    stypeclass_constraint_list := stypeclass_constraint (<span class="fstring">","</span> stypeclass_constraint )* =&gt;# 
<span class="lineno" id=line58></span>      <span class="fstring">"(cons _1 (map second _2))"</span>;
<span class="lineno" id=line59></span>  
<span class="lineno" id=line60></span>    stypeclass_constraint := squalified_name =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line61></span>  
<span class="lineno" id=line62></span>    <span class="doccomment">Allow T is Real to mean Real[T].</span>
<span class="lineno" id=line63></span>    <span class="comment">// probably should generalise to use ast_lookup </span>
<span class="lineno" id=line64></span>    stypeclass_constraint := stypeexpr <span class="fstring">"is"</span> sname =&gt;# <span class="fstring">"`(ast_name ,_sr ,_3 (texprs (,_1)))"</span>;
<span class="lineno" id=line65></span>  
<span class="lineno" id=line66></span>    <span class="doccomment">A constraint specifying types require an instance</span>
<span class="lineno" id=line67></span>    <span class="doccomment">of a particular type class.</span>
<span class="lineno" id=line68></span>    stype_constraint := <span class="fstring">"with"</span> stypeclass_constraint_list =&gt;# 
<span class="lineno" id=line69></span>     <span class="fstring">"`(,ttrue ,_2)"</span>;
<span class="lineno" id=line70></span>  
<span class="lineno" id=line71></span>    <span class="doccomment">A predicative or equational constraint.</span>
<span class="lineno" id=line72></span>    stype_constraint := <span class="fstring">"where"</span> stype =&gt;# <span class="fstring">"`(,_2 ())"</span>;
<span class="lineno" id=line73></span>  
<span class="lineno" id=line74></span>    <span class="doccomment">Both types of constraint together.</span>
<span class="lineno" id=line75></span>    stype_constraint := <span class="fstring">"with"</span> stypeclass_constraint_list <span class="fstring">"where"</span> stype =&gt;#
<span class="lineno" id=line76></span>      <span class="fstring">"`(,_4 ,_2)"</span>;
<span class="lineno" id=line77></span>    
<span class="lineno" id=line78></span>    <span class="doccomment">Both types of constraint together.</span>
<span class="lineno" id=line79></span>    stype_constraint := <span class="fstring">"where"</span> stype <span class="fstring">"with"</span> stypeclass_constraint_list =&gt;#
<span class="lineno" id=line80></span>      <span class="fstring">"`(,_2 ,_4)"</span>;
<span class="lineno" id=line81></span>  
<span class="lineno" id=line82></span>    <span class="doccomment">The constraint is empty if the polymorphism is parametric.</span>
<span class="lineno" id=line83></span>    stype_constraint := sepsilon =&gt;# <span class="fstring">"`(,ttrue ())"</span>;
<span class="lineno" id=line84></span>  
<span class="lineno" id=line85></span>    <span class="doccomment">Individual type variable equational constraint.</span>
<span class="lineno" id=line86></span>    seqorin:= <span class="fstring">"="</span> stypeexpr =&gt;# <span class="fstring">"`(Eq ,_2)"</span>;
<span class="lineno" id=line87></span>  
<span class="lineno" id=line88></span>    <span class="doccomment">Individual type variable membership constraint.</span>
<span class="lineno" id=line89></span>    seqorin:= <span class="fstring">"in"</span> stypeset =&gt;# <span class="fstring">"`(In ,_2)"</span>;
<span class="lineno" id=line90></span>  
<span class="lineno" id=line91></span>    <span class="doccomment">No constraint!</span>
<span class="lineno" id=line92></span>    seqorin:= sepsilon =&gt;# <span class="fstring">"'NoConstraint"</span>;
<span class="lineno" id=line93></span>  
<span class="lineno" id=line94></span>    <span class="comment">// variance spec: + covariant, - contravariant, nothing: invariant</span>
<span class="lineno" id=line95></span>    svariance := <span class="fstring">"+"</span> =&gt;# <span class="fstring">"'covariant"</span>;
<span class="lineno" id=line96></span>    svariance := <span class="fstring">"-"</span> =&gt;# <span class="fstring">"'contravariant"</span>;
<span class="lineno" id=line97></span>    svariance := sepsilon =&gt;# <span class="fstring">"'invariant"</span>;
<span class="lineno" id=line98></span>  
<span class="lineno" id=line99></span>    <span class="doccomment">A type variable, possibly with an individual constraint.</span>
<span class="lineno" id=line100></span>    stvar := svariance sname seqorin =&gt;# <span class="fstring">"""`(,_2 (knd_name "TYPE") ,_3 ,_1)"""</span>; 
<span class="lineno" id=line101></span>  
<span class="lineno" id=line102></span>    <span class="doccomment">A type variable with an individual constraint.</span>
<span class="lineno" id=line103></span>    <span class="doccomment">This is usually the same as a predicate.</span>
<span class="lineno" id=line104></span>    stvar := svariance sname <span class="fstring">":"</span> skindexpr seqorin =&gt;# <span class="fstring">"`(,_2 ,_4 ,_5 ,_1)"</span>;
<span class="lineno" id=line105></span>  
<span class="lineno" id=line106></span>    <span class="doccomment">A list of type variables with optional individual constraints.</span>
<span class="lineno" id=line107></span>    stvar_comma_list := stvar (<span class="fstring">","</span> stvar)* =&gt;# <span class="fstring">"(cons _1 (map second _2))"</span>;
<span class="lineno" id=line108></span>    stvar_comma_list := sepsilon =&gt;# <span class="fstring">"'()"</span>;
<span class="lineno" id=line109></span>  
<span class="lineno" id=line110></span>    <span class="doccomment">A type variable specification consists of</span>
<span class="lineno" id=line111></span>    <span class="doccomment">a possibly empty list of type variables with </span>
<span class="lineno" id=line112></span>    <span class="doccomment">individual constraints, plus an optional</span>
<span class="lineno" id=line113></span>    <span class="doccomment">type constraint relating the specified variables.</span>
<span class="lineno" id=line114></span>    stvarlist := sepsilon =&gt;# <span class="fstring">"dfltvs"</span>;
<span class="lineno" id=line115></span>    stvarlist := <span class="fstring">"["</span> stvar_comma_list stype_constraint <span class="fstring">"]"</span> =&gt;#
<span class="lineno" id=line116></span>      <span class="fstring">"(tvfixup _2 _3)"</span>;
<span class="lineno" id=line117></span>  
<span class="lineno" id=line118></span>  
<span class="lineno" id=line119></span>    stypeparameter := sname <span class="fstring">":"</span> k[sarrow_pri] =&gt;# <span class="fstring">"`(,_1 ,_3)"</span>;
<span class="lineno" id=line120></span>    stypeparameter := sname =&gt;# <span class="fstring">'`(,_1 (knd_name "TYPE"))'</span>;
<span class="lineno" id=line121></span>    stypeparameter_comma_list := sepsilon =&gt;# <span class="fstring">"()"</span>;
<span class="lineno" id=line122></span>    stypeparameter_comma_list := stypeparameter (<span class="fstring">","</span> stypeparameter)* =&gt;# <span class="fstring">"(cons _1 (map second _2))"</span>;
<span class="lineno" id=line123></span>  
<span class="lineno" id=line124></span>    stypefun_arg := sname =&gt;# <span class="fstring">'`((,_1 (knd_name "TYPE")))'</span>;
<span class="lineno" id=line125></span>    stypefun_arg := <span class="fstring">"("</span> stypeparameter_comma_list <span class="fstring">")"</span> =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line126></span>    stypefun_args := stypefun_arg+  =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line127></span>  
<span class="lineno" id=line128></span>    <span class="doccomment">The todo no-op is primarily a way to document</span>
<span class="lineno" id=line129></span>    <span class="doccomment">unfinished code. Currently no action is taken.</span>
<span class="lineno" id=line130></span>    <span class="doccomment">Felix reserves the right to throw an exception,</span>
<span class="lineno" id=line131></span>    <span class="doccomment">or emit some diagnostics in future versions.</span>
<span class="lineno" id=line132></span>    stodo := <span class="fstring">"todo"</span> sstring <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(ast_nop ,_sr ,_2)"</span>;
<span class="lineno" id=line133></span>    stodo := <span class="fstring">"todo"</span> <span class="fstring">";"</span> =&gt;# <span class="fstring">"""`(ast_nop ,_sr "todo")"""</span>;
<span class="lineno" id=line134></span>  
<span class="lineno" id=line135></span>    <span class="doccomment">Compound construction.</span>
<span class="lineno" id=line136></span>    <span class="doccomment">Note his is NOT a statement.</span>
<span class="lineno" id=line137></span>    <span class="doccomment">A compound followed by a semi-colon ";" is, however.</span>
<span class="lineno" id=line138></span>    <span class="comment">//scompound := "{" stmt* "}" =&gt;# "_2";</span>
<span class="lineno" id=line139></span>    scompound := <span class="fstring">"{"</span> sstatements <span class="fstring">"}"</span> =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line140></span>  
<span class="lineno" id=line141></span>    <span class="doccomment">A suffixed name.</span>
<span class="lineno" id=line142></span>    <span class="doccomment">Used  to name an overloaded function.</span>
<span class="lineno" id=line143></span>    sname_suffix:= <span class="fstring">","</span> sname sname_suffix =&gt;# <span class="fstring">"(cons _2 _3)"</span>;
<span class="lineno" id=line144></span>    sname_suffix:= <span class="fstring">","</span> sname =&gt;# <span class="fstring">"`(,_2)"</span>;
<span class="lineno" id=line145></span>  
<span class="lineno" id=line146></span>  
<span class="lineno" id=line147></span>  }
<span class="lineno" id=line148></span>  
</pre></p></div><h2 id='TeX_Symbols_h'><img src='/share/src/web/images/minus.gif' id='TeX Symbols' onclick='toggle(this,"TeX_Symbols_d")' alt='+'/> 2.24 TeX Symbols</h2><div id='TeX_Symbols_d' style='display:block'>
<p>A fairly complete set of TeX, LaTeX and AMSTeX symbols
available for client use with predefined precedences.
Some symbols are used elsewhere in the grammar and may
not be included here because they have been assigned 
different precedences.
</p><pre class='inclusion'>
share/lib/grammar/texsyms.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">This file contains a huge set of operators from TeX, AMSTeX and LaTeX.</span>
<span class="lineno" id=line2></span>  <span class="comment">// </span>
<span class="lineno" id=line3></span>  <span class="doccomment">The precedence classification is currently very crude.</span>
<span class="lineno" id=line4></span>  <span class="doccomment">Some operators are duplicate semantics with different names.</span>
<span class="lineno" id=line5></span>  <span class="doccomment">Some are negations, and should be handled properly.</span>
<span class="lineno" id=line6></span>  <span class="doccomment">//$ Nouns such as Greek letters are not included because they're atoms and don't</span>
<span class="lineno" id=line7></span>  <span class="doccomment">need any parsing.</span>
<span class="lineno" id=line8></span>  <span class="doccomment">syntax texsyms {</span>
<span class="lineno" id=line9></span>  
<span class="lineno" id=line10></span>  <span class="comment">// A</span>
<span class="lineno" id=line11></span>  
<span class="lineno" id=line12></span>    bin := <span class="fstring">"\amalg"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line13></span>    cmp := <span class="fstring">"\approx"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line14></span>    cmp := <span class="fstring">"\approxeq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line15></span>    cmp := <span class="fstring">"\Arrowvert"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line16></span>    cmp := <span class="fstring">"\arrowvert"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line17></span>    cmp := <span class="fstring">"\asymp"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line18></span>  
<span class="lineno" id=line19></span>  <span class="comment">// B</span>
<span class="lineno" id=line20></span>  
<span class="lineno" id=line21></span>    cmp := <span class="fstring">"\backsim"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line22></span>    cmp := <span class="fstring">"\backsimeq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line23></span>    cmp := <span class="fstring">"\bar"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line24></span>    cmp := <span class="fstring">"\barwedge"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line25></span>    cmp := <span class="fstring">"\between"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line26></span>    bin := <span class="fstring">"\bigcap"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line27></span>    bin := <span class="fstring">"\bigcirc"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line28></span>    bin := <span class="fstring">"\bigcup"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line29></span>    bin := <span class="fstring">"\bigodot"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line30></span>    bin := <span class="fstring">"\bigoplus"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line31></span>    bin := <span class="fstring">"\bigotimes"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line32></span>    bin := <span class="fstring">"\bigsqcup"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line33></span>    bin := <span class="fstring">"\bigtriangledown"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line34></span>    bin := <span class="fstring">"\bigtriangleup"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line35></span>    bin := <span class="fstring">"\biguplus"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line36></span>    bin := <span class="fstring">"\bigvee"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line37></span>    bin := <span class="fstring">"\bigwedge"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line38></span>    bin := <span class="fstring">"\bowtie"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line39></span>    bin := <span class="fstring">"\Box"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line40></span>    bin := <span class="fstring">"\boxdot"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line41></span>    bin := <span class="fstring">"\boxminus"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line42></span>    bin := <span class="fstring">"\boxplus"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line43></span>    bin := <span class="fstring">"\boxtimes"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line44></span>    cmp := <span class="fstring">"\Bumpeq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line45></span>    cmp := <span class="fstring">"\bumpeq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line46></span>  
<span class="lineno" id=line47></span>  <span class="comment">// C</span>
<span class="lineno" id=line48></span>  
<span class="lineno" id=line49></span>    bin := <span class="fstring">"\Cap"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line50></span>    bin := <span class="fstring">"\cdot"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line51></span>    bin := <span class="fstring">"\cdotp"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line52></span>    cmp := <span class="fstring">"\circeq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line53></span>    bin := <span class="fstring">"\circledast"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line54></span>    bin := <span class="fstring">"\circledcirc"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line55></span>    bin := <span class="fstring">"\circleddash"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line56></span>    cmp := <span class="fstring">"\cong"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line57></span>    bin := <span class="fstring">"\coprod"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line58></span>    bin := <span class="fstring">"\Cup"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line59></span>    cmp := <span class="fstring">"\curlyeqprec"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line60></span>    cmp := <span class="fstring">"\curlyeqsucc"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line61></span>    bin := <span class="fstring">"\curlyvee"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line62></span>    bin := <span class="fstring">"\curlywedge"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line63></span>  
<span class="lineno" id=line64></span>  <span class="comment">// D</span>
<span class="lineno" id=line65></span>  
<span class="lineno" id=line66></span>    arr := <span class="fstring">"\dashleftarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line67></span>    arr := <span class="fstring">"\dashrightarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line68></span>    bin := <span class="fstring">"\divideontimes"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line69></span>    cmp := <span class="fstring">"\doteq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line70></span>    cmp := <span class="fstring">"\Doteq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line71></span>    cmp := <span class="fstring">"\doteqdot"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line72></span>    bin := <span class="fstring">"\dotplus"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line73></span>    bin := <span class="fstring">"\doublebarwedge"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line74></span>    bin := <span class="fstring">"\doublecap"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line75></span>    bin := <span class="fstring">"\doublecup"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line76></span>    bin := <span class="fstring">"\Downarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line77></span>    bin := <span class="fstring">"\downarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line78></span>    bin := <span class="fstring">"\downdownarrows"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line79></span>    bin := <span class="fstring">"\downharpoonleft"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line80></span>    bin := <span class="fstring">"\downharpoonright"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line81></span>  
<span class="lineno" id=line82></span>  <span class="comment">// E</span>
<span class="lineno" id=line83></span>  
<span class="lineno" id=line84></span>    cmp := <span class="fstring">"\eqcirc"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line85></span>    cmp := <span class="fstring">"\eqsim"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line86></span>    cmp := <span class="fstring">"\eqslantgtr"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line87></span>    cmp := <span class="fstring">"\eqslantless"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line88></span>    cmp := <span class="fstring">"\equiv"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line89></span>  
<span class="lineno" id=line90></span>  <span class="comment">// F</span>
<span class="lineno" id=line91></span>  
<span class="lineno" id=line92></span>    bin := <span class="fstring">"\fallingdotseq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line93></span>  
<span class="lineno" id=line94></span>  <span class="comment">// G</span>
<span class="lineno" id=line95></span>  
<span class="lineno" id=line96></span>    cmp := <span class="fstring">"\geqslant"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line97></span>    arr := <span class="fstring">"\gets"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line98></span>    cmp := <span class="fstring">"\gg"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line99></span>    cmp := <span class="fstring">"\ggg"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line100></span>    cmp := <span class="fstring">"\gggtr"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line101></span>    cmp := <span class="fstring">"\gnapprox"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line102></span>    cmp := <span class="fstring">"\gnsim"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line103></span>    cmp := <span class="fstring">"\gtrapprox"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line104></span>    cmp := <span class="fstring">"\gtrdot"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line105></span>    cmp := <span class="fstring">"\gtreqless"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line106></span>    cmp := <span class="fstring">"\gtreqqless"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line107></span>    cmp := <span class="fstring">"\gtrless"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line108></span>    cmp := <span class="fstring">"\gtrsim"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line109></span>    cmp := <span class="fstring">"\gvertneqq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line110></span>  
<span class="lineno" id=line111></span>  <span class="comment">// H</span>
<span class="lineno" id=line112></span>  
<span class="lineno" id=line113></span>    arr := <span class="fstring">"\hookleftarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line114></span>    arr := <span class="fstring">"\hookrightarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line115></span>  
<span class="lineno" id=line116></span>  <span class="comment">// I</span>
<span class="lineno" id=line117></span>  
<span class="lineno" id=line118></span>  <span class="comment">// J</span>
<span class="lineno" id=line119></span>  
<span class="lineno" id=line120></span>    bin := <span class="fstring">"\Join"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line121></span>  
<span class="lineno" id=line122></span>  <span class="comment">// K</span>
<span class="lineno" id=line123></span>  
<span class="lineno" id=line124></span>  <span class="comment">// L</span>
<span class="lineno" id=line125></span>  
<span class="lineno" id=line126></span>    arr := <span class="fstring">"\leadsto"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line127></span>    arr := <span class="fstring">"\Leftarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line128></span>    arr := <span class="fstring">"\leftarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line129></span>    arr := <span class="fstring">"\leftarrowtail"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line130></span>    arr := <span class="fstring">"\leftharpoondown"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line131></span>    arr := <span class="fstring">"\leftharpoonup"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line132></span>    arr := <span class="fstring">"\leftleftarrows"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line133></span>    arr := <span class="fstring">"\Leftrightarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line134></span>    arr := <span class="fstring">"\leftrightarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line135></span>    cmp := <span class="fstring">"\leftrightarrows"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line136></span>    cmp := <span class="fstring">"\leftrightharpoons"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line137></span>    arr := <span class="fstring">"\leftrightsquigarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line138></span>    cmp := <span class="fstring">"\leqslant"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line139></span>    cmp := <span class="fstring">"\lessapprox"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line140></span>    cmp := <span class="fstring">"\lessdot"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line141></span>    cmp := <span class="fstring">"\lesseqgtr"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line142></span>    cmp := <span class="fstring">"\lesseqqgtr"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line143></span>    cmp := <span class="fstring">"\lessgtr"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line144></span>    cmp := <span class="fstring">"\lesssim"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line145></span>    arr := <span class="fstring">"\Lleftarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line146></span>    cmp := <span class="fstring">"\lll"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line147></span>    cmp := <span class="fstring">"\llless"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line148></span>    cmp := <span class="fstring">"\lnapprox"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line149></span>    cmp := <span class="fstring">"\lnot"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line150></span>    cmp := <span class="fstring">"\lnsim"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line151></span>    arr := <span class="fstring">"\Longleftarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line152></span>    arr := <span class="fstring">"\longleftarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line153></span>    arr := <span class="fstring">"\Longleftrightarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line154></span>    arr := <span class="fstring">"\longleftrightarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line155></span>    arr := <span class="fstring">"\longmapsto"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line156></span>    arr := <span class="fstring">"\Longrightarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line157></span>    arr := <span class="fstring">"\longrightarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line158></span>    cmp := <span class="fstring">"\ltimes"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line159></span>    cmp := <span class="fstring">"\lvertneqq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line160></span>  
<span class="lineno" id=line161></span>  <span class="comment">// M</span>
<span class="lineno" id=line162></span>  
<span class="lineno" id=line163></span>    arr := <span class="fstring">"\mapsto"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line164></span>  
<span class="lineno" id=line165></span>  <span class="comment">// N</span>
<span class="lineno" id=line166></span>  
<span class="lineno" id=line167></span>    cmp := <span class="fstring">"\ncong"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line168></span>    cmp := <span class="fstring">"\ngeqslant"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line169></span>    cmp := <span class="fstring">"\ni"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line170></span>    cmp := <span class="fstring">"\nleqslant"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line171></span>    cmp := <span class="fstring">"\nparallel"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line172></span>    cmp := <span class="fstring">"\nprec"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line173></span>    cmp := <span class="fstring">"\npreceq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line174></span>    cmp := <span class="fstring">"\nsim"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line175></span>    cmp := <span class="fstring">"\nsucc"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line176></span>    cmp := <span class="fstring">"\nsucceq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line177></span>    cmp := <span class="fstring">"\ntriangleleft"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line178></span>    cmp := <span class="fstring">"\ntrianglelefteq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line179></span>    cmp := <span class="fstring">"\ntriangleright"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line180></span>    cmp := <span class="fstring">"\ntrianglerighteq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line181></span>  
<span class="lineno" id=line182></span>  <span class="comment">// O</span>
<span class="lineno" id=line183></span>  
<span class="lineno" id=line184></span>    bin := <span class="fstring">"\odot"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line185></span>    bin := <span class="fstring">"\ominus"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line186></span>    bin := <span class="fstring">"\oplus"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line187></span>    bin := <span class="fstring">"\oslash"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line188></span>    <span class="comment">//bin := "\otimes" =&gt;# '(nos _1)'; </span>
<span class="lineno" id=line189></span>  
<span class="lineno" id=line190></span>  <span class="comment">// P</span>
<span class="lineno" id=line191></span>  
<span class="lineno" id=line192></span>    cmp := <span class="fstring">"\perp"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line193></span>    bin := <span class="fstring">"\pm"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line194></span>    cmp := <span class="fstring">"\prec"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line195></span>    cmp := <span class="fstring">"\precapprox"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line196></span>    cmp := <span class="fstring">"\preccurlyeq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line197></span>    cmp := <span class="fstring">"\preceq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line198></span>    cmp := <span class="fstring">"\precnapprox"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line199></span>    cmp := <span class="fstring">"\precneqq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line200></span>    cmp := <span class="fstring">"\precnsim"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line201></span>    cmp := <span class="fstring">"\precsim"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line202></span>    bin := <span class="fstring">"\prod"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line203></span>    cmp := <span class="fstring">"\propto"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line204></span>  
<span class="lineno" id=line205></span>  <span class="comment">// Q</span>
<span class="lineno" id=line206></span>  
<span class="lineno" id=line207></span>  <span class="comment">// R</span>
<span class="lineno" id=line208></span>  
<span class="lineno" id=line209></span>    cmp := <span class="fstring">"\rhd"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line210></span>    arr := <span class="fstring">"\Rightarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line211></span>    arr := <span class="fstring">"\rightarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line212></span>    arr := <span class="fstring">"\rightarrowtail"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line213></span>    arr := <span class="fstring">"\rightharpoondown"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line214></span>    arr := <span class="fstring">"\rightharpoonup"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line215></span>    arr := <span class="fstring">"\rightleftarrows"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line216></span>    arr := <span class="fstring">"\rightleftharpoons"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line217></span>    arr := <span class="fstring">"\rightleftharpoons"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line218></span>    arr := <span class="fstring">"\rightrightarrows"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line219></span>    arr := <span class="fstring">"\rightsquigarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line220></span>    arr := <span class="fstring">"\Rrightarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line221></span>    cmp := <span class="fstring">"\rtimes"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line222></span>  
<span class="lineno" id=line223></span>  <span class="comment">// S</span>
<span class="lineno" id=line224></span>  
<span class="lineno" id=line225></span>    bin := <span class="fstring">"\setminus"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line226></span>    cmp := <span class="fstring">"\sim"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line227></span>    cmp := <span class="fstring">"\simeq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line228></span>    cmp := <span class="fstring">"\smallsetminus"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line229></span>    bin := <span class="fstring">"\sqcap"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line230></span>    bin := <span class="fstring">"\sqcup"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line231></span>    cmp := <span class="fstring">"\sqsubset"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line232></span>    cmp := <span class="fstring">"\sqsubseteq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line233></span>    cmp := <span class="fstring">"\sqsupset"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line234></span>    cmp := <span class="fstring">"\sqsupseteq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line235></span>    bin := <span class="fstring">"\square"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line236></span>    cmp := <span class="fstring">"\Subset"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line237></span>    cmp := <span class="fstring">"\succ"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line238></span>    cmp := <span class="fstring">"\succapprox"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line239></span>    cmp := <span class="fstring">"\succcurlyeq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line240></span>    cmp := <span class="fstring">"\succeq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line241></span>    cmp := <span class="fstring">"\succnapprox"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line242></span>    cmp := <span class="fstring">"\succneqq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line243></span>    cmp := <span class="fstring">"\succnsim"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line244></span>    cmp := <span class="fstring">"\succsim"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line245></span>    cmp := <span class="fstring">"\Supset"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line246></span>  
<span class="lineno" id=line247></span>  <span class="comment">// T</span>
<span class="lineno" id=line248></span>  
<span class="lineno" id=line249></span>    cmp := <span class="fstring">"\thickapprox"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line250></span>    cmp := <span class="fstring">"\thicksim"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line251></span>    bin := <span class="fstring">"\times"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line252></span>    arr := <span class="fstring">"\to"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line253></span>    bin := <span class="fstring">"\triangle"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line254></span>    bin := <span class="fstring">"\triangledown"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line255></span>    cmp := <span class="fstring">"\triangleleft"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line256></span>    cmp := <span class="fstring">"\trianglelefteq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line257></span>    cmp := <span class="fstring">"\triangleq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line258></span>    cmp := <span class="fstring">"\triangleright"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line259></span>    cmp := <span class="fstring">"\trianglerighteq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line260></span>    arr := <span class="fstring">"\twoheadleftarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line261></span>    arr := <span class="fstring">"\twoheadrightarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line262></span>  
<span class="lineno" id=line263></span>  <span class="comment">// U</span>
<span class="lineno" id=line264></span>  
<span class="lineno" id=line265></span>    cmp := <span class="fstring">"\unlhd"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line266></span>    cmp := <span class="fstring">"\unrhd"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line267></span>    bin := <span class="fstring">"\Uparrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line268></span>    bin := <span class="fstring">"\uparrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line269></span>    bin := <span class="fstring">"\Updownarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line270></span>    bin := <span class="fstring">"\updownarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line271></span>    bin := <span class="fstring">"\upharpoonleft"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line272></span>    bin := <span class="fstring">"\upharpoonright"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line273></span>    bin := <span class="fstring">"\uplus"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line274></span>    bin := <span class="fstring">"\upuparrows"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line275></span>  
<span class="lineno" id=line276></span>  <span class="comment">// V</span>
<span class="lineno" id=line277></span>  
<span class="lineno" id=line278></span>    cmp := <span class="fstring">"\varsubsetneq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line279></span>    cmp := <span class="fstring">"\varsubsetneqq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line280></span>    cmp := <span class="fstring">"\varsupsetneq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line281></span>    cmp := <span class="fstring">"\varsupsetneqq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line282></span>    cmp := <span class="fstring">"\veebar"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line283></span>  
<span class="lineno" id=line284></span>  <span class="comment">// W</span>
<span class="lineno" id=line285></span>  
<span class="lineno" id=line286></span>  
<span class="lineno" id=line287></span>  <span class="comment">// X</span>
<span class="lineno" id=line288></span>  
<span class="lineno" id=line289></span>    arr := <span class="fstring">"\xleftarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line290></span>    arr := <span class="fstring">"\xrightarrow"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line291></span>  
<span class="lineno" id=line292></span>  <span class="comment">// Y</span>
<span class="lineno" id=line293></span>  
<span class="lineno" id=line294></span>  
<span class="lineno" id=line295></span>  <span class="comment">// Z</span>
<span class="lineno" id=line296></span>  
<span class="lineno" id=line297></span>  
<span class="lineno" id=line298></span>  
<span class="lineno" id=line299></span>  <span class="comment">// The precedences here are a hack: so many operators.</span>
<span class="lineno" id=line300></span>  <span class="comment">// The general effect is: except for keyword logic connectives,</span>
<span class="lineno" id=line301></span>  <span class="comment">// these operations are all done AFTER any ASCII art ops</span>
<span class="lineno" id=line302></span>  <span class="comment">// and, only one is allowed per sub-expression: you must use parens</span>
<span class="lineno" id=line303></span>  <span class="comment">// if you use more than one. We'll fix this for some key operations later,</span>
<span class="lineno" id=line304></span>  <span class="comment">// particularly the setwise and logic connectors. However, the comparisons</span>
<span class="lineno" id=line305></span>  <span class="comment">// are at the right precedence.</span>
<span class="lineno" id=line306></span>  <span class="comment">// (fact is, I don't know what half the operators are for anyhow .. )</span>
<span class="lineno" id=line307></span>  
<span class="lineno" id=line308></span>    x[stuple_pri] := x[&gt;stuple_pri] <span class="fstring">"\brace"</span> x[&gt;stuple_pri] =&gt;# <span class="fstring">"(Infix)"</span>;
<span class="lineno" id=line309></span>    x[stuple_pri] := x[&gt;stuple_pri] <span class="fstring">"\brack"</span> x[&gt;stuple_pri] =&gt;# <span class="fstring">"(Infix)"</span>;
<span class="lineno" id=line310></span>  
<span class="lineno" id=line311></span>  
<span class="lineno" id=line312></span>    x[scomparison_pri]:= x[&gt;scomparison_pri] bin x[&gt;scomparison_pri] =&gt;# 
<span class="lineno" id=line313></span>      <span class="fstring">"(binop _2 _1 _3)"</span>;
<span class="lineno" id=line314></span>  
<span class="lineno" id=line315></span>    <span class="comment">// set ops (note: no setminus, its a standard binop at the moment ;)</span>
<span class="lineno" id=line316></span>    <span class="comment">// note: no \Cap or other variants .. would interfere with chain </span>
<span class="lineno" id=line317></span>    <span class="comment">// there's no reason at all to chain these anyhow, they're standard left assoc operators </span>
<span class="lineno" id=line318></span>  
<span class="lineno" id=line319></span>    <span class="comment">// All arrows are right associative .. hmm ..</span>
<span class="lineno" id=line320></span>    x[sarrow_pri] := x[scase_literal_pri] arr x[sarrow_pri] =&gt;# 
<span class="lineno" id=line321></span>      <span class="fstring">"(binop _2 _1 _3)"</span>;
<span class="lineno" id=line322></span>  }
<span class="lineno" id=line323></span>  
</pre></p></div><h2 id='Type_definitions_h'><img src='/share/src/web/images/minus.gif' id='Type definitions' onclick='toggle(this,"Type_definitions_d")' alt='+'/> 2.25 Type definitions</h2><div id='Type_definitions_d' style='display:block'>
<pre class='inclusion'>
share/lib/grammar/type_decls.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">Stuff for defining types.</span>
<span class="lineno" id=line2></span>  <span class="doccomment">//$ Felix type expressions use the same syntax as value expressions.</span>
<span class="lineno" id=line3></span>  
<span class="lineno" id=line4></span>    <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line5></span>      (define (makecstruct type members reqs) 
<span class="lineno" id=line6></span>        (begin ;;(display "makecstruct ")(display type)(display "\n")
<span class="lineno" id=line7></span>        (let* 
<span class="lineno" id=line8></span>         (
<span class="lineno" id=line9></span>           (vals (filter_first 'Pval members))
<span class="lineno" id=line10></span>           (funs (filter_first 'Pfun members))
<span class="lineno" id=line11></span>           (struct-name (first type))
<span class="lineno" id=line12></span>           (struct-polyspec (second type))
<span class="lineno" id=line13></span>           (struct-polyvars (first struct-polyspec))
<span class="lineno" id=line14></span>           (struct-pvids (map first struct-polyvars))
<span class="lineno" id=line15></span>           (struct-pvs (map nos struct-pvids))
<span class="lineno" id=line16></span>           (struct-polyaux (second struct-polyspec))
<span class="lineno" id=line17></span>           (struct `(ast_cstruct ,_sr ,struct-name ,struct-polyspec ,vals ,reqs))
<span class="lineno" id=line18></span>           (mfuns (map (lambda (x) 
<span class="lineno" id=line19></span>             (let* 
<span class="lineno" id=line20></span>               (
<span class="lineno" id=line21></span>                 (lst (first x))
<span class="lineno" id=line22></span>                 (t0 (list-ref lst 0)) ; ast_curry
<span class="lineno" id=line23></span>                 (t1 (list-ref lst 1)) ; sr
<span class="lineno" id=line24></span>                 (t2 (list-ref lst 2)) ; name
<span class="lineno" id=line25></span>                 (polyspec (list-ref lst 3)) ; polyvars
<span class="lineno" id=line26></span>                 (t4 (list-ref lst 4)) ; args
<span class="lineno" id=line27></span>                 (t5 (list-ref lst 5)) ; return type
<span class="lineno" id=line28></span>                 (t6 (list-ref lst 6)) ; fun kind
<span class="lineno" id=line29></span>                 (t7 (list-ref lst 7)) ; adjective properties
<span class="lineno" id=line30></span>                 (t8 (list-ref lst 8)) ; body
<span class="lineno" id=line31></span>                 (polyvars (first polyspec))
<span class="lineno" id=line32></span>                 (polyaux (second polyspec))
<span class="lineno" id=line33></span>                 (outpolyvars `(,(append struct-polyvars polyvars) ,polyaux))
<span class="lineno" id=line34></span>                 (kind (if (isvoid? (first t5)) 'PRef 'PVal))
<span class="lineno" id=line35></span>                 (self-name 'self)
<span class="lineno" id=line36></span>                 (self-type `(ast_name ,_sr ,struct-name (texprs ,struct-pvs)))
<span class="lineno" id=line37></span>                 (self-arg `(,kind ,self-name ,self-type none)) 
<span class="lineno" id=line38></span>                 (self-args `((,self-arg) none))
<span class="lineno" id=line39></span>                 (args (cons self-args t4))
<span class="lineno" id=line40></span>               ) 
<span class="lineno" id=line41></span>               `(,t0 ,t1 ,t2 ,outpolyvars ,args, t5 ,t6 ,t7 ,t8)
<span class="lineno" id=line42></span>             )) funs)
<span class="lineno" id=line43></span>           )
<span class="lineno" id=line44></span>           
<span class="lineno" id=line45></span>           (sts (cons struct mfuns))
<span class="lineno" id=line46></span>         )
<span class="lineno" id=line47></span>         `(ast_seq ,_sr ,sts)
<span class="lineno" id=line48></span>        ))
<span class="lineno" id=line49></span>      )
<span class="lineno" id=line50></span>    """</span>;
<span class="lineno" id=line51></span>  
<span class="lineno" id=line52></span>    <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line53></span>    (define (asserteq a b code)
<span class="lineno" id=line54></span>      (if (equal? a b) 
<span class="lineno" id=line55></span>        code
<span class="lineno" id=line56></span>        (begin 
<span class="lineno" id=line57></span>          (display "struct tag ")(display a)(display " and typedef name ")
<span class="lineno" id=line58></span>          (display b)(display " must be equal\n")
<span class="lineno" id=line59></span>          (raise "typedef-struct-error") 
<span class="lineno" id=line60></span>        )
<span class="lineno" id=line61></span>      )
<span class="lineno" id=line62></span>    )
<span class="lineno" id=line63></span>    """</span>;
<span class="lineno" id=line64></span>  
<span class="lineno" id=line65></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line66></span>  (
<span class="lineno" id=line67></span>    define (make_struct_fun struct-name struct-polyvars struct-pvs x) 
<span class="lineno" id=line68></span>     (let* 
<span class="lineno" id=line69></span>       (
<span class="lineno" id=line70></span>         (lst (first x))
<span class="lineno" id=line71></span>         (t0 (list-ref lst 0)) ; ast_curry_effects
<span class="lineno" id=line72></span>         (t1 (list-ref lst 1)) ; sr
<span class="lineno" id=line73></span>         (t2 (list-ref lst 2)) ; name
<span class="lineno" id=line74></span>         ;;(dummy (begin (display "t2=")(display t2)(display "\n")))
<span class="lineno" id=line75></span>         (polyspec (list-ref lst 3)) ; polyvars
<span class="lineno" id=line76></span>         (t4 (list-ref lst 4)) ; args
<span class="lineno" id=line77></span>         (t5 (list-ref lst 5)) ; return type, constraint
<span class="lineno" id=line78></span>         ;;(dummy (begin (display "t5=")(display t5)(display "\n")))
<span class="lineno" id=line79></span>         (t6 (list-ref lst 6)) ; effects
<span class="lineno" id=line80></span>         (t7 (list-ref lst 7)) ; fun kind
<span class="lineno" id=line81></span>         (t8 (list-ref lst 8)) ; adjective properties
<span class="lineno" id=line82></span>         (t9 (list-ref lst 9)) ; body
<span class="lineno" id=line83></span>         (polyvars (first polyspec))
<span class="lineno" id=line84></span>         (polyaux (second polyspec))
<span class="lineno" id=line85></span>         (outpolyvars `(,(append struct-polyvars polyvars) ,polyaux))
<span class="lineno" id=line86></span>         (self-name 'self)
<span class="lineno" id=line87></span>         (self-type 
<span class="lineno" id=line88></span>           (if (isvoid? (first t5))
<span class="lineno" id=line89></span>             (begin ;; (display "procedure\n") 
<span class="lineno" id=line90></span>               `(typ_ref ,_sr (ast_name ,_sr ,struct-name (texprs ,struct-pvs)))
<span class="lineno" id=line91></span>             )
<span class="lineno" id=line92></span>             (begin ;; (display "function\n")
<span class="lineno" id=line93></span>               `(ast_name ,_sr ,struct-name (texprs ,struct-pvs))
<span class="lineno" id=line94></span>             )
<span class="lineno" id=line95></span>           )
<span class="lineno" id=line96></span>         )
<span class="lineno" id=line97></span>         (self-arg `(,_sr PVal ,self-name ,self-type none)) 
<span class="lineno" id=line98></span>         (self-args `((Satom ,self-arg) none))
<span class="lineno" id=line99></span>         (args (cons self-args t4))
<span class="lineno" id=line100></span>       ) 
<span class="lineno" id=line101></span>       `(,t0 ,t1 ,t2 ,outpolyvars ,args ,t5 ,t6 ,t7 ,t8 ,t9)
<span class="lineno" id=line102></span>    )
<span class="lineno" id=line103></span>  )
<span class="lineno" id=line104></span>  """</span>;
<span class="lineno" id=line105></span>  
<span class="lineno" id=line106></span>  
<span class="lineno" id=line107></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> type_decls {
<span class="lineno" id=line108></span>    <span class="big_keyword" title="specify requirements">requires</span> statements;
<span class="lineno" id=line109></span>  
<span class="lineno" id=line110></span>    tatom := stypematch =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line111></span>    satom := stypecasematch =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line112></span>  
<span class="lineno" id=line113></span>    <span class="doccomment">Typedef creates an alias for a type.</span>
<span class="lineno" id=line114></span>    stmt := <span class="fstring">"typedef"</span> sdeclname <span class="fstring">"="</span> stype <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line115></span>      <span class="fstring">"""
<span class="lineno" id=line116></span>      `(ast_type_alias ,_sr ,(first _2) ,(second _2) ,_4)
<span class="lineno" id=line117></span>      """</span>;
<span class="lineno" id=line118></span>  
<span class="lineno" id=line119></span>  
<span class="lineno" id=line120></span>    skvar := sname =&gt;# <span class="fstring">"""`(,_1 (ast_name ,_sr "KIND" ()))"""</span>; 
<span class="lineno" id=line121></span>    skvar_comma_list := skvar (<span class="fstring">","</span> skvar)* =&gt;# <span class="fstring">"(cons _1 (map second _2))"</span>;
<span class="lineno" id=line122></span>    skvar_comma_list := sepsilon =&gt;# <span class="fstring">"'()"</span>;
<span class="lineno" id=line123></span>    skvarlist := sepsilon =&gt;# <span class="fstring">"'()"</span>;
<span class="lineno" id=line124></span>    skvarlist := <span class="fstring">"&lt;"</span> skvar_comma_list <span class="fstring">"&gt;"</span>=&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line125></span>    skf_declname := sname skvarlist =&gt;# <span class="fstring">"`(,_1 ,_2)"</span>;
<span class="lineno" id=line126></span>  
<span class="lineno" id=line127></span>  
<span class="lineno" id=line128></span>    <span class="doccomment">Typedef fun create a type function or functor.</span>
<span class="lineno" id=line129></span>    <span class="doccomment">It maps some types to another type.</span>
<span class="lineno" id=line130></span>    <span class="doccomment">This is the simple expression form.</span>
<span class="lineno" id=line131></span>    stmt := <span class="fstring">"typefun"</span> skf_declname stypefun_args <span class="fstring">":"</span> skindexpr <span class="fstring">"=&gt;"</span> stype <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line132></span>      <span class="fstring">"""
<span class="lineno" id=line133></span>      `(mktypefun ,_sr ,(first _2) ,(second _2) ,_3 ,_5 ,_7)
<span class="lineno" id=line134></span>      """</span>;
<span class="lineno" id=line135></span>  
<span class="lineno" id=line136></span>    <span class="doccomment">Typedef fun create a type function or functor.</span>
<span class="lineno" id=line137></span>    <span class="doccomment">It maps some types to another type.</span>
<span class="lineno" id=line138></span>    <span class="doccomment">This is the simple matching form.</span>
<span class="lineno" id=line139></span>    stmt := <span class="fstring">"typefun"</span> skf_sdeclname <span class="fstring">":"</span> skindexpr <span class="fstring">"="</span> stype_matching+ <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line140></span>      <span class="fstring">"""
<span class="lineno" id=line141></span>      (if (eq? 'typ_arrow (first _4))
<span class="lineno" id=line142></span>        (let (
<span class="lineno" id=line143></span>          (argt (caadr _4))
<span class="lineno" id=line144></span>          (ret (cadadr _4))
<span class="lineno" id=line145></span>          (body `(ast_type_match ,_sr (,(noi '_a) ,_6))))
<span class="lineno" id=line146></span>          (let ((args `(((_a ,argt)))))
<span class="lineno" id=line147></span>        `(mktypefun ,_sr ,(first _2) ,(second _2) ,args ,ret ,body)
<span class="lineno" id=line148></span>        ))
<span class="lineno" id=line149></span>        ('ERROR)
<span class="lineno" id=line150></span>      )
<span class="lineno" id=line151></span>      """</span>;
<span class="lineno" id=line152></span>  
<span class="lineno" id=line153></span>    stypecasematch := <span class="fstring">"typecase"</span> stype <span class="fstring">"with"</span> stypecase_matching+ <span class="fstring">"endmatch"</span> =&gt;#
<span class="lineno" id=line154></span>      <span class="fstring">"`(ast_typecase_match ,_sr (,_2 ,_4))"</span>;
<span class="lineno" id=line155></span>    stypecase_matching := <span class="fstring">"|"</span> stype <span class="fstring">"=&gt;"</span> sexpr =&gt;# <span class="fstring">"`(,_2 ,_4)"</span>;
<span class="lineno" id=line156></span>  
<span class="lineno" id=line157></span>    <span class="doccomment">A struct is a nominally type product type similar to a C struct.</span>
<span class="lineno" id=line158></span>    <span class="doccomment">A struct may be polymorphic.  Felix generates a constructor for</span>
<span class="lineno" id=line159></span>    <span class="doccomment">the struct from a tuple of the types of the fields of te struct,</span>
<span class="lineno" id=line160></span>    <span class="doccomment">in the order they're written.</span>
<span class="lineno" id=line161></span>    <span class="doccomment">  //$ The syntax allows functions and procedures to be included in a struct, </span>
<span class="lineno" id=line162></span>    <span class="doccomment">however these are not non-static members. </span>
<span class="lineno" id=line163></span>    <span class="doccomment">Rather they global functions with an additional</span>
<span class="lineno" id=line164></span>    <span class="doccomment">argument prefixed of the struct type (for a fun) or pointer</span>
<span class="lineno" id=line165></span>    <span class="doccomment">to the struct type (for a proc). In such functinos the special</span>
<span class="lineno" id=line166></span>    <span class="doccomment">identifier "self" must be used to refer to the struct.</span>
<span class="lineno" id=line167></span>    <span class="doccomment">For example:</span>
<span class="lineno" id=line168></span>    <span class="doccomment">  //$ struct X { </span>
<span class="lineno" id=line169></span>    <span class="doccomment">  a : int;</span>
<span class="lineno" id=line170></span>    <span class="doccomment">  fun f(b: int) =&gt; self.a + b;</span>
<span class="lineno" id=line171></span>    <span class="doccomment">}</span>
<span class="lineno" id=line172></span>    <span class="doccomment">println$ X 1 . f 2;</span>
<span class="lineno" id=line173></span>    <span class="doccomment">// f is equivalent to</span>
<span class="lineno" id=line174></span>    <span class="doccomment">fun f (self:X) (b:int) =&gt; self.a + b;</span>
<span class="lineno" id=line175></span>    <span class="doccomment"></span>
<span class="lineno" id=line176></span>    sexport := <span class="fstring">"export"</span> =&gt;# <span class="fstring">"'export"</span>;
<span class="lineno" id=line177></span>    sexport := sepsilon =&gt;# <span class="fstring">"'noexport"</span>;
<span class="lineno" id=line178></span>    stmt := sexport <span class="fstring">"struct"</span> sdeclname <span class="fstring">"="</span> ? <span class="fstring">"{"</span> sstruct_mem_decl * <span class="fstring">"}"</span> =&gt;#
<span class="lineno" id=line179></span>      <span class="fstring">"""
<span class="lineno" id=line180></span>       (let* 
<span class="lineno" id=line181></span>         (
<span class="lineno" id=line182></span>           (export_clause _1)
<span class="lineno" id=line183></span>           (decl_name _3)
<span class="lineno" id=line184></span>           (body _6)
<span class="lineno" id=line185></span>           (vals (filter_first 'Pval body))
<span class="lineno" id=line186></span>           (funs (filter_first 'Pfun body))
<span class="lineno" id=line187></span>           (struct-name (first decl_name))
<span class="lineno" id=line188></span>           (struct-polyspec (second decl_name))
<span class="lineno" id=line189></span>           (struct-polyvars (first struct-polyspec))
<span class="lineno" id=line190></span>           (struct-pvids (map first struct-polyvars))
<span class="lineno" id=line191></span>           (struct-pvs (map nos struct-pvids))
<span class="lineno" id=line192></span>           (struct-polyaux (second struct-polyspec))
<span class="lineno" id=line193></span>           (struct `(ast_struct ,_sr ,struct-name ,struct-polyspec ,vals))
<span class="lineno" id=line194></span>           (mfuns (map (lambda (x)(make_struct_fun struct-name struct-polyvars struct-pvs x)) funs))
<span class="lineno" id=line195></span>           (sts (cons struct mfuns))
<span class="lineno" id=line196></span>           (sts 
<span class="lineno" id=line197></span>             (if 
<span class="lineno" id=line198></span>               (equal? export_clause 'export) 
<span class="lineno" id=line199></span>               (cons `(ast_export_struct ,_sr ,struct-name) sts)
<span class="lineno" id=line200></span>               sts
<span class="lineno" id=line201></span>             )
<span class="lineno" id=line202></span>           )
<span class="lineno" id=line203></span>         )
<span class="lineno" id=line204></span>         `(ast_seq ,_sr ,sts)
<span class="lineno" id=line205></span>       )
<span class="lineno" id=line206></span>       """</span>;
<span class="lineno" id=line207></span>      sstruct_mem_decl := stypeexpr sname <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(Pval ,_2 ,_1)"</span>; <span class="comment">// like C: int x;!</span>
<span class="lineno" id=line208></span>      sstruct_mem_decl := sname <span class="fstring">":"</span> stypeexpr <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(Pval ,_1 ,_3)"</span>;
<span class="lineno" id=line209></span>      sstruct_mem_decl := sfunction  =&gt;# <span class="fstring">"""
<span class="lineno" id=line210></span>       (let 
<span class="lineno" id=line211></span>         (
<span class="lineno" id=line212></span>           (curry_kind (first _1))
<span class="lineno" id=line213></span>         )
<span class="lineno" id=line214></span>         (if 
<span class="lineno" id=line215></span>           (equal? curry_kind 'ast_curry_effects)
<span class="lineno" id=line216></span>           `(Pfun ,_1)
<span class="lineno" id=line217></span>           (let*
<span class="lineno" id=line218></span>             (
<span class="lineno" id=line219></span>               (lst _1)
<span class="lineno" id=line220></span>               (t1 (list-ref lst 1)) ; sr
<span class="lineno" id=line221></span>               (t2 (list-ref lst 2)) ; name
<span class="lineno" id=line222></span>               (t3 (list-ref lst 3)) ; vs
<span class="lineno" id=line223></span>               (t4 (list-ref lst 4)) ; args
<span class="lineno" id=line224></span>               (t5 (list-ref lst 5)) ; return type, constraint
<span class="lineno" id=line225></span>               (t6 (list-ref lst 6)) ; fun kind
<span class="lineno" id=line226></span>               (t7 (list-ref lst 7)) ; adjective properties
<span class="lineno" id=line227></span>               (t8 (list-ref lst 8)) ; body
<span class="lineno" id=line228></span>             )
<span class="lineno" id=line229></span>            `(Pfun (ast_curry_effects ,t1 ,t2 ,t3 ,t4 ,t5 ,dflteffects ,t6 ,t7 ,t8))
<span class="lineno" id=line230></span>           )
<span class="lineno" id=line231></span>         )
<span class="lineno" id=line232></span>       )
<span class="lineno" id=line233></span>       """</span>;
<span class="lineno" id=line234></span>  
<span class="lineno" id=line235></span>    <span class="doccomment">A ctruct provides a model of a C structure.</span>
<span class="lineno" id=line236></span>    <span class="doccomment">This is the same as a struct except the structure is not emitted.</span>
<span class="lineno" id=line237></span>    <span class="doccomment">Instead, it is assumed to be already defined in C.</span>
<span class="lineno" id=line238></span>    <span class="doccomment">  //$ CAVEAT: A C struct constructor should not be used</span>
<span class="lineno" id=line239></span>    <span class="doccomment">unless the cstruct definition is a complete model of the C struct.</span>
<span class="lineno" id=line240></span>  
<span class="lineno" id=line241></span>    stmt := <span class="fstring">"cstruct"</span> sdeclname <span class="fstring">"="</span> ? <span class="fstring">"{"</span> sstruct_mem_decl * <span class="fstring">"}"</span> srequires_clause <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line242></span>      <span class="fstring">"(makecstruct _2 _5 _7)"</span>
<span class="lineno" id=line243></span>    ;
<span class="lineno" id=line244></span>  
<span class="lineno" id=line245></span>    <span class="doccomment">A hack to help with cut and paste from C headers into Felix</span>
<span class="lineno" id=line246></span>    stmt := <span class="fstring">"typedef"</span> <span class="fstring">"struct"</span> <span class="fstring">"{"</span> sstruct_mem_decl * <span class="fstring">"}"</span> sdeclname srequires_clause <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line247></span>      <span class="fstring">"(makecstruct _6 _4 _7)"</span>
<span class="lineno" id=line248></span>    ;
<span class="lineno" id=line249></span>  
<span class="lineno" id=line250></span>    <span class="doccomment">A hack to help with cut and paste from C headers into Felix</span>
<span class="lineno" id=line251></span>    stmt := <span class="fstring">"typedef"</span> <span class="fstring">"struct"</span> sdeclname <span class="fstring">"{"</span> sstruct_mem_decl * <span class="fstring">"}"</span> sdeclname srequires_clause <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line252></span>      <span class="fstring">"(asserteq (first _3)(first _7) (makecstruct _7 _5 _8))"</span>
<span class="lineno" id=line253></span>    ;
<span class="lineno" id=line254></span>  
<span class="lineno" id=line255></span>    sopt_name := sname =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line256></span>    sopt_name := sepsilon =&gt;# <span class="fstring">'""'</span>;
<span class="lineno" id=line257></span>  
<span class="lineno" id=line258></span>    <span class="doccomment">A union is a model of a discriminated union or variant.</span>
<span class="lineno" id=line259></span>    <span class="doccomment">Such unions have a discriminant tag that determines</span>
<span class="lineno" id=line260></span>    <span class="doccomment">at run time which component is populated.</span>
<span class="lineno" id=line261></span>    <span class="doccomment">The only way to access the union field is by using a</span>
<span class="lineno" id=line262></span>    <span class="doccomment">match which automatically enforces proper access.</span>
<span class="lineno" id=line263></span>    <span class="doccomment">  //$ The fields of a union are called type constructors.</span>
<span class="lineno" id=line264></span>    <span class="doccomment">A constant type constructor has no arguments.</span>
<span class="lineno" id=line265></span>    <span class="doccomment">A non-constant type constructor has an argument</span>
<span class="lineno" id=line266></span>    <span class="doccomment">which can be extracted in a match.</span>
<span class="lineno" id=line267></span>    <span class="doccomment"></span>
<span class="lineno" id=line268></span>    <span class="doccomment">Unions provide a safe way to "unify" heterogenous data</span>
<span class="lineno" id=line269></span>    <span class="doccomment">into a single data type.</span>
<span class="lineno" id=line270></span>  
<span class="lineno" id=line271></span>    <span class="comment">// shared by both union decl forms..</span>
<span class="lineno" id=line272></span>      stype_sum_item := sname sopt_value stvarlist <span class="fstring">"of"</span> stypeexpr =&gt;# <span class="fstring">"`(,_1 ,_2 ,_3 ,_5)"</span>;
<span class="lineno" id=line273></span>      stype_sum_item := sname sopt_value stvarlist <span class="fstring">"of"</span> stypeexpr <span class="fstring">"=&gt;"</span> sexpr =&gt;# <span class="fstring">"`(,_1 ,_2 ,_3 ,_5 ,_7)"</span>;
<span class="lineno" id=line274></span>      stype_sum_item := sname sopt_value stvarlist =&gt;# <span class="fstring">"`(,_1 ,_2 ,_3 (ast_void ,_sr))"</span>;
<span class="lineno" id=line275></span>      stype_sum_item := <span class="fstring">"#"</span> sname sopt_value stvarlist =&gt;# <span class="fstring">"`(,_2 ,_3 ,_4 (ast_void ,_sr))"</span>;
<span class="lineno" id=line276></span>  
<span class="lineno" id=line277></span>      stype_sum_item_bar := <span class="fstring">"|"</span> stype_sum_item =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line278></span>      stype_sum_items := stype_sum_item stype_sum_item_bar* =&gt;# <span class="fstring">"(cons _1 _2)"</span>;
<span class="lineno" id=line279></span>      stype_sum_items := stype_sum_item_bar* =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line280></span>  
<span class="lineno" id=line281></span>   <span class="comment">// deviant form using trailing ";" per item used inside { } unions</span>
<span class="lineno" id=line282></span>      stype_sum_item1 := stype_sum_item <span class="fstring">";"</span> =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line283></span>  
<span class="lineno" id=line284></span>    suexport := <span class="fstring">"export"</span> =&gt;# <span class="fstring">"'export"</span>;
<span class="lineno" id=line285></span>    suexport := sepsilon =&gt;# <span class="fstring">"'noexport"</span>;
<span class="lineno" id=line286></span>    suexport := <span class="fstring">"export"</span> sstring =&gt;# <span class="fstring">"`(namedexport ,_2)"</span>;
<span class="lineno" id=line287></span>    stmt := suexport <span class="fstring">"variant"</span> sdeclname <span class="fstring">"="</span> stype_sum_items <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line288></span>      <span class="fstring">"""
<span class="lineno" id=line289></span>      (let*
<span class="lineno" id=line290></span>        ( 
<span class="lineno" id=line291></span>          (union-name (first _3))
<span class="lineno" id=line292></span>          (sts (list `(ast_union ,_sr ,union-name ,(second _3) ,_5)))
<span class="lineno" id=line293></span>          (sts 
<span class="lineno" id=line294></span>            (if 
<span class="lineno" id=line295></span>              (equal? _1 'export) 
<span class="lineno" id=line296></span>              (cons `(ast_export_union ,_sr ,(nos union-name) ,union-name) sts)
<span class="lineno" id=line297></span>              (if
<span class="lineno" id=line298></span>                (equal? _1 'noexport) 
<span class="lineno" id=line299></span>                 sts
<span class="lineno" id=line300></span>                (cons `(ast_export_union ,_sr ,(nos union-name) ,(second _1)) sts)
<span class="lineno" id=line301></span>              )
<span class="lineno" id=line302></span>            )
<span class="lineno" id=line303></span>          )
<span class="lineno" id=line304></span>        )
<span class="lineno" id=line305></span>        `(ast_seq ,_sr ,sts)
<span class="lineno" id=line306></span>      )
<span class="lineno" id=line307></span>      """</span>;
<span class="lineno" id=line308></span>  
<span class="lineno" id=line309></span>    <span class="doccomment">Deprecated C like syntax for unionx.</span>
<span class="lineno" id=line310></span>    stmt := <span class="fstring">"variant"</span> sdeclname <span class="fstring">"{"</span> stype_sum_item1* <span class="fstring">"}"</span> =&gt;#
<span class="lineno" id=line311></span>      <span class="fstring">"""
<span class="lineno" id=line312></span>      `(ast_union ,_sr ,(first _2) ,(second _2) ,_4)
<span class="lineno" id=line313></span>       """</span>;
<span class="lineno" id=line314></span>  
<span class="lineno" id=line315></span>  
<span class="lineno" id=line316></span>    stmt := senum_decl =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line317></span>  
<span class="lineno" id=line318></span>    <span class="doccomment">Short for for declaring an enumeration,</span>
<span class="lineno" id=line319></span>    <span class="doccomment">which is a union all of whose fields are constant constructors.</span>
<span class="lineno" id=line320></span>    <span class="doccomment">Deprecated syntax.</span>
<span class="lineno" id=line321></span>    stmt := <span class="fstring">"enum"</span> sdeclname <span class="fstring">"{"</span> senum_items <span class="fstring">"}"</span> =&gt;#
<span class="lineno" id=line322></span>      <span class="fstring">"""
<span class="lineno" id=line323></span>      `(ast_union ,_sr ,(first _2) ,(second _2) ,_4)
<span class="lineno" id=line324></span>       """</span>;
<span class="lineno" id=line325></span>  
<span class="lineno" id=line326></span>    <span class="doccomment">Short for for declaring an enumeration,</span>
<span class="lineno" id=line327></span>    <span class="doccomment">which is a union all of whose fields are constant constructors.</span>
<span class="lineno" id=line328></span>    stmt := <span class="fstring">"enum"</span> sdeclname <span class="fstring">"="</span> senum_items <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line329></span>      <span class="fstring">"""
<span class="lineno" id=line330></span>      `(ast_union ,_sr ,(first _2) ,(second _2) ,_4)
<span class="lineno" id=line331></span>       """</span>;
<span class="lineno" id=line332></span>  
<span class="lineno" id=line333></span>    sopt_value := <span class="fstring">"="</span> sinteger =&gt;# <span class="fstring">"`(some ,_2)"</span>;
<span class="lineno" id=line334></span>    sopt_value := sepsilon =&gt;# <span class="fstring">"'none"</span>;
<span class="lineno" id=line335></span>    senum_item := sname sopt_value =&gt;# <span class="fstring">"`(,_1 ,_2 ,dfltvs (ast_void ,_sr))"</span>;
<span class="lineno" id=line336></span>    senum_items := senum_item <span class="fstring">","</span> senum_items =&gt;# <span class="fstring">"(cons _1 _3)"</span>;
<span class="lineno" id=line337></span>    senum_items := senum_item =&gt;# <span class="fstring">"`(,_1)"</span>;
<span class="lineno" id=line338></span>    senum_items := sepsilon =&gt;# <span class="fstring">"()"</span>;
<span class="lineno" id=line339></span>  
<span class="lineno" id=line340></span>  <span class="comment">/*
<span class="lineno" id=line341></span>    //$ Java like interface of an object type.
<span class="lineno" id=line342></span>    //$ Equivalent to a record type.
<span class="lineno" id=line343></span>    stmt := "interface" sdeclname "{" srecord_type "}" =&gt;#
<span class="lineno" id=line344></span>      """
<span class="lineno" id=line345></span>      `(ast_type_alias ,_sr ,(first _2) ,(second _2) ,_4)
<span class="lineno" id=line346></span>      """;
<span class="lineno" id=line347></span>  */</span>
<span class="lineno" id=line348></span>  
<span class="lineno" id=line349></span>    <span class="doccomment">Java like interface of an object type.</span>
<span class="lineno" id=line350></span>    <span class="doccomment">Equivalent to a record type.</span>
<span class="lineno" id=line351></span>    stmt := <span class="fstring">"interface"</span> sdeclname stype_extension <span class="fstring">"{"</span> srecord_type <span class="fstring">"}"</span> =&gt;#
<span class="lineno" id=line352></span>      <span class="fstring">"""
<span class="lineno" id=line353></span>      `(ast_type_alias ,_sr ,(first _2) ,(second _2) (typ_type_extension ,_sr ,_3 ,_5))
<span class="lineno" id=line354></span>      """</span>;
<span class="lineno" id=line355></span>  
<span class="lineno" id=line356></span>      srecord_type := srecord_mem_decl (<span class="fstring">";"</span> srecord_mem_decl)* <span class="fstring">";"</span> =&gt;# 
<span class="lineno" id=line357></span>       <span class="fstring">"`(ast_record_type ,(cons _1 (map second _2)))"</span>;
<span class="lineno" id=line358></span>      stype_extension := <span class="fstring">"extends"</span> stypeexpr_comma_list =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line359></span>      stype_extension := sepsilon =&gt;# <span class="fstring">"()"</span>;
<span class="lineno" id=line360></span>  }
<span class="lineno" id=line361></span>  
</pre></p></div><h2 id='Utility_nonterminals._h'><img src='/share/src/web/images/minus.gif' id='Utility nonterminals.' onclick='toggle(this,"Utility_nonterminals._d")' alt='+'/> 2.26 Utility nonterminals.</h2><div id='Utility_nonterminals._d' style='display:block'>
<pre class='inclusion'>
share/lib/grammar/utility.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="comment">// Utility macros</span>
<span class="lineno" id=line2></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> <span class="library" title="functional, singly linked list">list</span> 
<span class="lineno" id=line3></span>  {
<span class="lineno" id=line4></span>    seplist1 sep a := a (sep a)* =&gt;# <span class="fstring">'(cons _1 (map second _2))'</span>; 
<span class="lineno" id=line5></span>    seplist0 sep a = seplist1&lt;sep&gt;&lt;a&gt;;
<span class="lineno" id=line6></span>    seplist0 sep a := sepsilon =&gt;# <span class="fstring">'()'</span>;
<span class="lineno" id=line7></span>    commalist1 a = seplist1&lt;<span class="fstring">","</span>&gt;&lt;a&gt;;
<span class="lineno" id=line8></span>    commalist0 a = seplist0&lt;<span class="fstring">","</span>&gt;&lt;a&gt;;
<span class="lineno" id=line9></span>  
<span class="lineno" id=line10></span>    snames = commalist1&lt;sname&gt;;
<span class="lineno" id=line11></span>    sdeclnames = commalist1&lt;sdeclname&gt;;
<span class="lineno" id=line12></span>  }
</pre></p></div><h2 id='Variable_definitions._h'><img src='/share/src/web/images/minus.gif' id='Variable definitions.' onclick='toggle(this,"Variable_definitions._d")' alt='+'/> 2.27 Variable definitions.</h2><div id='Variable_definitions._d' style='display:block'>
<pre class='inclusion'>
share/lib/grammar/variables.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">General variable binders.</span>
<span class="lineno" id=line2></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> variables {
<span class="lineno" id=line3></span>    <span class="big_keyword" title="specify requirements">requires</span> statements, executable;
<span class="lineno" id=line4></span>  
<span class="lineno" id=line5></span>    <span class="doccomment">Value binder: multi declaration. Like:</span>
<span class="lineno" id=line6></span>    <span class="doccomment"></span>
<span class="lineno" id=line7></span>    <span class="doccomment">val x,y,z = 1,2,3;</span>
<span class="lineno" id=line8></span>    <span class="doccomment">  stmt := "val" sname sname_suffix "=" sexpr ";" =&gt;#</span>
<span class="lineno" id=line9></span>      <span class="fstring">"""
<span class="lineno" id=line10></span>      (let
<span class="lineno" id=line11></span>        (
<span class="lineno" id=line12></span>          (names (cons _2 _3))
<span class="lineno" id=line13></span>          (vals (mkexlist _5))
<span class="lineno" id=line14></span>        )
<span class="lineno" id=line15></span>        (begin
<span class="lineno" id=line16></span>        ;;(display "names=")(display names)
<span class="lineno" id=line17></span>        ;;(display "init=")(display vals)
<span class="lineno" id=line18></span>        ;;(display "\\n")
<span class="lineno" id=line19></span>        (if (eq? (length names)(length vals))
<span class="lineno" id=line20></span>          (let
<span class="lineno" id=line21></span>            (
<span class="lineno" id=line22></span>              (f (lambda (n v)`(ast_val_decl ,_sr ,n ,dfltvs none (some ,v))))
<span class="lineno" id=line23></span>            )
<span class="lineno" id=line24></span>            `(ast_seq ,_sr ,(map f names vals))
<span class="lineno" id=line25></span>          )
<span class="lineno" id=line26></span>          (let*
<span class="lineno" id=line27></span>            (
<span class="lineno" id=line28></span>              (f (lambda (n)`((Val ,_sr ,n) none)))
<span class="lineno" id=line29></span>              (lexpr (map f names))
<span class="lineno" id=line30></span>            )
<span class="lineno" id=line31></span>            `(ast_assign ,_sr _set ((List ,lexpr) none) ,_5)
<span class="lineno" id=line32></span>          )
<span class="lineno" id=line33></span>      )))
<span class="lineno" id=line34></span>      """</span>;
<span class="lineno" id=line35></span>  
<span class="lineno" id=line36></span>    <span class="doccomment">Value binder, single.</span>
<span class="lineno" id=line37></span>    stmt := <span class="fstring">"val"</span> sdeclname <span class="fstring">"="</span> sexpr <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line38></span>      <span class="fstring">"""
<span class="lineno" id=line39></span>      `(ast_val_decl ,_sr ,(first _2) ,(second _2) none (some ,_4))
<span class="lineno" id=line40></span>       """</span>;
<span class="lineno" id=line41></span>  
<span class="lineno" id=line42></span>    stmt := <span class="fstring">"device"</span> sdeclname <span class="fstring">"="</span> sexpr <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line43></span>      <span class="fstring">"""
<span class="lineno" id=line44></span>      `(ast_val_decl ,_sr ,(first _2) ,(second _2) none (some ,_4))
<span class="lineno" id=line45></span>       """</span>;
<span class="lineno" id=line46></span>  
<span class="lineno" id=line47></span>  
<span class="lineno" id=line48></span>    <span class="doccomment">Value binder, single, with type.</span>
<span class="lineno" id=line49></span>    stmt := <span class="fstring">"val"</span> sdeclname <span class="fstring">":"</span> stypeexpr <span class="fstring">"="</span> sexpr <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line50></span>      <span class="fstring">"""
<span class="lineno" id=line51></span>      `(ast_val_decl ,_sr ,(first _2) ,(second _2) (some ,_4) (some ,_6))
<span class="lineno" id=line52></span>       """</span>;
<span class="lineno" id=line53></span>  
<span class="lineno" id=line54></span>    <span class="doccomment">Variable binder, multiple.</span>
<span class="lineno" id=line55></span>    stmt := <span class="fstring">"var"</span> sname sname_suffix <span class="fstring">"="</span> sexpr <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line56></span>      <span class="fstring">"""
<span class="lineno" id=line57></span>      (let
<span class="lineno" id=line58></span>        (
<span class="lineno" id=line59></span>          (names (cons _2 _3))
<span class="lineno" id=line60></span>          (vals (mkexlist _5))
<span class="lineno" id=line61></span>        )
<span class="lineno" id=line62></span>        (begin
<span class="lineno" id=line63></span>        ;;(display "names=")(display names)
<span class="lineno" id=line64></span>        ;;(display "init=")(display vals)
<span class="lineno" id=line65></span>        ;;(display "\\n")
<span class="lineno" id=line66></span>        (if (eq? (length names)(length vals))
<span class="lineno" id=line67></span>          (let
<span class="lineno" id=line68></span>            (
<span class="lineno" id=line69></span>              (f (lambda (n v)`(ast_var_decl ,_sr ,n ,dfltvs none (some ,v))))
<span class="lineno" id=line70></span>            )
<span class="lineno" id=line71></span>            `(ast_seq ,_sr ,(map f names vals))
<span class="lineno" id=line72></span>          )
<span class="lineno" id=line73></span>          (let*
<span class="lineno" id=line74></span>            (
<span class="lineno" id=line75></span>              (f (lambda (n)`((Var ,_sr ,n) none)))
<span class="lineno" id=line76></span>              (lexpr (map f names))
<span class="lineno" id=line77></span>            )
<span class="lineno" id=line78></span>            `(ast_assign ,_sr _set ((List ,lexpr) none) ,_5)
<span class="lineno" id=line79></span>          )
<span class="lineno" id=line80></span>      )))
<span class="lineno" id=line81></span>      """</span>;
<span class="lineno" id=line82></span>  
<span class="lineno" id=line83></span>    <span class="doccomment">Variable binder, single.</span>
<span class="lineno" id=line84></span>    stmt := <span class="fstring">"var"</span> sdeclname <span class="fstring">"="</span> sexpr <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line85></span>      <span class="fstring">"""
<span class="lineno" id=line86></span>      `(ast_var_decl ,_sr ,(first _2) ,(second _2) none (some ,_4))
<span class="lineno" id=line87></span>       """</span>;
<span class="lineno" id=line88></span>  
<span class="lineno" id=line89></span>    <span class="doccomment">Variable binder, single, with type.</span>
<span class="lineno" id=line90></span>    stmt := <span class="fstring">"var"</span> sdeclname <span class="fstring">":"</span> stypeexpr <span class="fstring">"="</span> sexpr <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line91></span>      <span class="fstring">"""
<span class="lineno" id=line92></span>      `(ast_var_decl ,_sr ,(first _2) ,(second _2) (some ,_4) (some ,_6))
<span class="lineno" id=line93></span>       """</span>;
<span class="lineno" id=line94></span>  
<span class="lineno" id=line95></span>    <span class="doccomment">Variable binder, single, with type, no explicit initialiser.</span>
<span class="lineno" id=line96></span>    stmt := <span class="fstring">"var"</span> sdeclname <span class="fstring">":"</span> stypeexpr <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line97></span>      <span class="fstring">"""
<span class="lineno" id=line98></span>      `(ast_var_decl ,_sr ,(first _2) ,(second _2) (some ,_4) none)
<span class="lineno" id=line99></span>       """</span>;
<span class="lineno" id=line100></span>  }
<span class="lineno" id=line101></span>  
</pre></p></div><h2 id='Chips_h'><img src='/share/src/web/images/minus.gif' id='Chips' onclick='toggle(this,"Chips_d")' alt='+'/> 2.28 Chips</h2><div id='Chips_d' style='display:block'>
<pre class='inclusion'>
share/lib/grammar/chips.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> chips {
<span class="lineno" id=line2></span>    <span class="doccomment">input schannel type %&lt;T</span>
<span class="lineno" id=line3></span>    pintype := <span class="fstring">"%&lt;"</span> t[spower_pri] =&gt;# <span class="fstring">'`(ast_name ,_sr "ischannel" (texprs (,_2)))'</span>;
<span class="lineno" id=line4></span>  
<span class="lineno" id=line5></span>    <span class="doccomment">output schannel type %&gt;T</span>
<span class="lineno" id=line6></span>    pintype := <span class="fstring">"%&gt;"</span> t[spower_pri] =&gt;# <span class="fstring">'`(ast_name ,_sr "oschannel" (texprs (,_2)))'</span>;
<span class="lineno" id=line7></span>  
<span class="lineno" id=line8></span>    <span class="doccomment">input/output schannel type %&lt;&gt;T</span>
<span class="lineno" id=line9></span>    pintype := <span class="fstring">"%&lt;&gt;"</span> t[spower_pri] =&gt;# <span class="fstring">'`(ast_name ,_sr "ioschannel" (texprs (,_2)))'</span>;
<span class="lineno" id=line10></span>  
<span class="lineno" id=line11></span>    <span class="doccomment">duplex schannel type %&lt;INPUT%&gt;OUTPUT</span>
<span class="lineno" id=line12></span>    pintype := <span class="fstring">"%&lt;"</span> t[spower_pri] <span class="fstring">"%&gt;"</span> t[spower_pri] =&gt;# 
<span class="lineno" id=line13></span>      <span class="fstring">'`(ast_name ,_sr "duplex_schannel" (texprs (,_2 ,_4)))'</span>
<span class="lineno" id=line14></span>    ;
<span class="lineno" id=line15></span>  
<span class="lineno" id=line16></span>    pinspec :=  <span class="fstring">"pin"</span> sname <span class="fstring">":"</span>  pintype =&gt;# <span class="fstring">"`(,_2 ,_4)"</span>; 
<span class="lineno" id=line17></span>  
<span class="lineno" id=line18></span>    stmt := <span class="fstring">"chip"</span> sdeclname sfun_arg* 
<span class="lineno" id=line19></span>      <span class="fstring">"connector"</span> sname pinspec*
<span class="lineno" id=line20></span>       scompound =&gt;#
<span class="lineno" id=line21></span>      <span class="fstring">"""
<span class="lineno" id=line22></span>        (let*
<span class="lineno" id=line23></span>          (
<span class="lineno" id=line24></span>            (name (first _2))
<span class="lineno" id=line25></span>            (vs (second _2))
<span class="lineno" id=line26></span>            (args _3)
<span class="lineno" id=line27></span>            (effects dflteffects)
<span class="lineno" id=line28></span>            (ret `(ast_void ,_sr))
<span class="lineno" id=line29></span>            (traint 'none)
<span class="lineno" id=line30></span>            (body _7)
<span class="lineno" id=line31></span>            (pinstype `(ast_record_type ,_6))
<span class="lineno" id=line32></span>            (pinsarg `(,_sr PVal ,_5 ,pinstype none))
<span class="lineno" id=line33></span>            (pinsargs `((Satom ,pinsarg) none))
<span class="lineno" id=line34></span>            (args (append args `(,pinsargs ,unitparam)))
<span class="lineno" id=line35></span>          )
<span class="lineno" id=line36></span>          `(ast_curry_effects ,_sr ,name ,vs ,args (,ret ,traint) ,effects
<span class="lineno" id=line37></span>           NoInlineFunction (NoInlineFunction) ,body)
<span class="lineno" id=line38></span>        )
<span class="lineno" id=line39></span>      """</span>;
<span class="lineno" id=line40></span>  
<span class="lineno" id=line41></span>    stmt := <span class="fstring">"circuit"</span> sconnection+ <span class="fstring">"endcircuit"</span> =&gt;# <span class="fstring">"`(ast_circuit ,_sr ,_2)"</span>;
<span class="lineno" id=line42></span>     spin := sname <span class="fstring">"."</span> sname =&gt;# <span class="fstring">"`(,_1 ,_3)"</span>;
<span class="lineno" id=line43></span>     sconnection := <span class="fstring">"connect"</span> <span class="library" title="functional, singly linked list">list</span>::commalist1&lt;spin&gt; =&gt;# <span class="fstring">"`(connect ,_2)"</span>;
<span class="lineno" id=line44></span>     sconnection := <span class="fstring">"wire"</span> sexpr <span class="fstring">"to"</span> sname <span class="fstring">"."</span> sname =&gt;# <span class="fstring">"`(wire (,_2 ,_4 ,_6))"</span>;
<span class="lineno" id=line45></span>  
<span class="lineno" id=line46></span>  }
</pre></p></div><h2 id='Syntax_h'><img src='/share/src/web/images/minus.gif' id='Syntax' onclick='toggle(this,"Syntax_d")' alt='+'/> 2.29 Syntax</h2><div id='Syntax_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/algebra/setexpr.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> setexpr
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    cmp := <span class="fstring">"in"</span> =&gt;# <span class="fstring">'(nos "\\in")'</span>; 
<span class="lineno" id=line4></span>    cmp := <span class="fstring">"\in"</span> =&gt;# <span class="fstring">"(nos _1)"</span>; 
<span class="lineno" id=line5></span>    cmp := <span class="fstring">"\notin"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line6></span>    cmp := <span class="fstring">"\owns"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line7></span>  
<span class="lineno" id=line8></span>    x[ssetunion_pri] := x[ssetunion_pri] <span class="fstring">"\cup"</span> x[&gt;ssetunion_pri] =&gt;# <span class="fstring">"(Infix)"</span> note <span class="fstring">"setunion"</span>;
<span class="lineno" id=line9></span>    x[ssetintersection_pri] := x[ssetintersection_pri] <span class="fstring">"\cap"</span> x[&gt;ssetintersection_pri] =&gt;# <span class="fstring">"(Infix)"</span> note <span class="fstring">"setintersection"</span>;
<span class="lineno" id=line10></span>  
<span class="lineno" id=line11></span>  }
</pre></p></div></div><h1 id='Syntax_h'><img src='/share/src/web/images/minus.gif' id='Syntax' onclick='toggle(this,"Syntax_d")' alt='+'/> 3 Syntax</h1><div id='Syntax_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/algebra/cmpexpr.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> cmpexpr
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    x[scomparison_pri]:= x[&gt;scomparison_pri] cmp x[&gt;scomparison_pri] =&gt;# 
<span class="lineno" id=line4></span>      <span class="fstring">"(binop _2 _1 _3)"</span>;
<span class="lineno" id=line5></span>    x[scomparison_pri]:= x[&gt;scomparison_pri] <span class="fstring">"not"</span> cmp x[&gt;scomparison_pri] =&gt;# 
<span class="lineno" id=line6></span>     <span class="fstring">"`(ast_not ,_sr ,(binop _3 _1 _4))"</span>;
<span class="lineno" id=line7></span>    cmp := <span class="fstring">"=="</span> =&gt;# <span class="fstring">"(nos _1)"</span>; 
<span class="lineno" id=line8></span>    cmp := <span class="fstring">"!="</span> =&gt;# <span class="fstring">"(nos _1)"</span>; 
<span class="lineno" id=line9></span>    cmp := <span class="fstring">"\ne"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line10></span>    cmp := <span class="fstring">"\neq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line11></span>  }
</pre></p><h2 id='Syntax_h'><img src='/share/src/web/images/minus.gif' id='Syntax' onclick='toggle(this,"Syntax_d")' alt='+'/> 3.1 Syntax</h2><div id='Syntax_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/algebra/pordcmpexpr.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> pordcmpexpr
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    cmp := <span class="fstring">"\subset"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line4></span>    cmp := <span class="fstring">"\supset"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line5></span>    cmp := <span class="fstring">"\subseteq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line6></span>    cmp := <span class="fstring">"\subseteqq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line7></span>    cmp := <span class="fstring">"\supseteq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line8></span>    cmp := <span class="fstring">"\supseteqq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line9></span>  
<span class="lineno" id=line10></span>    cmp := <span class="fstring">"\nsubseteq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line11></span>    cmp := <span class="fstring">"\nsubseteqq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line12></span>    cmp := <span class="fstring">"\nsupseteq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line13></span>    cmp := <span class="fstring">"\nsupseteqq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line14></span>  
<span class="lineno" id=line15></span>    cmp := <span class="fstring">"\subsetneq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line16></span>    cmp := <span class="fstring">"\subsetneqq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line17></span>    cmp := <span class="fstring">"\supsetneq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line18></span>    cmp := <span class="fstring">"\supsetneqq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line19></span>  }
<span class="lineno" id=line20></span>  
<span class="lineno" id=line21></span>  
<span class="lineno" id=line22></span>  
</pre></p></div><h2 id='Syntax_h'><img src='/share/src/web/images/minus.gif' id='Syntax' onclick='toggle(this,"Syntax_d")' alt='+'/> 3.2 Syntax</h2><div id='Syntax_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/algebra/tordcmpexpr.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> tordcmpexpr
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    cmp := <span class="fstring">"&lt;"</span> =&gt;# <span class="fstring">"(nos _1)"</span>; 
<span class="lineno" id=line4></span>  
<span class="lineno" id=line5></span>    cmp := <span class="fstring">"\lt"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line6></span>    cmp := <span class="fstring">"\lneq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line7></span>    cmp := <span class="fstring">"\lneqq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line8></span>  
<span class="lineno" id=line9></span>    cmp := <span class="fstring">"&lt;="</span> =&gt;# <span class="fstring">"(nos _1)"</span>; 
<span class="lineno" id=line10></span>    cmp := <span class="fstring">"\le"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line11></span>    cmp := <span class="fstring">"\leq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line12></span>    cmp := <span class="fstring">"\leqq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line13></span>  
<span class="lineno" id=line14></span>    cmp := <span class="fstring">"&gt;"</span> =&gt;# <span class="fstring">"(nos _1)"</span>; 
<span class="lineno" id=line15></span>    cmp := <span class="fstring">"\gt"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line16></span>    cmp := <span class="fstring">"\gneq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line17></span>    cmp := <span class="fstring">"\gneqq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line18></span>  
<span class="lineno" id=line19></span>    cmp := <span class="fstring">"&gt;="</span> =&gt;# <span class="fstring">"(nos _1)"</span>; 
<span class="lineno" id=line20></span>    cmp := <span class="fstring">"\ge"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line21></span>    cmp := <span class="fstring">"\geq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line22></span>    cmp := <span class="fstring">"\geqq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line23></span>  
<span class="lineno" id=line24></span>    cmp := <span class="fstring">"\nless"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line25></span>    cmp := <span class="fstring">"\nleq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line26></span>    cmp := <span class="fstring">"\nleqq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line27></span>    cmp := <span class="fstring">"\ngtr"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line28></span>    cmp := <span class="fstring">"\ngeq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line29></span>    cmp := <span class="fstring">"\ngeqq"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line30></span>  
<span class="lineno" id=line31></span>    bin := <span class="fstring">"\vee"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line32></span>    bin := <span class="fstring">"\wedge"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; 
<span class="lineno" id=line33></span>  }
<span class="lineno" id=line34></span>  
</pre></p></div><h2 id='Syntax_h'><img src='/share/src/web/images/minus.gif' id='Syntax' onclick='toggle(this,"Syntax_d")' alt='+'/> 3.3 Syntax</h2><div id='Syntax_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/algebra/mulexpr.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> mulexpr
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    <span class="doccomment">multiplication: non-associative.</span>
<span class="lineno" id=line4></span>    x[sproduct_pri] := x[sproduct_pri] <span class="fstring">"*"</span> x[&gt;sproduct_pri] =&gt;# <span class="fstring">"(Infix)"</span>;
<span class="lineno" id=line5></span>  }
<span class="lineno" id=line6></span>  
<span class="lineno" id=line7></span>  
</pre></p></div><h2 id='Notation_h'><img src='/share/src/web/images/minus.gif' id='Notation' onclick='toggle(this,"Notation_d")' alt='+'/> 3.4 Notation</h2><div id='Notation_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/algebra/addexpr.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> addexpr
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    <span class="doccomment">Addition: left associative.</span>
<span class="lineno" id=line4></span>    x[ssum_pri] := x[ssum_pri] <span class="fstring">"+"</span> x[&gt;ssum_pri] =&gt;# <span class="fstring">"(Infix)"</span>;
<span class="lineno" id=line5></span>  
<span class="lineno" id=line6></span>    <span class="doccomment">Subtraction: left associative.</span>
<span class="lineno" id=line7></span>    x[ssum_pri] := x[ssum_pri] <span class="fstring">"-"</span> x[&gt;ssum_pri] =&gt;# <span class="fstring">"(Infix)"</span>;
<span class="lineno" id=line8></span>  }
<span class="lineno" id=line9></span>  
<span class="lineno" id=line10></span>  
<span class="lineno" id=line11></span>  
</pre></p></div><h2 id='Syntax_h'><img src='/share/src/web/images/minus.gif' id='Syntax' onclick='toggle(this,"Syntax_d")' alt='+'/> 3.5 Syntax</h2><div id='Syntax_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/algebra/divexpr.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> divexpr
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    <span class="doccomment">division: right associative low precedence fraction form</span>
<span class="lineno" id=line4></span>    x[stuple_pri] := x[&gt;stuple_pri] <span class="fstring">"\over"</span> x[&gt;stuple_pri] =&gt;# <span class="fstring">"(Infix)"</span>;
<span class="lineno" id=line5></span>  
<span class="lineno" id=line6></span>    <span class="doccomment">division: left associative.</span>
<span class="lineno" id=line7></span>    x[sproduct_pri] := x[sproduct_pri] <span class="fstring">"/"</span> x[&gt;sproduct_pri] =&gt;# <span class="fstring">"(Infix)"</span>;
<span class="lineno" id=line8></span>  
<span class="lineno" id=line9></span>    <span class="doccomment">remainder: left associative.</span>
<span class="lineno" id=line10></span>    x[sproduct_pri] := x[sproduct_pri] <span class="fstring">"%"</span> x[&gt;sproduct_pri] =&gt;# <span class="fstring">"(Infix)"</span>;
<span class="lineno" id=line11></span>  
<span class="lineno" id=line12></span>    <span class="doccomment">remainder: left associative.</span>
<span class="lineno" id=line13></span>    x[sproduct_pri] := x[sproduct_pri] <span class="fstring">"\bmod"</span> x[&gt;sproduct_pri] =&gt;# <span class="fstring">"(Infix)"</span>;
<span class="lineno" id=line14></span>  }
<span class="lineno" id=line15></span>  
<span class="lineno" id=line16></span>  
</pre></p></div><h2 id='Syntax_h'><img src='/share/src/web/images/minus.gif' id='Syntax' onclick='toggle(this,"Syntax_d")' alt='+'/> 3.6 Syntax</h2><div id='Syntax_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/algebra/bitexpr.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> bitexpr
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    <span class="doccomment">Bitwise or, left associative.</span>
<span class="lineno" id=line4></span>    x[sbor_pri] := x[sbor_pri] <span class="fstring">"\|"</span> x[&gt;sbor_pri] =&gt;# <span class="fstring">"(Infix)"</span>;
<span class="lineno" id=line5></span>  
<span class="lineno" id=line6></span>    <span class="doccomment">Bitwise xor, left associative.</span>
<span class="lineno" id=line7></span>    x[sbxor_pri] := x[sbxor_pri] <span class="fstring">"\^"</span> x[&gt;sbxor_pri] =&gt;# <span class="fstring">"(Infix)"</span>;
<span class="lineno" id=line8></span>  
<span class="lineno" id=line9></span>    <span class="doccomment">Bitwise exclusive and, left associative.</span>
<span class="lineno" id=line10></span>    x[sband_pri] := x[sband_pri] <span class="fstring">"\&amp;"</span> x[&gt;sband_pri] =&gt;# <span class="fstring">"(Infix)"</span>;
<span class="lineno" id=line11></span>  
<span class="lineno" id=line12></span>    <span class="doccomment">Bitwise left shift, left associative.</span>
<span class="lineno" id=line13></span>    x[sshift_pri] := x[sshift_pri] <span class="fstring">"&lt;&lt;"</span> x[&gt;sshift_pri] =&gt;# <span class="fstring">"(Infix)"</span>;
<span class="lineno" id=line14></span>  
<span class="lineno" id=line15></span>    <span class="doccomment">Bitwise right shift, left associative.</span>
<span class="lineno" id=line16></span>    x[sshift_pri] := x[sshift_pri] <span class="fstring">"&gt;&gt;"</span> x[&gt;sshift_pri] =&gt;# <span class="fstring">"(Infix)"</span>;
<span class="lineno" id=line17></span>  }
<span class="lineno" id=line18></span>  
<span class="lineno" id=line19></span>  
</pre></p><pre class='inclusion'>
share/lib/grammar/swapop.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> swapop
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    sswapop := <span class="fstring">"&lt;-&gt;"</span> =&gt;# <span class="fstring">"'swap"</span>;
<span class="lineno" id=line4></span>  }
</pre></p><pre class='inclusion'>
share/lib/grammar/grammar_int_lexer.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line3></span>  (define (findradix s)  ; find the radix of integer lexeme
<span class="lineno" id=line4></span>    (let* 
<span class="lineno" id=line5></span>      (
<span class="lineno" id=line6></span>        (n (string-length s))
<span class="lineno" id=line7></span>        (result 
<span class="lineno" id=line8></span>          (cond 
<span class="lineno" id=line9></span>            ((prefix? "0b" s)`(,(substring s 2 n) 2)) 
<span class="lineno" id=line10></span>            ((prefix? "0o" s)`(,(substring s 2 n) 8)) 
<span class="lineno" id=line11></span>            ((prefix? "0d" s)`(,(substring s 2 n) 10)) 
<span class="lineno" id=line12></span>            ((prefix? "0x" s)`(,(substring s 2 n) 16)) 
<span class="lineno" id=line13></span>            (else `(,s 10))
<span class="lineno" id=line14></span>          )
<span class="lineno" id=line15></span>        )
<span class="lineno" id=line16></span>      )
<span class="lineno" id=line17></span>      result
<span class="lineno" id=line18></span>    )
<span class="lineno" id=line19></span>  )
<span class="lineno" id=line20></span>  """</span>;
<span class="lineno" id=line21></span>  
<span class="lineno" id=line22></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line23></span>  (define (findtype s) ;; find type of integer lexeme
<span class="lineno" id=line24></span>    (let*
<span class="lineno" id=line25></span>      (
<span class="lineno" id=line26></span>        (n (string-length s))
<span class="lineno" id=line27></span>        (result
<span class="lineno" id=line28></span>          (cond
<span class="lineno" id=line29></span>            ((suffix? "ut" s)`(,(substring s 0 (- n 2)) "utiny"))
<span class="lineno" id=line30></span>            ((suffix? "tu" s)`(,(substring s 0 (- n 2)) "utiny"))
<span class="lineno" id=line31></span>            ((suffix? "t" s)`(,(substring s 0 (- n 1)) "tiny"))
<span class="lineno" id=line32></span>  
<span class="lineno" id=line33></span>            ((suffix? "us" s)`(,(substring s 0 (- n 2)) "ushort"))
<span class="lineno" id=line34></span>            ((suffix? "su" s)`(,(substring s 0 (- n 2)) "ushort"))
<span class="lineno" id=line35></span>            ((suffix? "s" s)`(,(substring s 0 (- n 1)) "short"))
<span class="lineno" id=line36></span>  
<span class="lineno" id=line37></span>            ((suffix? "ui" s)`(,(substring s 0 (- n 2)) "uint"))
<span class="lineno" id=line38></span>            ((suffix? "iu" s)`(,(substring s 0 (- n 2)) "uint"))
<span class="lineno" id=line39></span>            ((suffix? "i" s)`(,(substring s 0 (- n 1)) "int"))
<span class="lineno" id=line40></span>  
<span class="lineno" id=line41></span>            ((suffix? "uz" s)`(,(substring s 0 (- n 2)) "size"))
<span class="lineno" id=line42></span>            ((suffix? "zu" s)`(,(substring s 0 (- n 2)) "size"))
<span class="lineno" id=line43></span>            ((suffix? "z" s)`(,(substring s 0 (- n 1)) "ssize"))
<span class="lineno" id=line44></span>  
<span class="lineno" id=line45></span>            ((suffix? "uj" s)`(,(substring s 0 (- n 2)) "uintmax"))
<span class="lineno" id=line46></span>            ((suffix? "ju" s)`(,(substring s 0 (- n 2)) "uintmax"))
<span class="lineno" id=line47></span>            ((suffix? "j" s)`(,(substring s 0 (- n 1)) "intmax"))
<span class="lineno" id=line48></span>  
<span class="lineno" id=line49></span>            ((suffix? "up" s)`(,(substring s 0 (- n 2)) "uintptr"))
<span class="lineno" id=line50></span>            ((suffix? "pu" s)`(,(substring s 0 (- n 2)) "uintptr"))
<span class="lineno" id=line51></span>            ((suffix? "p" s)`(,(substring s 0 (- n 1)) "intptr"))
<span class="lineno" id=line52></span>  
<span class="lineno" id=line53></span>            ((suffix? "ud" s)`(,(substring s 0 (- n 2)) "uptrdiff"))
<span class="lineno" id=line54></span>            ((suffix? "du" s)`(,(substring s 0 (- n 2)) "uptrdiff"))
<span class="lineno" id=line55></span>            ((suffix? "d" s)`(,(substring s 0 (- n 1)) "ptrdiff"))
<span class="lineno" id=line56></span>  
<span class="lineno" id=line57></span>            ;; must come first!
<span class="lineno" id=line58></span>            ((suffix? "uvl" s)`(,(substring s 0 (- n 3)) "uvlong"))
<span class="lineno" id=line59></span>            ((suffix? "vlu" s)`(,(substring s 0 (- n 3)) "uvlong"))
<span class="lineno" id=line60></span>            ((suffix? "ulv" s)`(,(substring s 0 (- n 3)) "uvlong"))
<span class="lineno" id=line61></span>            ((suffix? "lvu" s)`(,(substring s 0 (- n 3)) "uvlong"))
<span class="lineno" id=line62></span>            ((suffix? "llu" s)`(,(substring s 0 (- n 3)) "uvlong"))
<span class="lineno" id=line63></span>            ((suffix? "ull" s)`(,(substring s 0 (- n 3)) "uvlong"))
<span class="lineno" id=line64></span>  
<span class="lineno" id=line65></span>            ((suffix? "uv" s)`(,(substring s 0 (- n 2)) "uvlong"))
<span class="lineno" id=line66></span>            ((suffix? "vu" s)`(,(substring s 0 (- n 2)) "uvlong"))
<span class="lineno" id=line67></span>  
<span class="lineno" id=line68></span>            ((suffix? "lv" s)`(,(substring s 0 (- n 2)) "vlong"))
<span class="lineno" id=line69></span>            ((suffix? "vl" s)`(,(substring s 0 (- n 2)) "vlong"))
<span class="lineno" id=line70></span>            ((suffix? "ll" s)`(,(substring s 0 (- n 2)) "vlong"))
<span class="lineno" id=line71></span>      
<span class="lineno" id=line72></span>            ;; comes next
<span class="lineno" id=line73></span>            ((suffix? "ul" s)`(,(substring s 0 (- n 2)) "ulong"))
<span class="lineno" id=line74></span>            ((suffix? "lu" s)`(,(substring s 0 (- n 2)) "ulong"))
<span class="lineno" id=line75></span>  
<span class="lineno" id=line76></span>            ;; last
<span class="lineno" id=line77></span>            ((suffix? "v" s)`(,(substring s 0 (- n 1)) "vlong"))
<span class="lineno" id=line78></span>            ((suffix? "u" s)`(,(substring s 0 (- n 1)) "uint"))
<span class="lineno" id=line79></span>            ((suffix? "l" s)`(,(substring s 0 (- n 1)) "long"))
<span class="lineno" id=line80></span>  
<span class="lineno" id=line81></span>            ;; exact
<span class="lineno" id=line82></span>            ((suffix? "u8" s)`(,(substring s 0 (- n 2)) "uint8"))
<span class="lineno" id=line83></span>            ((suffix? "u16" s)`(,(substring s 0 (- n 3)) "uint16"))
<span class="lineno" id=line84></span>            ((suffix? "u32" s)`(,(substring s 0 (- n 3)) "uint32"))
<span class="lineno" id=line85></span>            ((suffix? "u64" s)`(,(substring s 0 (- n 3)) "uint64"))
<span class="lineno" id=line86></span>            ((suffix? "i8" s)`(,(substring s 0 (- n 2)) "int8"))
<span class="lineno" id=line87></span>            ((suffix? "i16" s)`(,(substring s 0 (- n 3)) "int16"))
<span class="lineno" id=line88></span>            ((suffix? "i32" s)`(,(substring s 0 (- n 3)) "int32"))
<span class="lineno" id=line89></span>            ((suffix? "i64" s)`(,(substring s 0 (- n 3)) "int64"))
<span class="lineno" id=line90></span>            (else `(,s "int"))
<span class="lineno" id=line91></span>          )
<span class="lineno" id=line92></span>        )
<span class="lineno" id=line93></span>      )
<span class="lineno" id=line94></span>      result
<span class="lineno" id=line95></span>    )
<span class="lineno" id=line96></span>  )
<span class="lineno" id=line97></span>  """</span>;
<span class="lineno" id=line98></span>  
<span class="lineno" id=line99></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""
<span class="lineno" id=line100></span>  (define (parse-int s) 
<span class="lineno" id=line101></span>    (let*
<span class="lineno" id=line102></span>      (
<span class="lineno" id=line103></span>        (s (tolower-string s))
<span class="lineno" id=line104></span>        (x (findradix s))
<span class="lineno" id=line105></span>        (radix (second x))
<span class="lineno" id=line106></span>        (x (first x))
<span class="lineno" id=line107></span>        (x (findtype x))
<span class="lineno" id=line108></span>        (type (second x))
<span class="lineno" id=line109></span>        (digits (first x))
<span class="lineno" id=line110></span>        (value (string-&gt;number digits radix))
<span class="lineno" id=line111></span>      )
<span class="lineno" id=line112></span>      (if (equal? value #f)
<span class="lineno" id=line113></span>         (begin 
<span class="lineno" id=line114></span>           (newline)
<span class="lineno" id=line115></span>           (display "Invalid integer literal ") (display s) 
<span class="lineno" id=line116></span>           (newline)
<span class="lineno" id=line117></span>           (display "Radix ")(display radix)
<span class="lineno" id=line118></span>           (newline)
<span class="lineno" id=line119></span>           (display "Type ")(display type)
<span class="lineno" id=line120></span>           (newline)
<span class="lineno" id=line121></span>           (display "Digits ")(display digits)
<span class="lineno" id=line122></span>           (newline)
<span class="lineno" id=line123></span>           error
<span class="lineno" id=line124></span>         )
<span class="lineno" id=line125></span>         `(,type ,value)
<span class="lineno" id=line126></span>      ) 
<span class="lineno" id=line127></span>    )
<span class="lineno" id=line128></span>  )
<span class="lineno" id=line129></span>  """</span>;
<span class="lineno" id=line130></span>  
<span class="lineno" id=line131></span>  <span class="doccomment">Integer literals.</span>
<span class="lineno" id=line132></span>  <span class="doccomment"></span>
<span class="lineno" id=line133></span>  <span class="doccomment">Felix integer literals consist of an optional radix specifer,</span>
<span class="lineno" id=line134></span>  <span class="doccomment">a sequence of digits of the radix type, possibly separated</span>
<span class="lineno" id=line135></span>  <span class="doccomment">by an underscore (_) character, and a trailing type specifier.</span>
<span class="lineno" id=line136></span>  <span class="doccomment">//$ The radix can be:</span>
<span class="lineno" id=line137></span>  <span class="doccomment">0b, 0B - binary</span>
<span class="lineno" id=line138></span>  <span class="doccomment">0o, 0O - octal</span>
<span class="lineno" id=line139></span>  <span class="doccomment">0d, 0D - decimal</span>
<span class="lineno" id=line140></span>  <span class="doccomment">0x, 0X - hex</span>
<span class="lineno" id=line141></span>  <span class="doccomment">//$ The default is decimal.</span>
<span class="lineno" id=line142></span>  <span class="doccomment">NOTE: unlike C a leading 0 in does NOT denote octal.</span>
<span class="lineno" id=line143></span>  <span class="doccomment">//$ Underscores are allowed between digits or the radix</span>
<span class="lineno" id=line144></span>  <span class="doccomment">and the first digit, or between the digits and type specifier.</span>
<span class="lineno" id=line145></span>  <span class="doccomment">//$ The adaptable signed type specifiers are:</span>
<span class="lineno" id=line146></span>  <span class="doccomment"></span>
<span class="lineno" id=line147></span>  <span class="doccomment">t        -- tiny   (char as int)</span>
<span class="lineno" id=line148></span>  <span class="doccomment">s        -- short</span>
<span class="lineno" id=line149></span>  <span class="doccomment">i        -- int</span>
<span class="lineno" id=line150></span>  <span class="doccomment">l        -- long </span>
<span class="lineno" id=line151></span>  <span class="doccomment">v,ll     -- vlong (long long in C)</span>
<span class="lineno" id=line152></span>  <span class="doccomment">z        -- ssize (ssize_t in C, a signed variant of size_t)</span>
<span class="lineno" id=line153></span>  <span class="doccomment">j        -- intmax</span>
<span class="lineno" id=line154></span>  <span class="doccomment">p        -- intptr</span>
<span class="lineno" id=line155></span>  <span class="doccomment">d        -- ptrdiff</span>
<span class="lineno" id=line156></span>  <span class="doccomment">//$ These may be upper of lower case. </span>
<span class="lineno" id=line157></span>  <span class="doccomment">A "u" or "U" before or after such specifier indicates</span>
<span class="lineno" id=line158></span>  <span class="doccomment">the correspondin unsigned type.</span>
<span class="lineno" id=line159></span>  <span class="doccomment">//$ The follingw exact type specifiers can be given:</span>
<span class="lineno" id=line160></span>  <span class="doccomment">//$      "i8" | "i16" | "i32" | "i64"</span>
<span class="lineno" id=line161></span>  <span class="doccomment">   | "u8" | "u16" | "u32" | "u64"</span>
<span class="lineno" id=line162></span>  <span class="doccomment">   | "I8" | "I16" | "I32" | "I64"</span>
<span class="lineno" id=line163></span>  <span class="doccomment">   | "U8" | "U16" | "U32" | "U64";</span>
<span class="lineno" id=line164></span>  <span class="doccomment">//$ The default type is "int".</span>
<span class="lineno" id=line165></span>  <span class="doccomment"></span>
<span class="lineno" id=line166></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> felix_int_lexer {
<span class="lineno" id=line167></span>    <span class="comment">/* integers */</span>
<span class="lineno" id=line168></span>    <span class="big_keyword" title="define named regular expression">regdef</span> bin_lit  = <span class="fstring">'0'</span> (<span class="fstring">'b'</span> | <span class="fstring">'B'</span>) (dsep ? bindigit) +;
<span class="lineno" id=line169></span>    <span class="big_keyword" title="define named regular expression">regdef</span> oct_lit  = <span class="fstring">'0'</span> (<span class="fstring">'o'</span> | <span class="fstring">'O'</span>) (dsep ? octdigit) +;
<span class="lineno" id=line170></span>    <span class="big_keyword" title="define named regular expression">regdef</span> dec_lit  = <span class="fstring">'0'</span> (<span class="fstring">'d'</span> | <span class="fstring">'D'</span>) (dsep ? digit) +;
<span class="lineno" id=line171></span>    <span class="big_keyword" title="define named regular expression">regdef</span> dflt_dec_lit  =  digit (dsep ? digit) *;
<span class="lineno" id=line172></span>    <span class="big_keyword" title="define named regular expression">regdef</span> hex_lit  = <span class="fstring">'0'</span> (<span class="fstring">'x'</span> | <span class="fstring">'X'</span>) (dsep ? hexdigit)  +;
<span class="lineno" id=line173></span>    <span class="big_keyword" title="define named regular expression">regdef</span> int_prefix = bin_lit | oct_lit | dec_lit | dflt_dec_lit | hex_lit;
<span class="lineno" id=line174></span>  
<span class="lineno" id=line175></span>    <span class="big_keyword" title="define named regular expression">regdef</span> fastint_type_suffix = 
<span class="lineno" id=line176></span>      <span class="fstring">'t'</span>|<span class="fstring">'T'</span>|<span class="fstring">'s'</span>|<span class="fstring">'S'</span>|<span class="fstring">'i'</span>|<span class="fstring">'I'</span>|<span class="fstring">'l'</span>|<span class="fstring">'L'</span>|<span class="fstring">'v'</span>|<span class="fstring">'V'</span>|<span class="fstring">"ll"</span>|<span class="fstring">"LL"</span>|<span class="fstring">"z"</span>|<span class="fstring">"Z"</span>|<span class="fstring">"j"</span>|<span class="fstring">"J"</span>|<span class="fstring">"p"</span>|<span class="fstring">"P"</span>|<span class="fstring">"d"</span>|<span class="fstring">"D"</span>;
<span class="lineno" id=line177></span>    <span class="big_keyword" title="define named regular expression">regdef</span> exactint_type_suffix =
<span class="lineno" id=line178></span>        <span class="fstring">"i8"</span> | <span class="fstring">"i16"</span> | <span class="fstring">"i32"</span> | <span class="fstring">"i64"</span>
<span class="lineno" id=line179></span>      | <span class="fstring">"u8"</span> | <span class="fstring">"u16"</span> | <span class="fstring">"u32"</span> | <span class="fstring">"u64"</span>
<span class="lineno" id=line180></span>      | <span class="fstring">"I8"</span> | <span class="fstring">"I16"</span> | <span class="fstring">"I32"</span> | <span class="fstring">"I64"</span>
<span class="lineno" id=line181></span>      | <span class="fstring">"U8"</span> | <span class="fstring">"U16"</span> | <span class="fstring">"U32"</span> | <span class="fstring">"U64"</span>;
<span class="lineno" id=line182></span>  
<span class="lineno" id=line183></span>    <span class="big_keyword" title="define named regular expression">regdef</span> signind = <span class="fstring">'u'</span> | <span class="fstring">'U'</span>;
<span class="lineno" id=line184></span>  
<span class="lineno" id=line185></span>    <span class="big_keyword" title="define named regular expression">regdef</span> int_type_suffix =
<span class="lineno" id=line186></span>        <span class="fstring">'_'</span>? exactint_type_suffix
<span class="lineno" id=line187></span>      | (<span class="fstring">'_'</span>? fastint_type_suffix)? (<span class="fstring">'_'</span>? signind)?
<span class="lineno" id=line188></span>      | (<span class="fstring">'_'</span>? signind)? (<span class="fstring">'_'</span>? fastint_type_suffix)?;
<span class="lineno" id=line189></span>  
<span class="lineno" id=line190></span>    <span class="big_keyword" title="define named regular expression">regdef</span> int_lit = int_prefix int_type_suffix;
<span class="lineno" id=line191></span>  
<span class="lineno" id=line192></span>    <span class="comment">// Untyped integer literals.</span>
<span class="lineno" id=line193></span>    <span class="big_keyword" title="define literal">literal</span> int_prefix =&gt;# <span class="fstring">"""
<span class="lineno" id=line194></span>    (let* 
<span class="lineno" id=line195></span>      (
<span class="lineno" id=line196></span>        (val (stripus _1))
<span class="lineno" id=line197></span>        (x (parse-int val))
<span class="lineno" id=line198></span>        ;; (type (first x))
<span class="lineno" id=line199></span>        (value (second x))
<span class="lineno" id=line200></span>      )
<span class="lineno" id=line201></span>      value
<span class="lineno" id=line202></span>    )
<span class="lineno" id=line203></span>    """</span>; 
<span class="lineno" id=line204></span>    sinteger := int_prefix =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line205></span>  
<span class="lineno" id=line206></span>    <span class="comment">// Typed integer literal.</span>
<span class="lineno" id=line207></span>    <span class="big_keyword" title="define literal">literal</span> int_lit =&gt;# <span class="fstring">"""
<span class="lineno" id=line208></span>    (let* 
<span class="lineno" id=line209></span>      (
<span class="lineno" id=line210></span>        (val (stripus _1))
<span class="lineno" id=line211></span>        (x (parse-int val))
<span class="lineno" id=line212></span>        (type (first x))
<span class="lineno" id=line213></span>        (value (second x))
<span class="lineno" id=line214></span>        (fvalue (number-&gt;string value))
<span class="lineno" id=line215></span>        (cvalue fvalue)       ;; FIXME!!
<span class="lineno" id=line216></span>      )
<span class="lineno" id=line217></span>      `(,type ,fvalue ,cvalue)
<span class="lineno" id=line218></span>    )
<span class="lineno" id=line219></span>    """</span>; 
<span class="lineno" id=line220></span>    sliteral := int_lit =&gt;# <span class="fstring">"`(ast_literal ,_sr ,@_1)"</span>;
<span class="lineno" id=line221></span>    sliteral := <span class="fstring">"@"</span> int_lit =&gt;# 
<span class="lineno" id=line222></span>      <span class="fstring">"""
<span class="lineno" id=line223></span>        `(ast_literal ,_sr "NSNumber" ,(second _2) ,(string-append "@" (third _2)))
<span class="lineno" id=line224></span>      """</span>
<span class="lineno" id=line225></span>    ;
<span class="lineno" id=line226></span>  
<span class="lineno" id=line227></span>    <span class="comment">// Typed signed integer constant.</span>
<span class="lineno" id=line228></span>    sintegral := int_lit =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line229></span>    sintegral := <span class="fstring">"-"</span> int_lit =&gt;# <span class="fstring">"""
<span class="lineno" id=line230></span>    (let* 
<span class="lineno" id=line231></span>      (
<span class="lineno" id=line232></span>        (type (first _2))
<span class="lineno" id=line233></span>        (val (second _2))
<span class="lineno" id=line234></span>        (val (* -1 val))
<span class="lineno" id=line235></span>      )
<span class="lineno" id=line236></span>      `(,type ,val)
<span class="lineno" id=line237></span>    )
<span class="lineno" id=line238></span>    """</span>;
<span class="lineno" id=line239></span>  
<span class="lineno" id=line240></span>    strint := sintegral =&gt;# <span class="fstring">"(second _1)"</span>;
<span class="lineno" id=line241></span>  }
<span class="lineno" id=line242></span>  
<span class="lineno" id=line243></span>  
</pre></p></div></div><h1 id='Float_literal_constructors_h'><img src='/share/src/web/images/minus.gif' id='Float literal constructors' onclick='toggle(this,"Float_literal_constructors_d")' alt='+'/> 4 Float literal constructors</h1><div id='Float_literal_constructors_d' style='display:block'>
<pre class='inclusion'>
share/lib/grammar/grammar_float_lexer.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>   
<span class="lineno" id=line2></span>  <span class="doccomment">Floating point literals.</span>
<span class="lineno" id=line3></span>  <span class="doccomment">//$ Follows ISO C89, except that we allow underscores;</span>
<span class="lineno" id=line4></span>  <span class="doccomment">AND we require both leading and trailing digits so that</span>
<span class="lineno" id=line5></span>  <span class="doccomment">x.0 works for tuple projections and 0.f is a function</span>
<span class="lineno" id=line6></span>  <span class="doccomment">application</span>
<span class="lineno" id=line7></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> felix_float_lexer {
<span class="lineno" id=line8></span>    <span class="big_keyword" title="define named regular expression">regdef</span> decimal_string = digit (dsep ? digit) *;
<span class="lineno" id=line9></span>    <span class="big_keyword" title="define named regular expression">regdef</span> hexadecimal_string = hexdigit (dsep ? hexdigit) *;
<span class="lineno" id=line10></span>  
<span class="lineno" id=line11></span>    <span class="big_keyword" title="define named regular expression">regdef</span> decimal_fractional_constant =
<span class="lineno" id=line12></span>      decimal_string <span class="fstring">'.'</span> decimal_string;
<span class="lineno" id=line13></span>  
<span class="lineno" id=line14></span>    <span class="big_keyword" title="define named regular expression">regdef</span> hexadecimal_fractional_constant =
<span class="lineno" id=line15></span>      (<span class="fstring">"0x"</span> |<span class="fstring">"0X"</span>)
<span class="lineno" id=line16></span>      hexadecimal_string <span class="fstring">'.'</span> hexadecimal_string;
<span class="lineno" id=line17></span>  
<span class="lineno" id=line18></span>    <span class="big_keyword" title="define named regular expression">regdef</span> decimal_exponent = (<span class="fstring">'E'</span>|<span class="fstring">'e'</span>) (<span class="fstring">'+'</span>|<span class="fstring">'-'</span>)? decimal_string;
<span class="lineno" id=line19></span>    <span class="big_keyword" title="define named regular expression">regdef</span> binary_exponent = (<span class="fstring">'P'</span>|<span class="fstring">'p'</span>) (<span class="fstring">'+'</span>|<span class="fstring">'-'</span>)? decimal_string;
<span class="lineno" id=line20></span>  
<span class="lineno" id=line21></span>    <span class="big_keyword" title="define named regular expression">regdef</span> floating_suffix = <span class="fstring">'L'</span> | <span class="fstring">'l'</span> | <span class="fstring">'F'</span> | <span class="fstring">'f'</span> | <span class="fstring">'D'</span> | <span class="fstring">'d'</span>;
<span class="lineno" id=line22></span>    <span class="big_keyword" title="define named regular expression">regdef</span> floating_literal =
<span class="lineno" id=line23></span>      (
<span class="lineno" id=line24></span>        decimal_fractional_constant decimal_exponent ? |
<span class="lineno" id=line25></span>        hexadecimal_fractional_constant binary_exponent ?
<span class="lineno" id=line26></span>      )
<span class="lineno" id=line27></span>      floating_suffix ?;
<span class="lineno" id=line28></span>  
<span class="lineno" id=line29></span>   <span class="comment">// Floating constant.</span>
<span class="lineno" id=line30></span>    <span class="big_keyword" title="define named regular expression">regdef</span> sfloat = floating_literal;
<span class="lineno" id=line31></span>    <span class="big_keyword" title="define literal">literal</span> sfloat =&gt;# <span class="fstring">"""
<span class="lineno" id=line32></span>    (let* 
<span class="lineno" id=line33></span>       (
<span class="lineno" id=line34></span>         (val (stripus _1))
<span class="lineno" id=line35></span>         (val (tolower-string val))
<span class="lineno" id=line36></span>         (n (string-length val))
<span class="lineno" id=line37></span>         (n-1 (- n 1))
<span class="lineno" id=line38></span>         (ch (substring val n-1 n))
<span class="lineno" id=line39></span>         (rest (substring val 0 n-1))
<span class="lineno" id=line40></span>         (result 
<span class="lineno" id=line41></span>           (if (equal? ch "l") `("ldouble" ,val ,val)
<span class="lineno" id=line42></span>             (if (equal? ch "f") `("float" ,val ,val) `("double" ,val ,val))
<span class="lineno" id=line43></span>           )
<span class="lineno" id=line44></span>         )
<span class="lineno" id=line45></span>       )
<span class="lineno" id=line46></span>       result 
<span class="lineno" id=line47></span>     ) 
<span class="lineno" id=line48></span>     """</span>; 
<span class="lineno" id=line49></span>  
<span class="lineno" id=line50></span>    strfloat := sfloat =&gt;# <span class="fstring">"(second _1)"</span>;
<span class="lineno" id=line51></span>  
<span class="lineno" id=line52></span>    <span class="comment">// Floating literal.</span>
<span class="lineno" id=line53></span>    sliteral := sfloat =&gt;# <span class="fstring">"`(ast_literal ,_sr ,@_1)"</span>;
<span class="lineno" id=line54></span>  
<span class="lineno" id=line55></span>    sliteral := <span class="fstring">"@"</span> sfloat =&gt;# 
<span class="lineno" id=line56></span>      <span class="fstring">"""
<span class="lineno" id=line57></span>        `(ast_literal ,_sr "NSNumber" ,(second _2) ,(string-append "@" (third _2)))
<span class="lineno" id=line58></span>      """</span>
<span class="lineno" id=line59></span>    ;
<span class="lineno" id=line60></span>  
<span class="lineno" id=line61></span>  }
<span class="lineno" id=line62></span>  
<span class="lineno" id=line63></span>  
</pre></p></div><h1 id='Tuple_Constructor_Syntax_h'><img src='/share/src/web/images/minus.gif' id='Tuple Constructor Syntax' onclick='toggle(this,"Tuple_Constructor_Syntax_d")' alt='+'/> 5 Tuple Constructor Syntax</h1><div id='Tuple_Constructor_Syntax_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/tupleexpr.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> tupleexpr
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    <span class="doccomment">Tuple formation by cons: right associative.</span>
<span class="lineno" id=line4></span>    x[stuple_cons_pri] := x[&gt;stuple_cons_pri] <span class="fstring">",,"</span> x[stuple_cons_pri] =&gt;# 
<span class="lineno" id=line5></span>      <span class="fstring">"""`(ast_tuple_cons ,_sr ,_1 ,_3)"""</span>;
<span class="lineno" id=line6></span>  
<span class="lineno" id=line7></span>    <span class="doccomment">Tuple formation by append: left associative</span>
<span class="lineno" id=line8></span>    x[stuple_cons_pri] := x[stuple_cons_pri] <span class="fstring">"&lt;,,&gt;"</span> x[&gt;stuple_cons_pri] =&gt;# 
<span class="lineno" id=line9></span>     <span class="fstring">"""`(ast_tuple_snoc ,_sr ,_1 ,_3)"""</span>;
<span class="lineno" id=line10></span>  
<span class="lineno" id=line11></span>    <span class="doccomment">Tuple formation non-associative.</span>
<span class="lineno" id=line12></span>    x[stuple_pri] := x[&gt;stuple_pri] ( <span class="fstring">","</span> x[&gt;stuple_pri])+ =&gt;# <span class="fstring">"(chain 'ast_tuple _1 _2)"</span>;
<span class="lineno" id=line13></span>    x[scompacttuple_pri] := x[&gt;scompacttuple_pri] ( <span class="fstring">"\,"</span> x[&gt;scompacttuple_pri])+ =&gt;# <span class="fstring">"(chain 'ast_compacttuple _1 _2)"</span>;
<span class="lineno" id=line14></span>  
<span class="lineno" id=line15></span>  }
<span class="lineno" id=line16></span>  
<span class="lineno" id=line17></span>  
</pre></p><pre class='inclusion'>
share/lib/grammar/debug.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> debug
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>     satom := <span class="fstring">"HERE"</span> =&gt;# <span class="fstring">"`(ast_here ,_sr)"</span>;
<span class="lineno" id=line4></span>  }
</pre></p></div><h1 id='Exception_Grammar_h'><img src='/share/src/web/images/minus.gif' id='Exception Grammar' onclick='toggle(this,"Exception_Grammar_d")' alt='+'/> 6 Exception Grammar</h1><div id='Exception_Grammar_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/control/exceptions.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> exceptions
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    <span class="doccomment">Exception handling.</span>
<span class="lineno" id=line4></span>    <span class="doccomment">  //$ try .. catch x : T =&gt; handler endtry</span>
<span class="lineno" id=line5></span>    <span class="doccomment">  //$ can be used to execute code which might throw</span>
<span class="lineno" id=line6></span>    <span class="doccomment">an exception, and catch the exception.</span>
<span class="lineno" id=line7></span>    <span class="doccomment">  //$ This is primarily intended to for wrapping C bindings.</span>
<span class="lineno" id=line8></span>    <span class="doccomment">Exceptions do not propage properly in Felix across</span>
<span class="lineno" id=line9></span>    <span class="doccomment">multiple function/procedure layers. If you have to use</span>
<span class="lineno" id=line10></span>    <span class="doccomment">this construction be sure to keep wrap the try block</span>
<span class="lineno" id=line11></span>    <span class="doccomment">closely around the throwing code.</span>
<span class="lineno" id=line12></span>    block := <span class="fstring">"try"</span> stmt+ catches <span class="fstring">"endtry"</span> =&gt;#
<span class="lineno" id=line13></span>      <span class="fstring">"`(ast_seq ,_sr ,(append `((ast_try ,_sr)) _2 _3 `((ast_endtry ,_sr))))"</span>;
<span class="lineno" id=line14></span>  
<span class="lineno" id=line15></span>    <span class="big_keyword" title="catch handler">catch</span> := <span class="fstring">"catch"</span> sname <span class="fstring">":"</span> sexpr  <span class="fstring">"=&gt;"</span> stmt+ =&gt;#
<span class="lineno" id=line16></span>      <span class="fstring">"`(ast_seq ,_sr ,(cons `(ast_catch ,_sr ,_2 ,_4) _6))"</span>;
<span class="lineno" id=line17></span>  
<span class="lineno" id=line18></span>    catches := <span class="big_keyword" title="catch handler">catch</span>+ =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line19></span>  }
<span class="lineno" id=line20></span>  
</pre></p><pre class='inclusion'>
share/lib/std/control/spipeexpr.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> spipeexpr 
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    <span class="doccomment">Left assoc, for schannel pipes.</span>
<span class="lineno" id=line4></span>    x[ssetunion_pri] := x[ssetunion_pri] <span class="fstring">"|-&gt;"</span> x[&gt;ssetunion_pri] =&gt;# <span class="fstring">"(infix 'pipe)"</span>; 
<span class="lineno" id=line5></span>  
<span class="lineno" id=line6></span>    <span class="doccomment">Right assoc, for schannel pipes transformers</span>
<span class="lineno" id=line7></span>    <span class="comment">// =&gt; BREAKS PATTERN MATCHING, replaced with &gt;=&gt; but can't find any uses</span>
<span class="lineno" id=line8></span>    <span class="comment">//x[ssetunion_pri] := x[&gt;ssetunion_pri] "&gt;=&gt;" x[ssetunion_pri] =&gt;# "(infix 'trans_type)"; </span>
<span class="lineno" id=line9></span>  
<span class="lineno" id=line10></span>    <span class="doccomment">Non associative, streaming data structure into transducer.</span>
<span class="lineno" id=line11></span>    x[ssetunion_pri] := x[&gt;ssetunion_pri] <span class="fstring">"&gt;-&gt;"</span> x[&gt;ssetunion_pri] =&gt;# <span class="fstring">"(infix 'xpipe)"</span>; 
<span class="lineno" id=line12></span>  
<span class="lineno" id=line13></span>    <span class="doccomment">input schannel type %&lt;T</span>
<span class="lineno" id=line14></span>    t[sprefixed_pri] := <span class="fstring">"%&lt;"</span> t[spower_pri] =&gt;# <span class="fstring">'`(ast_name ,_sr "ischannel" (texprs (,_2)))'</span>;
<span class="lineno" id=line15></span>  
<span class="lineno" id=line16></span>    <span class="doccomment">output schannel type %&gt;T</span>
<span class="lineno" id=line17></span>    t[sprefixed_pri] := <span class="fstring">"%&gt;"</span> t[spower_pri] =&gt;# <span class="fstring">'`(ast_name ,_sr "oschannel" (texprs (,_2)))'</span>;
<span class="lineno" id=line18></span>  
<span class="lineno" id=line19></span>    <span class="doccomment">input/output schannel type %&lt;&gt;T</span>
<span class="lineno" id=line20></span>    t[sprefixed_pri] := <span class="fstring">"%&lt;&gt;"</span> t[spower_pri] =&gt;# <span class="fstring">'`(ast_name ,_sr "ioschannel" (texprs (,_2)))'</span>;
<span class="lineno" id=line21></span>  
<span class="lineno" id=line22></span>    <span class="doccomment">duplex schannel type %&lt;INPUT%&gt;OUTPUT</span>
<span class="lineno" id=line23></span>    t[sprefixed_pri] := <span class="fstring">"%&lt;"</span> t[spower_pri] <span class="fstring">"%&gt;"</span> t[spower_pri] =&gt;# 
<span class="lineno" id=line24></span>      <span class="fstring">'`(ast_name ,_sr "duplex_schannel" (texprs (,_2 ,_4)))'</span>
<span class="lineno" id=line25></span>    ;
<span class="lineno" id=line26></span>  }
<span class="lineno" id=line27></span>  
</pre></p></div><h1 id='List_syntax_h'><img src='/share/src/web/images/minus.gif' id='List syntax' onclick='toggle(this,"List_syntax_d")' alt='+'/> 7 List syntax</h1><div id='List_syntax_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/listexpr.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> listexpr
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    <span class="doccomment">List cons, right associative.</span>
<span class="lineno" id=line4></span>    x[sarrow_pri] := x[&gt;sarrow_pri] <span class="fstring">"!"</span> x[sarrow_pri] =&gt;# 
<span class="lineno" id=line5></span>      <span class="fstring">'(binop (nos "Snoc") _3 _1)'</span>
<span class="lineno" id=line6></span>    ;
<span class="lineno" id=line7></span>  
<span class="lineno" id=line8></span>    satom := <span class="fstring">"@selector("</span> flx_ident <span class="fstring">")"</span> =&gt;# 
<span class="lineno" id=line9></span>      <span class="fstring">'''
<span class="lineno" id=line10></span>        `(ast_apply ,_sr (,(nos "selector") ,(stringof _2)))
<span class="lineno" id=line11></span>      '''</span>;
<span class="lineno" id=line12></span>  
<span class="lineno" id=line13></span>    satom := <span class="fstring">"("</span> <span class="fstring">"["</span> expr_comma_list <span class="fstring">"]"</span> <span class="fstring">")"</span> =&gt;# 
<span class="lineno" id=line14></span>      <span class="fstring">'''`(ast_apply ,_sr (,(nos "list") (ast_tuple ,_sr ,_3)))'''</span>
<span class="lineno" id=line15></span>    ; 
<span class="lineno" id=line16></span>  
<span class="lineno" id=line17></span>    satom := <span class="fstring">"@["</span> expr_comma_list  <span class="fstring">"]"</span> =&gt;# 
<span class="lineno" id=line18></span>      <span class="fstring">'''`(ast_apply ,_sr (,(nos "NSArray") (ast_tuple ,_sr ,_2)))'''</span>
<span class="lineno" id=line19></span>    ; 
<span class="lineno" id=line20></span>  
<span class="lineno" id=line21></span>  }
<span class="lineno" id=line22></span>  
<span class="lineno" id=line23></span>  
</pre></p></div><h1 id='Syntax_h'><img src='/share/src/web/images/minus.gif' id='Syntax' onclick='toggle(this,"Syntax_d")' alt='+'/> 8 Syntax</h1><div id='Syntax_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/scalar/boolexpr.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> boolexpr
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    <span class="doccomment">Boolean false.</span>
<span class="lineno" id=line4></span>    satom := <span class="fstring">"false"</span> =&gt;# <span class="fstring">"`(ast_false ,_sr)"</span>;
<span class="lineno" id=line5></span>  
<span class="lineno" id=line6></span>    <span class="doccomment">Boolean true.</span>
<span class="lineno" id=line7></span>    satom := <span class="fstring">"true"</span> =&gt;# <span class="fstring">"`(ast_true ,_sr)"</span>;
<span class="lineno" id=line8></span>  
<span class="lineno" id=line9></span>    <span class="doccomment">Logical implication.</span>
<span class="lineno" id=line10></span>    x[simplies_condition_pri] := x[&gt;simplies_condition_pri] <span class="fstring">"implies"</span> x[&gt;simplies_condition_pri] =&gt;# <span class="fstring">"(infix 'implies)"</span>;
<span class="lineno" id=line11></span>  
<span class="lineno" id=line12></span>    <span class="doccomment">Logical disjunction (or).</span>
<span class="lineno" id=line13></span>    x[sor_condition_pri] := x[sor_condition_pri] <span class="fstring">"or"</span> x[&gt;sor_condition_pri] =&gt;# <span class="fstring">"(infix 'lor)"</span>;
<span class="lineno" id=line14></span>  
<span class="lineno" id=line15></span>    <span class="doccomment">Logical conjunction (and).</span>
<span class="lineno" id=line16></span>    x[sand_condition_pri] := x[sand_condition_pri] <span class="fstring">"and"</span> x[&gt;sand_condition_pri] =&gt;# <span class="fstring">"(infix 'land)"</span>;
<span class="lineno" id=line17></span>  
<span class="lineno" id=line18></span>    <span class="doccomment">Logical negation (not).</span>
<span class="lineno" id=line19></span>    x[snot_condition_pri] := <span class="fstring">"not"</span> x[snot_condition_pri]  =&gt;# <span class="fstring">"`(ast_not ,_sr ,_2)"</span>;
<span class="lineno" id=line20></span>  
<span class="lineno" id=line21></span>    x[scomparison_pri]:= x[&gt;scomparison_pri] <span class="fstring">"\not"</span> cmp x[&gt;scomparison_pri] =&gt;# 
<span class="lineno" id=line22></span>      <span class="fstring">"`(ast_not ,_sr (binop _3 _1 _4))"</span>;
<span class="lineno" id=line23></span>  
<span class="lineno" id=line24></span>    <span class="comment">// tex logic operators</span>
<span class="lineno" id=line25></span>    x[stex_implies_condition_pri] := x[&gt;stex_implies_condition_pri]  <span class="fstring">"\implies"</span> x[&gt;stex_implies_condition_pri] =&gt;# 
<span class="lineno" id=line26></span>      <span class="fstring">"(infix 'implies)"</span>;
<span class="lineno" id=line27></span>  
<span class="lineno" id=line28></span>    x[stex_or_condition_pri] := x[stex_or_condition_pri] <span class="fstring">"\lor"</span> x[&gt;stex_or_condition_pri] =&gt;# 
<span class="lineno" id=line29></span>      <span class="fstring">"(infix 'lor)"</span>;
<span class="lineno" id=line30></span>  
<span class="lineno" id=line31></span>    x[stex_and_condition_pri] := x[stex_and_condition_pri] ( <span class="fstring">"\land"</span> x[&gt;stex_and_condition_pri])+ =&gt;# 
<span class="lineno" id=line32></span>      <span class="fstring">"(infix 'land)"</span> note <span class="fstring">"land"</span>;
<span class="lineno" id=line33></span>  
<span class="lineno" id=line34></span>    x[stex_not_condition_pri] := <span class="fstring">"\lnot"</span> x[stex_not_condition_pri]  =&gt;# <span class="fstring">"`(ast_not ,_sr ,_2)"</span>;
<span class="lineno" id=line35></span>  
<span class="lineno" id=line36></span>  
<span class="lineno" id=line37></span>    bin := <span class="fstring">"\iff"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; <span class="comment">// NOT IMPLEMENTED FIXME</span>
<span class="lineno" id=line38></span>    bin := <span class="fstring">"\impliedby"</span> =&gt;# <span class="fstring">'(nos _1)'</span>; <span class="comment">// NOT IMPLEMENTED FIXME</span>
<span class="lineno" id=line39></span>  
<span class="lineno" id=line40></span>    <span class="doccomment">Conditional expression.</span>
<span class="lineno" id=line41></span>    satom := sconditional <span class="fstring">"endif"</span> =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line42></span>  
<span class="lineno" id=line43></span>    <span class="doccomment">Conditional expression (prefix).</span>
<span class="lineno" id=line44></span>    sconditional := <span class="fstring">"if"</span> sexpr <span class="fstring">"then"</span> sexpr selse_part =&gt;#
<span class="lineno" id=line45></span>        <span class="fstring">"`(ast_cond ,_sr (,_2 ,_4 ,_5))"</span>;
<span class="lineno" id=line46></span>  
<span class="lineno" id=line47></span>        selif := <span class="fstring">"elif"</span> sexpr <span class="fstring">"then"</span> sexpr =&gt;# <span class="fstring">"`(,_2 ,_4)"</span>;
<span class="lineno" id=line48></span>  
<span class="lineno" id=line49></span>        selifs := selif =&gt;# <span class="fstring">"`(,_1)"</span>;
<span class="lineno" id=line50></span>        selifs := selifs selif =&gt;# <span class="fstring">"(cons _2 _1)"</span>;
<span class="lineno" id=line51></span>  
<span class="lineno" id=line52></span>        selse_part:= <span class="fstring">"else"</span> sexpr =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line53></span>        selse_part:= selifs <span class="fstring">"else"</span> sexpr =&gt;#
<span class="lineno" id=line54></span>            <span class="fstring">"""
<span class="lineno" id=line55></span>              (let ((f (lambda (result condthn)
<span class="lineno" id=line56></span>                (let ((cond (first condthn)) (thn (second condthn)))
<span class="lineno" id=line57></span>                  `(ast_cond ,_sr (,cond ,thn ,result))))))
<span class="lineno" id=line58></span>              (fold_left f _3 _1))
<span class="lineno" id=line59></span>            """</span>;
<span class="lineno" id=line60></span>  }
<span class="lineno" id=line61></span>  
<span class="lineno" id=line62></span>  
<span class="lineno" id=line63></span>  
</pre></p><pre class='inclusion'>
share/lib/std/strings/parser_syn.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> parser_syn
<span class="lineno" id=line3></span>  {
<span class="lineno" id=line4></span>    <span class="big_keyword" title="Define order of syntactic priority symbols">priority</span> 
<span class="lineno" id=line5></span>      palt_pri &lt;
<span class="lineno" id=line6></span>      pseq_pri &lt;
<span class="lineno" id=line7></span>      patom_pri
<span class="lineno" id=line8></span>    ;
<span class="lineno" id=line9></span>    
<span class="lineno" id=line10></span>    stmt := plibrary =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line11></span>  
<span class="lineno" id=line12></span>    plibrary := <span class="fstring">"gramlib"</span> sname <span class="fstring">"{"</span> plibentry* <span class="fstring">"}"</span> =&gt;#
<span class="lineno" id=line13></span>      <span class="fstring">"""
<span class="lineno" id=line14></span>      (let*
<span class="lineno" id=line15></span>        (
<span class="lineno" id=line16></span>          (tup `(ast_tuple ,_sr ,_4))
<span class="lineno" id=line17></span>          (v `(ast_apply ,_sr (,(nos "list") ,tup)))
<span class="lineno" id=line18></span>        )
<span class="lineno" id=line19></span>        `(ast_var_decl ,_sr ,_2 ,dfltvs none (some ,v))
<span class="lineno" id=line20></span>      )
<span class="lineno" id=line21></span>      """</span>
<span class="lineno" id=line22></span>    ; 
<span class="lineno" id=line23></span>  
<span class="lineno" id=line24></span>    plibentry := sname <span class="fstring">"="</span> pexpr[palt_pri] <span class="fstring">";"</span> =&gt;#
<span class="lineno" id=line25></span>    <span class="fstring">"""`(ast_tuple ,_sr (,(strlit _1) ,_3))"""</span>;
<span class="lineno" id=line26></span>  
<span class="lineno" id=line27></span>    sexpr := <span class="fstring">"parser"</span> <span class="fstring">"("</span> pexpr[palt_pri] <span class="fstring">")"</span> =&gt;# <span class="fstring">"_3"</span>;
<span class="lineno" id=line28></span>  
<span class="lineno" id=line29></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> pexpr[palt_pri] := <span class="fstring">"|"</span>? pexpr[&gt;palt_pri] (<span class="fstring">"|"</span> pexpr[&gt;palt_pri])+ =&gt;# 
<span class="lineno" id=line30></span>      <span class="fstring">"""`(ast_apply ,_sr (  
<span class="lineno" id=line31></span>        ,(qnoi 'Parser_synlib 'ALT)
<span class="lineno" id=line32></span>        (ast_apply ,_sr (,(noi 'list) ,(cons _2 (map second _3))))))"""</span>
<span class="lineno" id=line33></span>    ;
<span class="lineno" id=line34></span>  
<span class="lineno" id=line35></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> pexpr[pseq_pri] := pexpr[&gt;pseq_pri] (pexpr[&gt;pseq_pri])+ =&gt;# 
<span class="lineno" id=line36></span>      <span class="fstring">"""`(ast_apply ,_sr ( 
<span class="lineno" id=line37></span>        ,(qnoi 'Parser_synlib 'SEQ)
<span class="lineno" id=line38></span>        (ast_apply ,_sr (,(noi 'list) ,(cons _1 _2)))))"""</span>
<span class="lineno" id=line39></span>    ;
<span class="lineno" id=line40></span>  
<span class="lineno" id=line41></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> pexpr[patom_pri] := <span class="fstring">"("</span> pexpr[palt_pri] <span class="fstring">")"</span> =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line42></span>  
<span class="lineno" id=line43></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> pexpr[patom_pri] := String =&gt;# 
<span class="lineno" id=line44></span>      <span class="fstring">"""`(ast_apply ,_sr ( ,(qnoi 'Parser_synlib 'STR) ,_1)) """</span>
<span class="lineno" id=line45></span>    ;
<span class="lineno" id=line46></span>  
<span class="lineno" id=line47></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> pexpr[patom_pri] := <span class="fstring">"#EPS"</span> =&gt;#
<span class="lineno" id=line48></span>      <span class="fstring">"""`(ast_apply ,_sr ( ,(qnoi 'Parser_synlib 'EPS) ())) """</span>
<span class="lineno" id=line49></span>    ;
<span class="lineno" id=line50></span>  
<span class="lineno" id=line51></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> pexpr[patom_pri] := sname=&gt;#
<span class="lineno" id=line52></span>      <span class="fstring">"""`(ast_apply ,_sr ( ,(qnoi 'Parser_synlib 'NT) ,(strlit _1))) """</span>
<span class="lineno" id=line53></span>    ;
<span class="lineno" id=line54></span>  
<span class="lineno" id=line55></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> pexpr[patom_pri] := <span class="fstring">"{"</span> sexpr <span class="fstring">"}"</span> =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line56></span>  
<span class="lineno" id=line57></span>  
<span class="lineno" id=line58></span>  }
</pre></p><h2 id='Parallel_loop_grammar_h'><img src='/share/src/web/images/minus.gif' id='Parallel loop grammar' onclick='toggle(this,"Parallel_loop_grammar_d")' alt='+'/> 8.1 Parallel loop grammar</h2><div id='Parallel_loop_grammar_d' style='display:block'>
<pre class='inclusion'>
share/lib/grammar/pfor.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> pfor
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>     <span class="big_keyword" title="specify requirements">requires</span> loops, blocks;
<span class="lineno" id=line4></span>  
<span class="lineno" id=line5></span>     <span class="doccomment">Parallel For loop</span>
<span class="lineno" id=line6></span>     loop_stmt := <span class="fstring">"pfor"</span> sname <span class="fstring">"in"</span> sexpr <span class="fstring">"upto"</span> sexpr block =&gt;#
<span class="lineno" id=line7></span>      <span class="fstring">"""
<span class="lineno" id=line8></span>      (let* 
<span class="lineno" id=line9></span>        (
<span class="lineno" id=line10></span>          (ctlvar _2)
<span class="lineno" id=line11></span>          (first _4)
<span class="lineno" id=line12></span>          (last _6)
<span class="lineno" id=line13></span>          (body _7)
<span class="lineno" id=line14></span>          (int (nos "int"))
<span class="lineno" id=line15></span>          (param `(,_sr PVar ,ctlvar ,int none)) ;; kind name type defaultvalue
<span class="lineno" id=line16></span>          (params `((Satom ,param) none))               ;; parameter list with constraint
<span class="lineno" id=line17></span>          (sfunargs `(,params))                   ;; HOF list of parameter lists
<span class="lineno" id=line18></span>          (proc `(ast_lambda ,_sr (,dfltvs ,sfunargs (ast_void ,_sr) (,body))))
<span class="lineno" id=line19></span>          (call `(ast_call ,_sr ,(nos "tpfor")  (ast_tuple ,_sr (,first ,last ,proc))))
<span class="lineno" id=line20></span>        )
<span class="lineno" id=line21></span>        ;;(begin (display body) (display "\n*****\n")
<span class="lineno" id=line22></span>        call
<span class="lineno" id=line23></span>        ;;)
<span class="lineno" id=line24></span>      )
<span class="lineno" id=line25></span>      """</span>;
<span class="lineno" id=line26></span>  }
<span class="lineno" id=line27></span>  
<span class="lineno" id=line28></span>  
</pre></p></div></div><h1 id='Syntax_h'><img src='/share/src/web/images/minus.gif' id='Syntax' onclick='toggle(this,"Syntax_d")' alt='+'/> 9 Syntax</h1><div id='Syntax_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/regex/regexps.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="doccomment">Syntax for regular definitions.</span>
<span class="lineno" id=line3></span>  <span class="doccomment">Binds to library class Regdef,</span>
<span class="lineno" id=line4></span>  <span class="doccomment">which in turn binds to the binding of Google RE2.</span>
<span class="lineno" id=line5></span>  <span class="big_keyword" title="Define Scheme symbols">SCHEME</span> <span class="fstring">"""(define (regdef x) `(ast_lookup (,(noi 'Regdef) ,x ())))"""</span>;
<span class="lineno" id=line6></span>  
<span class="lineno" id=line7></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> regexps {
<span class="lineno" id=line8></span>    <span class="big_keyword" title="Define order of syntactic priority symbols">priority</span> 
<span class="lineno" id=line9></span>      ralt_pri &lt;
<span class="lineno" id=line10></span>      rseq_pri &lt;
<span class="lineno" id=line11></span>      rpostfix_pri &lt;
<span class="lineno" id=line12></span>      ratom_pri
<span class="lineno" id=line13></span>    ;
<span class="lineno" id=line14></span>  
<span class="lineno" id=line15></span>   
<span class="lineno" id=line16></span>    <span class="doccomment">Regular definition binder.</span>
<span class="lineno" id=line17></span>    <span class="doccomment">Statement to name a regular expression.</span>
<span class="lineno" id=line18></span>    <span class="doccomment">The expression may contain names of previously named regular expressions.</span>
<span class="lineno" id=line19></span>    <span class="doccomment">Defines the LHS symbol as a value of type Regdef::regex.</span>
<span class="lineno" id=line20></span>    stmt := <span class="fstring">"regdef"</span> sdeclname <span class="fstring">"="</span> sregexp[ralt_pri] <span class="fstring">";"</span> =&gt;# 
<span class="lineno" id=line21></span>      <span class="fstring">"""
<span class="lineno" id=line22></span>      `(ast_val_decl ,_sr ,(first _2) ,(second _2) (some ,(regdef "regex" )) (some ,_4))
<span class="lineno" id=line23></span>      """</span>;
<span class="lineno" id=line24></span>  
<span class="lineno" id=line25></span>    <span class="doccomment">Inline regular expression.</span>
<span class="lineno" id=line26></span>    <span class="doccomment">Can be used anywhere in Felix code.</span>
<span class="lineno" id=line27></span>    <span class="doccomment">Returns a a value of type Regdef::regex.</span>
<span class="lineno" id=line28></span>    x[sapplication_pri] := <span class="fstring">"regexp"</span> <span class="fstring">"("</span> sregexp[ralt_pri] <span class="fstring">")"</span> =&gt;# <span class="fstring">"_3"</span>;
<span class="lineno" id=line29></span>  
<span class="lineno" id=line30></span>    <span class="doccomment">Alternatives.</span>
<span class="lineno" id=line31></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sregexp[ralt_pri] := sregexp[&gt;ralt_pri] (<span class="fstring">"|"</span> sregexp[&gt;ralt_pri])+ =&gt;# 
<span class="lineno" id=line32></span>      <span class="fstring">"""`(ast_apply ,_sr (  
<span class="lineno" id=line33></span>        ,(regdef "Alts")
<span class="lineno" id=line34></span>        (ast_apply ,_sr (,(noi 'list) (ast_tuple ,_sr ,(cons _1 (map second _2)))))))"""</span>
<span class="lineno" id=line35></span>    ;
<span class="lineno" id=line36></span>  
<span class="lineno" id=line37></span>    <span class="doccomment">Sequential concatenation.</span>
<span class="lineno" id=line38></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sregexp[rseq_pri] := sregexp[&gt;rseq_pri] (sregexp[&gt;rseq_pri])+ =&gt;# 
<span class="lineno" id=line39></span>      <span class="fstring">"""`(ast_apply ,_sr ( 
<span class="lineno" id=line40></span>        ,(regdef "Seqs")
<span class="lineno" id=line41></span>        (ast_apply ,_sr (,(noi 'list) (ast_tuple ,_sr ,(cons _1 _2)))))))"""</span>
<span class="lineno" id=line42></span>    ;
<span class="lineno" id=line43></span>  
<span class="lineno" id=line44></span>  
<span class="lineno" id=line45></span>    <span class="doccomment">Postfix star (*).</span>
<span class="lineno" id=line46></span>    <span class="doccomment">Kleene closure: zero or more repetitions.</span>
<span class="lineno" id=line47></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sregexp[rpostfix_pri] := sregexp[rpostfix_pri] <span class="fstring">"*"</span> =&gt;# 
<span class="lineno" id=line48></span>      <span class="fstring">"""`(ast_apply ,_sr ( ,(regdef "Rpt") (ast_tuple ,_sr (,_1 0 -1))))"""</span>
<span class="lineno" id=line49></span>    ;
<span class="lineno" id=line50></span>  
<span class="lineno" id=line51></span>    <span class="doccomment">Postfix plus (+).</span>
<span class="lineno" id=line52></span>    <span class="doccomment">One or more repetitions.</span>
<span class="lineno" id=line53></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sregexp[rpostfix_pri] := sregexp[rpostfix_pri] <span class="fstring">"+"</span> =&gt;#
<span class="lineno" id=line54></span>      <span class="fstring">"""`(ast_apply ,_sr ( ,(regdef "Rpt") (ast_tuple ,_sr (,_1 1 -1))))"""</span>
<span class="lineno" id=line55></span>    ;
<span class="lineno" id=line56></span>  
<span class="lineno" id=line57></span>    <span class="doccomment">Postfix question mark (?).</span>
<span class="lineno" id=line58></span>    <span class="doccomment">Optional. Zero or one repetitions.</span>
<span class="lineno" id=line59></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sregexp[rpostfix_pri] := sregexp[rpostfix_pri] <span class="fstring">"?"</span> =&gt;#
<span class="lineno" id=line60></span>      <span class="fstring">"""`(ast_apply ,_sr (,(regdef "Rpt") (ast_tuple ,_sr (,_1 0 1))))"""</span>
<span class="lineno" id=line61></span>    ;
<span class="lineno" id=line62></span>  
<span class="lineno" id=line63></span>    <span class="doccomment">Parenthesis. Non-capturing group.</span>
<span class="lineno" id=line64></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sregexp[ratom_pri] := <span class="fstring">"("</span> sregexp[ralt_pri] <span class="fstring">")"</span> =&gt;# <span class="fstring">"_2"</span>;
<span class="lineno" id=line65></span>  
<span class="lineno" id=line66></span>    <span class="doccomment">Group psuedo function.</span>
<span class="lineno" id=line67></span>    <span class="doccomment">Capturing group.</span>
<span class="lineno" id=line68></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sregexp[ratom_pri] := <span class="fstring">"group"</span> <span class="fstring">"("</span> sregexp[ralt_pri] <span class="fstring">")"</span> =&gt;# 
<span class="lineno" id=line69></span>      <span class="fstring">"""`(ast_apply ,_sr ( ,(regdef "Group") ,_3))"""</span>
<span class="lineno" id=line70></span>    ;
<span class="lineno" id=line71></span>  
<span class="lineno" id=line72></span>    <span class="doccomment">The charset prefix operator.</span>
<span class="lineno" id=line73></span>    <span class="doccomment">Treat the string as a set of characters,</span>
<span class="lineno" id=line74></span>    <span class="doccomment">that is, one of the contained characters.</span>
<span class="lineno" id=line75></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sregexp[ratom_pri] := <span class="fstring">"charset"</span> String =&gt;# 
<span class="lineno" id=line76></span>      <span class="fstring">"""`(ast_apply ,_sr ( ,(regdef "Charset") ,_2))"""</span>
<span class="lineno" id=line77></span>    ;
<span class="lineno" id=line78></span>  
<span class="lineno" id=line79></span>    <span class="doccomment">The string literal.</span>
<span class="lineno" id=line80></span>    <span class="doccomment">The given sequence of characters.</span>
<span class="lineno" id=line81></span>    <span class="doccomment">Any valid Felix string can be used here.</span>
<span class="lineno" id=line82></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sregexp[ratom_pri] := String =&gt;# 
<span class="lineno" id=line83></span>      <span class="fstring">"""`(ast_apply ,_sr ( ,(regdef "String") ,_1)) """</span>
<span class="lineno" id=line84></span>    ;
<span class="lineno" id=line85></span>  
<span class="lineno" id=line86></span>    <span class="doccomment">The Perl psuedo function.</span>
<span class="lineno" id=line87></span>    <span class="doccomment">Treat the argument string expression as</span>
<span class="lineno" id=line88></span>    <span class="doccomment">a Perl regular expression, with constraints</span>
<span class="lineno" id=line89></span>    <span class="doccomment">as specified for Google RE2.</span>
<span class="lineno" id=line90></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sregexp[ratom_pri] := <span class="fstring">"perl"</span> <span class="fstring">"("</span> sexpr <span class="fstring">")"</span> =&gt;# 
<span class="lineno" id=line91></span>      <span class="fstring">"""`(ast_apply ,_sr ( ,(regdef "Perl") ,_3)) """</span>
<span class="lineno" id=line92></span>    ;
<span class="lineno" id=line93></span>  
<span class="lineno" id=line94></span>    <span class="doccomment">The regex psuedo function.</span>
<span class="lineno" id=line95></span>    <span class="doccomment">Treat the argument Felix expression of type Regdef::regex</span>
<span class="lineno" id=line96></span>    <span class="doccomment">as a regular expression.</span>
<span class="lineno" id=line97></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sregexp[ratom_pri] := <span class="fstring">"regex"</span> <span class="fstring">"("</span> sexpr <span class="fstring">")"</span> =&gt;# <span class="fstring">"_3"</span>;
<span class="lineno" id=line98></span>  
<span class="lineno" id=line99></span>    <span class="doccomment">Identifier.</span>
<span class="lineno" id=line100></span>    <span class="doccomment">Must name a previously defined variable of type Regdef:;regex.</span>
<span class="lineno" id=line101></span>    <span class="doccomment">For example, the LHS of a regdef binder.</span>
<span class="lineno" id=line102></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> sregexp[ratom_pri] := sname=&gt;# <span class="fstring">"`(ast_name ,_sr ,_1 ())"</span>;
<span class="lineno" id=line103></span>   
<span class="lineno" id=line104></span>  }
<span class="lineno" id=line105></span>  
<span class="lineno" id=line106></span>  
</pre></p></div><h1 id='String_syntax_h'><img src='/share/src/web/images/minus.gif' id='String syntax' onclick='toggle(this,"String_syntax_d")' alt='+'/> 10 String syntax</h1><div id='String_syntax_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/strings/stringexpr.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> stringexpr
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    <span class="doccomment">String subscript.</span>
<span class="lineno" id=line4></span>    x[sfactor_pri] := x[sfactor_pri] <span class="fstring">"."</span> <span class="fstring">"["</span> sexpr <span class="fstring">"]"</span> =&gt;# 
<span class="lineno" id=line5></span>      <span class="fstring">"(binop (noi 'subscript) _1 _4)"</span>;
<span class="lineno" id=line6></span>  
<span class="lineno" id=line7></span>    <span class="doccomment">String substring.</span>
<span class="lineno" id=line8></span>    x[sfactor_pri] := x[sfactor_pri] <span class="fstring">"."</span> <span class="fstring">"["</span> sexpr <span class="fstring">"to"</span> sexpr <span class="fstring">"]"</span> =&gt;# 
<span class="lineno" id=line9></span>      <span class="fstring">"`(ast_apply ,_sr (,(noi 'substring) (ast_tuple ,_sr (,_1 ,_4 ,_6))))"</span>;
<span class="lineno" id=line10></span>  
<span class="lineno" id=line11></span>    <span class="doccomment">String substring, to end of string.</span>
<span class="lineno" id=line12></span>    x[sfactor_pri] := x[sfactor_pri] <span class="fstring">"."</span> <span class="fstring">"["</span> sexpr <span class="fstring">"to"</span> <span class="fstring">"]"</span> =&gt;# 
<span class="lineno" id=line13></span>     <span class="fstring">"(binop (noi 'copyfrom) _1 _4)"</span>;
<span class="lineno" id=line14></span>  
<span class="lineno" id=line15></span>    <span class="doccomment">String substring, from start of string.</span>
<span class="lineno" id=line16></span>    x[sfactor_pri] := x[sfactor_pri] <span class="fstring">"."</span> <span class="fstring">"["</span> <span class="fstring">"to"</span> sexpr <span class="fstring">"]"</span> =&gt;# 
<span class="lineno" id=line17></span>     <span class="fstring">"(binop (noi 'copyto) _1 _5)"</span>;
<span class="lineno" id=line18></span>  }
<span class="lineno" id=line19></span>  
</pre></p></div><h1 id='ObjC_Syntax_h'><img src='/share/src/web/images/minus.gif' id='ObjC Syntax' onclick='toggle(this,"ObjC_Syntax_d")' alt='+'/> 11 ObjC Syntax</h1><div id='ObjC_Syntax_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/objc/objc.fsyn</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="define domain specific sublanguage module">syntax</span> ObjC
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>  
<span class="lineno" id=line4></span>    stmt 
<span class="lineno" id=line5></span>        := <span class="fstring">"objc-bind"</span> class_interface srequires_clause <span class="fstring">";"</span> =&gt;# <span class="fstring">'`(objc_bind_class_interface ,_sr ,_2 ,_3)'</span> 
<span class="lineno" id=line6></span>        | <span class="fstring">"objc-bind"</span> protocol_interface srequires_clause <span class="fstring">";"</span> =&gt;# <span class="fstring">'`(objc_bind_protocol_interface ,_sr ,_2 ,_3)'</span> 
<span class="lineno" id=line7></span>        ;
<span class="lineno" id=line8></span>   
<span class="lineno" id=line9></span>    class_interface 
<span class="lineno" id=line10></span>        := <span class="fstring">"@interface"</span> sname (<span class="fstring">":"</span> sname)? protocol_reference_list? instance_variables? interface_declaration* <span class="fstring">"@end"</span>
<span class="lineno" id=line11></span>           =&gt;# <span class="fstring">'`(objc_class_interface ,_2 ,_3 ,_4 ,_5 ,_6)'</span>
<span class="lineno" id=line12></span>        ;
<span class="lineno" id=line13></span>  <span class="comment">/*
<span class="lineno" id=line14></span>    class_implementation
<span class="lineno" id=line15></span>        := "@implementation" sname ":" ? instance_variables? implementation_definition* "@end"
<span class="lineno" id=line16></span>        ;
<span class="lineno" id=line17></span>  
<span class="lineno" id=line18></span>    category_interface
<span class="lineno" id=line19></span>        := "@interface" class_name "(" category_name? ")" protocol_reference_list? interface_declaration* "@end"
<span class="lineno" id=line20></span>        ;
<span class="lineno" id=line21></span>  
<span class="lineno" id=line22></span>    category_implementation
<span class="lineno" id=line23></span>        := "@implementation" sname "("  sname ")" implementation_definition* "@end"
<span class="lineno" id=line24></span>        ;
<span class="lineno" id=line25></span>  */</span>
<span class="lineno" id=line26></span>  
<span class="lineno" id=line27></span>    protocol_interface
<span class="lineno" id=line28></span>        := <span class="fstring">"@protocol"</span> sname protocol_reference_list? interface_declaration* <span class="fstring">"@end"</span>
<span class="lineno" id=line29></span>           =&gt;# <span class="fstring">'`(objc_protocol_interface ,_2 ,_3 ,_4)'</span>
<span class="lineno" id=line30></span>        ;
<span class="lineno" id=line31></span>  
<span class="lineno" id=line32></span>    class_declaration_list
<span class="lineno" id=line33></span>        := <span class="fstring">"@class"</span> snames =&gt;# <span class="fstring">'_2'</span>
<span class="lineno" id=line34></span>        ;
<span class="lineno" id=line35></span>  
<span class="lineno" id=line36></span>    protocol_reference_list
<span class="lineno" id=line37></span>        := <span class="fstring">"&lt;"</span> snames <span class="fstring">"&gt;"</span> =&gt;# <span class="fstring">'_2'</span>
<span class="lineno" id=line38></span>        ;
<span class="lineno" id=line39></span>  
<span class="lineno" id=line40></span>    instance_variables
<span class="lineno" id=line41></span>        := <span class="fstring">"{"</span> instance_variable_declaration* <span class="fstring">"}"</span> =&gt;# <span class="fstring">'_2'</span>
<span class="lineno" id=line42></span>        ;
<span class="lineno" id=line43></span>  
<span class="lineno" id=line44></span>    instance_variable_declaration
<span class="lineno" id=line45></span>        := stypeexpr sname <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(Pval ,_2 ,_1)"</span> <span class="comment">// like C: int x;!</span>
<span class="lineno" id=line46></span>        | sname <span class="fstring">":"</span> stypeexpr <span class="fstring">";"</span> =&gt;# <span class="fstring">"`(Pval ,_1 ,_3)"</span>
<span class="lineno" id=line47></span>        ;
<span class="lineno" id=line48></span>  
<span class="lineno" id=line49></span>  
<span class="lineno" id=line50></span>  <span class="comment">/*
<span class="lineno" id=line51></span>    instance_variable_declaration
<span class="lineno" id=line52></span>        := visibility_specification =&gt;# '`((objc_visibility_specification ,_1))'
<span class="lineno" id=line53></span>        | struct_declaration =&gt;# '`((objc_struct_declaration ,_1))'
<span class="lineno" id=line54></span>        | instance_variable_declaration visibility_specification =&gt;# '(append _1 (list _2))'
<span class="lineno" id=line55></span>        | instance_variable_declaration struct_declaration =&gt;# '(append _1 (list _2))'
<span class="lineno" id=line56></span>        ;
<span class="lineno" id=line57></span>  
<span class="lineno" id=line58></span>    visibility_specification
<span class="lineno" id=line59></span>        := "@private" =&gt;# '_1' 
<span class="lineno" id=line60></span>        | "@protected" =&gt;# '_1' 
<span class="lineno" id=line61></span>        | "@package" =&gt;# '_1'
<span class="lineno" id=line62></span>        | "@public" =&gt;# '_1'
<span class="lineno" id=line63></span>        ;
<span class="lineno" id=line64></span>  
<span class="lineno" id=line65></span>    struct_declaration
<span class="lineno" id=line66></span>        := sname sname ";" =&gt;# '`(objc_struct_declaration ,_1 ,_2)' // HACK: really a variable declaration
<span class="lineno" id=line67></span>        ;
<span class="lineno" id=line68></span>  */</span>
<span class="lineno" id=line69></span>  
<span class="lineno" id=line70></span>    interface_declaration
<span class="lineno" id=line71></span>        := declaration =&gt;# <span class="fstring">'_1'</span>
<span class="lineno" id=line72></span>        | property_declaration =&gt;# <span class="fstring">'_1'</span>
<span class="lineno" id=line73></span>        | method_declaration =&gt;# <span class="fstring">'_1'</span>
<span class="lineno" id=line74></span>        ;
<span class="lineno" id=line75></span>  
<span class="lineno" id=line76></span>    protocol_interface_declaration 
<span class="lineno" id=line77></span>        := method_declaration =&gt;# <span class="fstring">"_1"</span>
<span class="lineno" id=line78></span>        ;
<span class="lineno" id=line79></span>  
<span class="lineno" id=line80></span>    property_declaration
<span class="lineno" id=line81></span>        := <span class="fstring">"@property"</span> property_attributes_declaration? instance_variable_declaration=&gt;# <span class="fstring">'`(objc_property ,_sr ,_2 ,_3)'</span>
<span class="lineno" id=line82></span>        ;
<span class="lineno" id=line83></span>  
<span class="lineno" id=line84></span>    property_attributes_declaration
<span class="lineno" id=line85></span>        := <span class="fstring">"("</span> <span class="library" title="functional, singly linked list">list</span>::commalist1&lt;property_attribute&gt; <span class="fstring">")"</span> =&gt;# <span class="fstring">'_2'</span>
<span class="lineno" id=line86></span>        ;
<span class="lineno" id=line87></span>  
<span class="lineno" id=line88></span>    property_attribute
<span class="lineno" id=line89></span>        := <span class="fstring">"nonatomic"</span> =&gt;# <span class="fstring">'_1'</span>
<span class="lineno" id=line90></span>        | <span class="fstring">"readwrite"</span> =&gt;# <span class="fstring">'_1'</span>
<span class="lineno" id=line91></span>        | <span class="fstring">"readonly"</span> =&gt;# <span class="fstring">'_1'</span>
<span class="lineno" id=line92></span>        | <span class="fstring">"retain"</span> =&gt;# <span class="fstring">'_1'</span>
<span class="lineno" id=line93></span>        | <span class="fstring">"assign"</span> =&gt;# <span class="fstring">'_1'</span>
<span class="lineno" id=line94></span>        | <span class="fstring">"copy"</span> =&gt;# <span class="fstring">'_1'</span>
<span class="lineno" id=line95></span>        | <span class="fstring">"strong"</span> =&gt;# <span class="fstring">'_1'</span>
<span class="lineno" id=line96></span>        | <span class="fstring">"weak"</span> 
<span class="lineno" id=line97></span>        | sname <span class="fstring">"="</span> sname =&gt;# <span class="fstring">'`(objc_getter_ivar ,_1 ,_3)'</span> <span class="comment">//  getter ivar</span>
<span class="lineno" id=line98></span>        | sname <span class="fstring">"="</span> sname <span class="fstring">":"</span> =&gt;# <span class="fstring">'`(objc_setter ,_1 ,_3)'</span>  <span class="comment">// setter</span>
<span class="lineno" id=line99></span>        ;
<span class="lineno" id=line100></span>    method_declaration
<span class="lineno" id=line101></span>        := class_method_declaration =&gt;# <span class="fstring">'_1'</span>
<span class="lineno" id=line102></span>        | instance_method_declaration =&gt;# <span class="fstring">'_1'</span>
<span class="lineno" id=line103></span>        ;
<span class="lineno" id=line104></span>  
<span class="lineno" id=line105></span>    class_method_declaration
<span class="lineno" id=line106></span>        := <span class="fstring">"+"</span> method_type method_selector <span class="fstring">";"</span>  
<span class="lineno" id=line107></span>           =&gt;# <span class="fstring">'`(objc_class_method_declaration ,_sr ,_2 ,_3)'</span>
<span class="lineno" id=line108></span>        ;
<span class="lineno" id=line109></span>  
<span class="lineno" id=line110></span>    instance_method_declaration
<span class="lineno" id=line111></span>        := <span class="fstring">"-"</span> method_type method_selector <span class="fstring">";"</span>
<span class="lineno" id=line112></span>           =&gt;# <span class="fstring">'`(objc_instance_method_declaration ,_sr ,_2 ,_3)'</span>
<span class="lineno" id=line113></span>        ;
<span class="lineno" id=line114></span>  
<span class="lineno" id=line115></span>    method_selector
<span class="lineno" id=line116></span>        := sname =&gt;# <span class="fstring">'`(objc_method_selector_name  ,_1)'</span>
<span class="lineno" id=line117></span>        | keyword_selector =&gt;# <span class="fstring">'`(objc_keyword_selector  ,_1)'</span>
<span class="lineno" id=line118></span>        | keyword_selector <span class="fstring">","</span> <span class="fstring">"..."</span> =&gt;# <span class="fstring">'`(objc_keyword_selector_ellipsis  ,_1)'</span>
<span class="lineno" id=line119></span>        ;
<span class="lineno" id=line120></span>  
<span class="lineno" id=line121></span>    keyword_selector
<span class="lineno" id=line122></span>        := keyword_declarator+ =&gt;# <span class="fstring">"_1"</span>;
<span class="lineno" id=line123></span>  
<span class="lineno" id=line124></span>    keyword_declarator
<span class="lineno" id=line125></span>        := sname <span class="fstring">":"</span> method_type =&gt;# <span class="fstring">'`(objc_keyword_declarator  ,_1 ,_3)'</span>; 
<span class="lineno" id=line126></span>  
<span class="lineno" id=line127></span>    method_type
<span class="lineno" id=line128></span>        := <span class="fstring">"("</span> stype <span class="fstring">")"</span> =&gt;# <span class="fstring">'_2'</span>;
<span class="lineno" id=line129></span>  
<span class="lineno" id=line130></span>  
<span class="lineno" id=line131></span>  
<span class="lineno" id=line132></span>  <span class="comment">// TEST HACKS</span>
<span class="lineno" id=line133></span>  
<span class="lineno" id=line134></span>    implementation_definition := <span class="fstring">"IMPLEMENTATION_DEFINITION"</span>;
<span class="lineno" id=line135></span>    protocol_interace_declaration := <span class="fstring">"PROTOCOL_INTERFACE_DECLARATION"</span>;
<span class="lineno" id=line136></span>  } <span class="comment">// end syntax ObjC</span>
<span class="lineno" id=line137></span>  
<span class="lineno" id=line138></span>  
<span class="lineno" id=line139></span>  
</pre></p></div><!--Main Content Body End-->

          </div> <!-- rightpanel contents end -->
          <hr>
        </span> <!-- rightpanel end -->

        <span id="panemover" style="cursor:col-resize;"
         onmousedown="dragStart(event, 'left', 'right'); return false;"
         onmousemove="drag(event, 'left', 'right');"
         onmouseout="dragRelease();"
         onmouseup="dragRelease();"
        >
        </span> <!-- panemover end -->
      </div> <!-- bottom panel end -->
    </div> <!-- container end -->
</body></html>

