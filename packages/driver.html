<html><head>
<style type="text/css">
body {margin:3%; }
h1 {color:gray; font-size:120%;}
h2 {color:gray; font-size:105%;}
h3 {font-size:100%;}
h4 {font-size:95%;}
h5 {font-size:95%;}
span.fstring {color:darkblue; font-style:italic; }
span.comment {font-family:arial; color:blue; font-style:italic; }
span.doccomment {font-family:arial; color:green; font-style:italic; }
span.big_keyword {color:#FF1010; }
span.small_keyword {color:#802040; }
span.qualifier {color:#A02020; }
span.library {color:#A02000; }
span.ctor {color:#406020; }
span.hack {color:#66DD00; }
span.preproc {color:#005500; }
span.embedded_c{background-color:#DDDDDD; }
span.fpc_fieldname {color:#DD0000; }
span.lineno {color:#101010; background-color:#E0E0E0; font-size:80%; font-family:"courier",monospace; font-style:normal; }
pre.flxbg {background-color:#A0FFA0; color:black; padding:2px; box-shadow:5px 5px 2px #807080; }
pre.uncheckedflxbg {background-color:#D0D0D0; color:black; padding:2px; box-shadow:5px 5px 2px #807080; }
pre.cppbg {background-color:#80FF80; color:black; }
pre.prefmtbg {background-color:#D0D0D0; color:black; }
pre.expected {background-color:#E0FF80; color:black; }
pre.input {background-color:#E08080; color:black; }
pre.inclusion {background-color:#D070D0; color:black; }
code.inclusion {background-color:#D070D0; color:black; }
.obsolete { background-color:#FFEFEF; font-size: small; color:black; }
.future { background-color:#FF8080; font-size: small; color:black; }
.implementation_detail { background-color:#E0E0E0; font-size: small; color:black;  }
.bug { background-color:#FFE0E0; font-size: small; color:black; }
.fixed{ background-color:#FFE0E0; font-size: small; color:black; }
.done { background-color:#FFE0E0; font-size: small; color:black; }
.caveat { background-color:#FF8080; color:black; }
</style>
<title>Driver and Dynamic Linker</title></head><body>
<style>
body {margin:3%; font-family: sans-serif; }
h1 {color:black; font-size:120%; border-bottom: 2px solid #ddd; padding: 0 0 3px 0;}
h2 {color:#202020; font-size:105%;}
h3 {font-size:100%;}
h4 {font-size:95%;}
h5 {font-size:95%;}
span.fstring {color:darkblue; font-style:italic; }
span.comment {font-family:arial; color:blue; font-style:italic; }
span.doccomment {font-family:arial; color:green; font-style:italic; }
span.big_keyword {color:#FF1010; }
span.small_keyword {color:#802040; }
span.qualifier {color:#A02020; }
span.library {color:#A02000; }
span.ctor {color:#406020; }
span.hack {color:#66DD00; }
span.preproc {color:#005500; }
span.embedded_c{background-color:#DDDDDD; }
span.fpc_fieldname {color:#DD0000; }
span.lineno {color:#101010; background-color:#E0E0E0; font-size:80%; font-family:"courier",monospace; font-style:normal; }
pre { border: 1px solid #ccc; color: black; box-shadow:3px 3px 2px rgba(0,0,0,0.1); padding:2px; }
pre.flxbg {background-color:#C2FDC2; box-shadow:3px 3px 2px rgba(0,0,0,0.1) }
pre.uncheckedflxbg {background-color:#eee; box-shadow:3px 3px 2px rgba(0,0,0,0.1); }
pre.cppbg {background-color:#C2FDC2; }
pre.prefmtbg {background-color:#F1F1F1; }
pre.expected {background-color:hsla(74,94%,88%,1); }
pre.input {background-color:hsla(20,94%,88%,1); }
pre.inclusion {
    font-family: Arial;
    font-weight: normal;
    font-size: 0.9em;
    color: #555;
    border: none;
    box-shadow: none;
    text-align: right;
    margin: -7px 11px -12px 0;
    padding: 0;
    background-color:#fafafa;
}
code.inclusion {background-color:#D070D0; color:black; }
.obsolete { background-color:#FFEFEF; font-size: small; color:black; }
.future { background-color:#FF8080; font-size: small; color:black; }
.implementation_detail { background-color:#E0E0E0; font-size: small; color:black;  }
.bug { background-color:#FFE0E0; font-size: small; color:black; }
.fixed{ background-color:#FFE0E0; font-size: small; color:black; }
.done { background-color:#FFE0E0; font-size: small; color:black; }
.caveat { background-color:hsla(0,100%,91%,1); color:black; padding: 0.6em; }
.container {
  position: fixed;
  top:0px;
  left:0px;
  height : 100%;
  width: 100%;
  background-color: grey;
  margin: 0px;
  padding: 0px;
  border-width: 0px;
  color: #404040;
}
.maincontent {
  padding:4px;
  padding-left:8px;
  line-height:1.3em;
  color:#404040; background-color:#fafafa;
}
.maincontent h1 { margin-left:-8px; position: relative; font-family: georgia, serif; font-size: 1.8em; font-weight: normal; }
.maincontent h2 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent h3 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent h4 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent code { color:#902030; }
.toppanel {
  position:absolute; left:0px; top:0px; height:20px; right:0px;
  background-color: #e0e0e0;
}
.bottompanel {
  position:absolute; left:0px; top:22px; bottom:0px; right:0px;
  background-color: #fafafa;
  font-size:14px;
}
.leftpanel {
  position:absolute; left:0px; top:0px; bottom:0px; width: 150px;
  background-color: #eaeaea; overflow: auto;
}
.rightpanel {
  position:absolute; right: 0px; left:160px; top:0px; bottom: 0px;
  background-color: #fafafa; overflow: auto;
}
.divider {
  position:absolute; left: 150px; top:0px; bottom:0px;
  background-color: black; width:2px;
  box-shadow: 0 0 8px #000;
}

#panemover {
    position:absolute;
    left: 150px;
    width : 10px;
    top: 0px;
    bottom: 0px;
    opacity: 0.3;
    cursor:col-resize;
}

div.m {
    margin: 0px;
    padding:0px;
    border-width:2px;
    border-color: green;
}

div.m1 {
    background-color: #86E870;
    border-style:outset;
    border-color:#ccc;
    border-width:2px 0;
    font-size:90%;
    padding: 1px 0 2px 10px;
}

div.m2 {
    background-color: #70C070;
    padding-left:15px;
    padding-top:2px;
    border-style:outset;
    border-color:green;
    border-width:0 0 1px 0;
    font-size:80%;
}

div.m1:hover, div.m2:hover {
    background-color: white;
}

#leftmargintoc a {
    text-decoration: none;
    color: #404040;
}
</style>

<style>
div.m {
    margin: 0px;
    padding:0px;
    border-width:2px;
    border-color: green;
}

div.m1 {
    background-color: #86E870;
    border-style:outset;
    border-color:#ccc;
    border-width:2px 0;
    font-size:90%;
    padding: 1px 0 2px 10px;
}

div.m2 {
    background-color: #70C070;
    padding-left:15px;
    padding-top:2px;
    border-style:outset;
    border-color:green;
    border-width:0 0 1px 0;
    font-size:80%;
}

div.m1:hover, div.m2:hover {
    background-color: white;
}

#leftmargintoc a {
    text-decoration: none;
    color: #404040;
}


</style>

    <script async="true">
      function dragStart(e, left, right){
        document.getElementById("panemover").style.width="70%";
        document.getElementById("panemover").style.left="50px";
        mousedown = true;
        x = e.clientX
        dragOffsetLeft =
          document.getElementById(left).getBoundingClientRect().right -
          document.getElementById(left).getBoundingClientRect().left -
          x
        ;
        dragOffsetDivider= document.getElementById("divider").getBoundingClientRect().left - x;
        dragOffsetRight = document.getElementById(right).getBoundingClientRect().left - x;
      }
      function dragRelease(){
        document.getElementById('panemover').style.width = '10px';
        document.getElementById('panemover').style.left = document.getElementById('divider').offsetLeft + 'px';
        mousedown = false;
      }
      function drag(e, left, right){
        if(!mousedown){return}
        x = e.clientX
        tmpLeft = dragOffsetLeft + x
        tmpDivider= dragOffsetDivider + x
        tmpRight = dragOffsetRight + x
        document.getElementById(left).style.width= tmpLeft + 'px';
        document.getElementById("divider").style.left= tmpDivider + 'px';
        document.getElementById(right).style.left = tmpRight + 'px';
      };
    </script>

<script type="text/javascript">

  function mexpand(id)
  {
    var n = document.getElementById(id).style;
    n.display = "block";
  }

  function mcollapse(id)
  {
    var n = document.getElementById(id).style;
    n.display = "none";
  }

  var counter_max = 0;
  function mshow(id,loc)
  {
    var i;
    for(i=1; i<=counter_max; ++i)
      mcollapse("menu"+String(i));
    mexpand(id);
    window.location.replace(loc);
  }
</script>

<script type="text/javascript">

function expand(but,id)
{
  var n = document.getElementById(id).style;
  var button = document.getElementById(but);
  button.src = "/share/src/web/images/minus.gif";
  button.alt = "-";
  n.display = "block";
}
function collapse(but,id)
{
  var n = document.getElementById(id).style;
  var button = document.getElementById(but);
  button.src = "/share/src/web/images/plus.gif";
  button.alt = "+";
  n.display = "none";
}
function toggle(button,id)
{
  var n = document.getElementById(id).style;
  if (n.display == "none")
  {
    button.src = "/share/src/web/images/minus.gif";
    button.alt = "-";
    n.display = "block";
  }
  else
  {
    button.src = "/share/src/web/images/plus.gif";
    button.alt = "+";
    n.display = "none";
  }
}
var allbuttons = [
"Driver <code>flx_run</code>",
"Entry points",
"Implementation",
"<code>init_ptr_create_async_hooker</code> callback #1",
"<code>get_flx_args_config</code> callback",
"The <code>modulenameoffilename</code> helper function.",
"<code>link_library</code> callback #3",
"Mainline",
"Dynamic link loader with async support",
"Static link loader with async support",
"Dynamic link loader with async support",
"Static link loader without async support",
"Traditional Mainline with async support",
"Traditional Mainline without async support",
"Driver executable config",
"Build Code"
];
function expand_all(dummy)
{
  for (i in allbuttons)
  {
    expand(allbuttons[i], allbuttons[i]+"_d");
  }
}
function collapse_all(dummy)
{
  for (i in allbuttons)
  {
    collapse(allbuttons[i], allbuttons[i]+"_d");
  }
}
</script>

<script>
function mouseover(id)
{
  var elt = document.getElementById(id);
  elt.style.display="none";
  var elt2 = document.getElementById(id+"_mo");
  elt2.style.display="inline";
}

function mouseout(id)
{
  var elt = document.getElementById(id+"_mo");
  elt.style.display="none";
  var elt2 = document.getElementById(id);
  elt2.style.display="inline";
}

</script>
<script> function nop(dummy) {} </script>
    <div class="container">
      <div class="toppanel">
    <!--Main Content top navbar-->
<span style="position:relative; bottom:6px"
  onmouseover="mouseover('expand')"
  onmouseout="mouseout('expand')"
  onclick="expand_all('expand')"
  ><span id="expand"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:blue;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Expand</text></svg></span><span id="expand_mo" style="display:none"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:red;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Expand</text></svg></span></span><span style="position:relative; bottom:6px"
  onmouseover="mouseover('collapse')"
  onmouseout="mouseout('collapse')"
  onclick="collapse_all('collapse')"
  ><span id="collapse"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:blue;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Collapse</text></svg></span><span id="collapse_mo" style="display:none"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:red;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Collapse</text></svg></span></span>    <!--Main Content top navbar End-->

      </div> <!-- toppanel end -->
      <div class="bottompanel">
        <span id="divider" class="divider"></span>

        <span id="left" class="leftpanel" >
          <div class="menucontent">
  <!--Left Margin Toc-->
  <div id="leftmargintoc">
    <!--Left Margin Toc Main Contents-->
      <div class=m1 onclick="mshow('menu1','#Driver <code>flx_run</code>_h')"> <a href="#Driver_<code>flx_run</code>_h">Driver <code>flx_run</code></a></div>
      <div class=sm id=menu1>
      <div class=m2><a href="#Entry_points_h">Entry points</a></div>
      <div class=m2><a href="#Implementation_h">Implementation</a></div>
      <div class=m2><a href="#<code>init_ptr_create_async_hooker</code>_callback_#1_h"><code>init_ptr_create_async_hooker</code> callback #1</a></div>
      <div class=m2><a href="#<code>get_flx_args_config</code>_callback_h"><code>get_flx_args_config</code> callback</a></div>
      <div class=m2><a href="#<code>link_library</code>_callback_#3_h"><code>link_library</code> callback #3</a></div>
      <div class=m2><a href="#Mainline_h">Mainline</a></div>
      <div class=m2><a href="#Dynamic_link_loader_with_async_support_h">Dynamic link loader with async support</a></div>
      <div class=m2><a href="#Static_link_loader_with_async_support_h">Static link loader with async support</a></div>
      <div class=m2><a href="#Dynamic_link_loader_with_async_support_h">Dynamic link loader with async support</a></div>
      <div class=m2><a href="#Static_link_loader_without_async_support_h">Static link loader without async support</a></div>
      <div class=m2><a href="#Traditional_Mainline_with_async_support_h">Traditional Mainline with async support</a></div>
      <div class=m2><a href="#Traditional_Mainline_without_async_support_h">Traditional Mainline without async support</a></div>
      </div>
      <div class=m1 onclick="mshow('menu2','#Driver executable config_h')"> <a href="#Driver_executable_config_h">Driver executable config</a></div>
      <div class=sm id=menu2>
      </div>
      <div class=m1 onclick="mshow('menu3','#Build Code_h')"> <a href="#Build_Code_h">Build Code</a></div>
      <div class=sm id=menu3>
      </div>
    <script>counter_max=3;</script>
  </div>
  <!--End Left Margin Toc-->

          </div> <!-- leftpanel contents end -->
        </span> <!-- leftpanel end -->

        <span id="right" class="rightpanel">
          <div class="maincontent">
<!--Main Content Body-->
<h1 id='Driver_<code>flx_run</code>_h'><img src='/share/src/web/images/minus.gif' id='Driver <code>flx_run</code>' onclick='toggle(this,"Driver_<code>flx_run</code>_d")' alt='+'/> 1 Driver <code>flx_run</code></h1><div id='Driver_<code>flx_run</code>_d' style='display:block'>
<h2 id='Entry_points_h'><img src='/share/src/web/images/minus.gif' id='Entry points' onclick='toggle(this,"Entry_points_d")' alt='+'/> 1.1 Entry points</h2><div id='Entry_points_d' style='display:block'>
<p>This header specifies the interface for two entry points, <code>felix_run</code>
and <code>felix_arun</code>. The first provides a driver function that refuses
to support asynchronous I/O, and is suitable for embedded systems.
The second provides asynchronous I/O support which includes support
for real time clock and sockets.
</p><p>Only one of these entry points will actually be defined in a given
translation unit.
</p><pre class='inclusion'>
share/lib/rtl/flx_run.hpp</pre>
<p><pre class='cppbg'><span class="qualifier">int</span> felix_run(<span class="qualifier">int</span>, <span class="qualifier">char</span>**);
<span class="qualifier">int</span> felix_arun(<span class="qualifier">int</span>, <span class="qualifier">char</span>**);
</pre></p></div><h2 id='Implementation_h'><img src='/share/src/web/images/minus.gif' id='Implementation' onclick='toggle(this,"Implementation_d")' alt='+'/> 1.2 Implementation</h2><div id='Implementation_d' style='display:block'>
<p> 
</p><p>This file contains FOUR separate sets of four callback functions
and a mainline. 
</p><p>It is designed to be included in four stub files which set the
four combinations, so common code can be shared.
</p><p>These are conditioned by two boolean macros:
</p><p>FLX_BUILD_FOR_STATIC_LINK:
  if defined, we're static linking
  if not defined, we're dynamic linking
</p><p>FLX_SUPPORT_ASYNC:
  if defined 0, async support is not provided
  if defined non-zero, async support is provided
  this macro must be defined
</p><p>In addition we notice these macros too:
</p><p>FLX_WIN32:
  if defined non-zero, we're running Win32
</p><p>FLX_HAVE_MSVC:
  if defined non-zero we're using MSVC++ compiler and SDK
  used to decide the name of the async library dll
</p><p>NOTE: The macro "FLX_STATIC_LINK" will ALSO be defined by the
toolchain. This is UNRELATED to the FLX_BUILD_FOR_STATIC_LINK
macro. The FLX_STATIC_LINK macro says that all unresolved
externals linking the flx_(a)_run executables are to be
found in libraries statically. These executables ALWAYS
dynamically load Felix DLLs using dlopen/LoadLibrary.
</p><p>But the exes themselves are fully statically linked 
(except for C/C++ standard libraries of course).
The flx_(a)run exes are univeral drivers. To make
them the macro FLX_BUILD_FOR_STATIC_LINK must be *undefined*.
</p><p>The same source code is ALSO used to statically link your program
into an executable. In this case again, all the object files
have to be FLX_STATIC_LINK however this time we get code
produced with FLX_BUILD_FOR_STATIC link defined.
</p><p>Note that a flx_run that satisfies its externals from a DLL
would also be possible but we don't build one of them.
That would be PATH dependent, and the PATH might be *different*
to the one the client DLL program requires.
</p><pre class='inclusion'>
share/src/flx_drivers/flx_run.include</pre>
<p><pre class="prefmtbg">#include &lt;cstdlib&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &lt;string&gt;

#include "flx_world.hpp"
#include "flx_async_world.hpp"
#include "flx_ts_collector.hpp"
#include "flx_eh.hpp"

using namespace std;
using namespace flx::rtl;
using namespace flx::run;

// non async drivers don't depend on faio&lt;-demux&lt;-winsock
// and so aren't linked with mswsock and ws2_32
// Cygwin doesn't use windows sockets either
#if !FLX_CYGWIN &amp;&amp; FLX_WIN32 &amp;&amp; FLX_SUPPORT_ASYNC
  #include "demux_iocp_demuxer.hpp"
  // needed to perform win socket io (calls WSAInit). Must happen
  // before iocp_demuxer is instantiated and (I assume) happen
  // only once.
  // JS: No, it can be called any number of times, provided
  // the destructor WSACleanup is called same number of times
  // Use of this RAII object ensures WSAinit/Cleanup calls balance.
  // RF: Still has to happen before any socket calls. Putting it in
  // the async object which is created on demand is already too late.
  // If that's a problem then any socket creation calls would have to
  // gratuitously make async calls.
  flx::demux::winsock_initer wsinit;
#endif

// Actually on Cygwin it might be cygflx_async_dynamic .. not sure
#if !FLX_CYGWIN &amp;&amp; FLX_HAVE_MSVC
   #define FLX_ASYNC_DLL_NAME "flx_async_dynamic"
#else
   #define FLX_ASYNC_DLL_NAME "libflx_async_dynamic"
#endif

#ifdef FLX_BUILD_FOR_STATIC_LINK
extern "C" void *flx_main;
extern void *static_create_thread_frame;
extern void *static_flx_start;
#endif

namespace flx { namespace run {

</pre></p></div><h2 id='<code>init_ptr_create_async_hooker</code>_callback_#1_h'><img src='/share/src/web/images/minus.gif' id='<code>init_ptr_create_async_hooker</code> callback #1' onclick='toggle(this,"<code>init_ptr_create_async_hooker</code>_callback_#1_d")' alt='+'/> 1.3 <code>init_ptr_create_async_hooker</code> callback #1</h2><div id='<code>init_ptr_create_async_hooker</code>_callback_#1_d' style='display:block'>
<p>CALLBACK #1 init_ptr_create_async_hooker
</p><p>This is a really ugly piece of hackery!
</p><p>General Felix provides async I/O which is loaded
and initialised on demand, i.e. on the first use.
</p><p>This is done so programs not doing socket or timer I/O
don't spawn an extra thread, and programs which do 
do not spawn it prematurely.
</p><p>Therefore the asynchronous I/O subsystem is initially
represented by a NULL pointer. When its services are 
required, the shared library providing them is dynamically
loaded by name, and the service started.
</p><p>However if static linkage is being used, the code is linked
in statically instead. In this case, the load step can
be skipped, but the service must still be started on demand.
</p><p>Furthermore, Felix provides two drivers, flx_run and flx_arun.
The former driver does not permit any asynchronous I/O.
This is useful on a platform where we cannot provide these
services, and it's also useful if we want to physically
guarantee that such services cannot be run.
</p><p>We represent these options by using two pointers.
One pointer contains a function will initialises the other.
The first pointer represents the service creator,
and the second the actual service.
</p><p>If the creator is NULL, the service can never be started.
This is the variable ptr_create_async_hooker in the config.
It is set to zero if async support is disabled by conditional
compilation of this driver code, used to produce flx_run,
the restricted version of Felix.
</p><p>If async is to be supported, then if we're static linking
we set the pointer to the service initialiser create_async_hooker
which has to have been statically linked in.
</p><p>If we're dynamic linking, we load the shared library FLX_ASYNC_DLL_NAME
dynamically, and use dlsym() or GetProcAddress() to fetch
the service creator function from its string name. 
</p><pre class='inclusion'>
share/src/flx_drivers/flx_run.include</pre>
<p><pre class="prefmtbg">
void init_ptr_create_async_hooker(flx_config *c, bool debug_driver) {
#if !FLX_SUPPORT_ASYNC
  if(debug_driver)
    fprintf(stderr,"[flx_run.include]: FLX_SUPPORT_ASYNC FALSE\n");
  c-&gt;ptr_create_async_hooker = 0;
#else
  c-&gt;ptr_create_async_hooker = create_async_hooker;
  if(debug_driver)
    fprintf(stderr,"[flx_run.include]: FLX_SUPPORT_ASYNC TRUE, create_async_hooker = %p\n", create_async_hooker);
#ifndef FLX_BUILD_FOR_STATIC_LINK
  // Try to dynamically load the felix asynchronous library

  if(debug_driver)
    fprintf(stderr,"[flx_run.include]: dymamic_link: trying to load %s\n",FLX_ASYNC_DLL_NAME);

  FLX_LIBHANDLE async_lib = ::flx::dynlink::flx_load_module_nothrow(FLX_ASYNC_DLL_NAME);

  // Error out if we couldn't load the library.
  if (async_lib == FLX_NOLIBRARY) {
    fprintf(stderr,
      "[flx_run.include]: dynamic_link: Unable to find module '%s'\n",FLX_ASYNC_DLL_NAME);
    exit(1);
  }
  // debug only ..
  else {
    if (debug_driver)
      fprintf(stderr, "[flx_run.include]: dynamic_link: module '%s' loaded!\n",FLX_ASYNC_DLL_NAME);
  }

  // Get the hooker function
  c-&gt;ptr_create_async_hooker =
    (create_async_hooker_t*)FLX_DLSYM(async_lib, create_async_hooker);

  // Error out if we couldn't find the hooker function in the
  // library.
  if (c-&gt;ptr_create_async_hooker == NULL) {
    fprintf(stderr,
      "[flx_run.include]: dynamic_link: Unable to find symbol 'create_async_hooker' in module "
      "'%s'\n",FLX_ASYNC_DLL_NAME);
    exit(1);
  }
  // debug only
  else {
    if (debug_driver)
      fprintf(stderr, "[flx_run.include]: dynamic_link: found 'create_async_hooker'!\n");
  }
#else
  if(debug_driver)
    fprintf(stderr,"[flx_run.include]: static_link: 'create_async_hooker' SHOULD BE LINKED IN\n");
#endif
#endif
}

</pre></p></div><h2 id='<code>get_flx_args_config</code>_callback_h'><img src='/share/src/web/images/minus.gif' id='<code>get_flx_args_config</code> callback' onclick='toggle(this,"<code>get_flx_args_config</code>_callback_d")' alt='+'/> 1.4 <code>get_flx_args_config</code> callback</h2><div id='<code>get_flx_args_config</code>_callback_d' style='display:block'>
<p>CALLBACK #2: get_flx_args_config #2
</p><p>Purpose: grabs program arguments.
Prints help if statically linked.
</p><p>Static and dynamic linked programs have arguments 
in different slots of argv because the mainline for
dynamic linkage is actually flx_run executable whereas
for static linkage this is the executable.
</p><p>So dynamic linked programs have an extra argument
which has to be skipped for compatibility of static
and dynamic linkage.
</p><pre class='inclusion'>
share/src/flx_drivers/flx_run.include</pre>
<p><pre class="prefmtbg">int get_flx_args_config(int argc, char **argv, flx_config *c) {
#ifndef FLX_BUILD_FOR_STATIC_LINK
  c-&gt;static_link = false;
  if (argc&lt;2)
  {
    printf("usage: flx_run [--debug] dll_filename options ..\n");
    printf("  environment variables (numbers can be decimals):\n");
    printf("  FLX_DEBUG               # enable debugging traces (default off)\n");
    printf("  FLX_DEBUG_ALLOCATIONS   # enable debugging allocator (default FLX_DEBUG)\n");
    printf("  FLX_DEBUG_COLLECTIONS   # enable debugging collector (default FLX_DEBUG)\n");
    printf("  FLX_REPORT_COLLECTIONS  # report collections (default FLX_DEBUG)\n");
    printf("  FLX_DEBUG_THREADS       # enable debugging collector (default FLX_DEBUG)\n");
    printf("  FLX_DEBUG_DRIVER        # enable debugging driver (default FLX_DEBUG)\n");
    printf("  FLX_FINALISE            # whether to cleanup on termination (default NO)\n");
    printf("  FLX_GC_FREQ=n           # how often to call garbage collector (default 1000)\n");
    printf("  FLX_MIN_MEM=n           # initial memory pool n Meg (default 10)\n");
    printf("  FLX_MAX_MEM=n           # maximum memory n Meg (default -1 = infinite)\n");
    printf("  FLX_FREE_FACTOR=n.m     # reset FLX_MIN_MEM to actual usage by n.m after gc (default 1.1) \n");
    printf("  FLX_ALLOW_COLLECTION_ANYWHERE # (default yes)\n");
    return 1;
  }
  c-&gt;filename = argv[1];
  c-&gt;flx_argv = argv+1;
  c-&gt;flx_argc = argc-1;
  c-&gt;debug = (argc &gt; 1) &amp;&amp; (strcmp(argv[1], "--debug")==0);
  if (c-&gt;debug)
  {
    if (argc &lt; 3)
    {
      printf("usage: flx_run [--debug] dll_filename options ..\n");
      return 1;
    }
    c-&gt;filename = argv[2];
    --c-&gt;flx_argc;
    ++c-&gt;flx_argv;
  }
#else
  c-&gt;static_link = true;
  c-&gt;filename = argv[0];
  c-&gt;flx_argv = argv;
  c-&gt;flx_argc = argc;
  c-&gt;debug = false;

//  printf("Statically linked Felix program running\n");
#endif
  return 0;
}

</pre></p><h3 id='The_<code>modulenameoffilename</code>_helper_function._h'><img src='/share/src/web/images/minus.gif' id='The <code>modulenameoffilename</code> helper function.' onclick='toggle(this,"The_<code>modulenameoffilename</code>_helper_function._d")' alt='+'/> 1.4.1 The <code>modulenameoffilename</code> helper function.</h3><div id='The_<code>modulenameoffilename</code>_helper_function._d' style='display:block'>
<p>A helper routine for finding the module name when
static linking.
</p><p>Static link executables get their full pathname in argv[0].
This has to be parsed to get the module name which is then
set into the library linkage object.
</p><p>For dynamic link programs the library name is passed to
the library linkage loader function, which does the parsing
itself.
</p><p>This is a hack. It should be done in the library linkage class.
</p><pre class='inclusion'>
share/src/flx_drivers/flx_run.include</pre>
<p><pre class="prefmtbg">#ifdef FLX_BUILD_FOR_STATIC_LINK
static ::std::string modulenameoffilename(::std::string const &amp;s)
{
  ::std::size_t i = s.find_last_of("\\/");
  ::std::size_t j = s.find_first_of(".",i+1);
  return s.substr (i+1,j-i-1);
}
#endif


</pre></p></div></div><h2 id='<code>link_library</code>_callback_#3_h'><img src='/share/src/web/images/minus.gif' id='<code>link_library</code> callback #3' onclick='toggle(this,"<code>link_library</code>_callback_#3_d")' alt='+'/> 1.5 <code>link_library</code> callback #3</h2><div id='<code>link_library</code>_callback_#3_d' style='display:block'>
<p>CALLBACK #3: link_library
</p><p>This function sets up the entry points for either
a static or dynamic link program. 
</p><p>For static link,
we provide the addresses of the compiler generated
static link thunks. These are variables containing
the actual entry points.
</p><p>For dynamic link, we actually load the library and
then use dlsym() or GetProcAddress() to find the
entry points.
</p><p>Once this routine is done, the flx_dynlink_t object is
in the same state irrespective of linkage model.
</p><p>Note the asymmetric encoding: static link uses a dedicated
static link only constructor form. The dynamic link uses
a default constructor and then an initialisation method.
There's no good reason for this now because I added a
static_link() method (although it doesn't check for NULLs).
</p><pre class='inclusion'>
share/src/flx_drivers/flx_run.include</pre>
<p><pre class="prefmtbg">::flx::dynlink::flx_dynlink_t *link_library(flx_config *c, ::flx::gc::collector::gc_profile_t *gcp) {
  ::flx::dynlink::flx_dynlink_t* library;
#ifdef FLX_BUILD_FOR_STATIC_LINK
  library = new (*gcp, ::flx::dynlink::flx_dynlink_ptr_map, false) ::flx::dynlink::flx_dynlink_t(
      modulenameoffilename(c-&gt;filename),
      (::flx::dynlink::thread_frame_creator_t)static_create_thread_frame,
      (::flx::dynlink::start_t)static_flx_start,
      (::flx::dynlink::main_t)&amp;flx_main,
      c-&gt;debug_driver
   );
#else
  library = new (*gcp, ::flx::dynlink::flx_dynlink_ptr_map, false) ::flx::dynlink::flx_dynlink_t(c-&gt;debug_driver);
  library-&gt;dynamic_link(c-&gt;filename);
#endif
  return library;
}

}} // namespaces

</pre></p></div><h2 id='Mainline_h'><img src='/share/src/web/images/minus.gif' id='Mainline' onclick='toggle(this,"Mainline_d")' alt='+'/> 1.6 Mainline</h2><div id='Mainline_d' style='display:block'>
<pre class='inclusion'>
share/src/flx_drivers/flx_run.include</pre>
<p><pre class="prefmtbg">int FELIX_MAIN (int argc, char** argv)
{
//fprintf(stderr,"felix_run=FELIX_MAIN starts\n");
  int error_exit_code = 0;
  flx_config *c = new flx_config(link_library, init_ptr_create_async_hooker, get_flx_args_config);
// WINDOWS CRASHES HERE (the constructor runs)
//fprintf(stderr,"flx_config created\n");
  flx_world *world=new flx_world(c);
//fprintf(stderr,"flx_world created\n");
  try {

    error_exit_code = world-&gt;setup(argc, argv);

    if(0 != error_exit_code) return error_exit_code;

  // MAINLINE, ONLY DONE ONCE
  // TODO: simply return error_exit_code
    // We're all set up, so run felix
    world-&gt;begin_flx_code();

    // Run the felix usercode.
    error_exit_code = world-&gt;run();
    if(0 != error_exit_code) return error_exit_code;

    world-&gt;end_flx_code();

    error_exit_code = world-&gt;teardown();
  }
  catch (flx_exception_t &amp;x) { error_exit_code = flx_exception_handler(&amp;x); }
  catch (std::exception &amp;x) { error_exit_code = std_exception_handler (&amp;x); }
  catch (std::string &amp;s) { error_exit_code = 6; fprintf(stderr, "%s\n", s.c_str()); }
  catch (flx::rtl::con_t *p) { error_exit_code = 9; fprintf(stderr, "SYSTEM ERROR, UNCAUGHT CONTINUATION %p\n",p);}

  catch (...)
  {
    fprintf(stderr, "flx_run driver ends with unknown EXCEPTION\n");
    error_exit_code = 4;
  }
  delete world;
  delete c;

  return error_exit_code;
}


</pre></p></div><h2 id='Dynamic_link_loader_with_async_support_h'><img src='/share/src/web/images/minus.gif' id='Dynamic link loader with async support' onclick='toggle(this,"Dynamic_link_loader_with_async_support_d")' alt='+'/> 1.7 Dynamic link loader with async support</h2><div id='Dynamic_link_loader_with_async_support_d' style='display:block'>
<p>Compile this with position independent code support
to create a main driver object file
containing flx_run startup function suitable for
loading a Felix program built as a shared library.
This object has support for on demand loading of
the async I/O library. Loading may fail if the
async I/O library DLL cannot be found at run time.
</p><pre class='inclusion'>
share/src/flx_drivers/flx_arun_lib_dynamic.cpp</pre>
<p><pre class='cppbg'>#<span class="preproc">define</span> FLX_SUPPORT_ASYNC 1
#<span class="preproc">define</span> FELIX_MAIN felix_arun
#<span class="preproc">include</span> <span class="fstring">"flx_run.include"</span>
</pre></p></div><h2 id='Static_link_loader_with_async_support_h'><img src='/share/src/web/images/minus.gif' id='Static link loader with async support' onclick='toggle(this,"Static_link_loader_with_async_support_d")' alt='+'/> 1.8 Static link loader with async support</h2><div id='Static_link_loader_with_async_support_d' style='display:block'>
<p>Compile this to create a main driver object file
containing flx_run startup function suitable for
running a Felix program built as an object file.
This object file requires the async support library
to be linked in, however it is only activated on demand.
</p><pre class='inclusion'>
share/src/flx_drivers/flx_arun_lib_static.cpp</pre>
<p><pre class='cppbg'>#<span class="preproc">define</span> FLX_SUPPORT_ASYNC 1
#<span class="preproc">define</span> FELIX_MAIN felix_arun
#<span class="preproc">define</span> FLX_BUILD_FOR_STATIC_LINK
#<span class="preproc">include</span> <span class="fstring">"flx_run.include"</span>
</pre></p></div><h2 id='Dynamic_link_loader_with_async_support_h'><img src='/share/src/web/images/minus.gif' id='Dynamic link loader with async support' onclick='toggle(this,"Dynamic_link_loader_with_async_support_d")' alt='+'/> 1.9 Dynamic link loader with async support</h2><div id='Dynamic_link_loader_with_async_support_d' style='display:block'>
<p>Compile this with position independent code support
to create a main driver object file
containing flx_run startup function suitable for
loading a Felix program built as a shared library.
</p><pre class='inclusion'>
share/src/flx_drivers/flx_run_lib_dynamic.cpp</pre>
<p><pre class='cppbg'>#<span class="preproc">define</span> FLX_SUPPORT_ASYNC 0
#<span class="preproc">define</span> FELIX_MAIN felix_run
#<span class="preproc">include</span> <span class="fstring">"flx_run.include"</span>
</pre></p></div><h2 id='Static_link_loader_without_async_support_h'><img src='/share/src/web/images/minus.gif' id='Static link loader without async support' onclick='toggle(this,"Static_link_loader_without_async_support_d")' alt='+'/> 1.10 Static link loader without async support</h2><div id='Static_link_loader_without_async_support_d' style='display:block'>
<p>Compile this to create a main driver object file
containing flx_run startup function suitable for
running a Felix program built as an object file.
</p><pre class='inclusion'>
share/src/flx_drivers/flx_run_lib_static.cpp</pre>
<p><pre class='cppbg'>#<span class="preproc">define</span> FLX_SUPPORT_ASYNC 0
#<span class="preproc">define</span> FELIX_MAIN felix_run
#<span class="preproc">define</span> FLX_BUILD_FOR_STATIC_LINK
#<span class="preproc">include</span> <span class="fstring">"flx_run.include"</span>
</pre></p></div><h2 id='Traditional_Mainline_with_async_support_h'><img src='/share/src/web/images/minus.gif' id='Traditional Mainline with async support' onclick='toggle(this,"Traditional_Mainline_with_async_support_d")' alt='+'/> 1.11 Traditional Mainline with async support</h2><div id='Traditional_Mainline_with_async_support_d' style='display:block'>
<p>Link this, together with translation units containing flx_arun,
to create a static link executable with async support.
</p><pre class='inclusion'>
share/src/flx_drivers/flx_arun_main.cxx</pre>
<p><pre class='cppbg'>#<span class="preproc">include</span> <span class="fstring">"flx_run.hpp"</span>

<span class="comment">// to set the critical error handler
</span>#<span class="preproc">ifdef</span> _WIN32
#<span class="preproc">include</span> <span class="fstring">&lt;windows.h&gt;</span>
#<span class="preproc">include</span> <span class="fstring">&lt;stdio.h&gt;</span>
#<span class="preproc">endif</span>

<span class="qualifier">int</span> main(<span class="qualifier">int</span> argc, <span class="qualifier">char</span> **argv) 
{
  #<span class="preproc">ifdef</span> _WIN32
  SetErrorMode (SEM_FAILCRITICALERRORS);
  #<span class="preproc">endif</span>
  <span class="small_keyword">return</span> felix_arun(argc, argv);
}
</pre></p></div><h2 id='Traditional_Mainline_without_async_support_h'><img src='/share/src/web/images/minus.gif' id='Traditional Mainline without async support' onclick='toggle(this,"Traditional_Mainline_without_async_support_d")' alt='+'/> 1.12 Traditional Mainline without async support</h2><div id='Traditional_Mainline_without_async_support_d' style='display:block'>
<p>Link this, together with translation units containing flx_run,
to create a static link executable without async support.
</p><pre class='inclusion'>
share/src/flx_drivers/flx_run_main.cxx</pre>
<p><pre class='cppbg'>#<span class="preproc">include</span> <span class="fstring">"flx_run.hpp"</span>
#<span class="preproc">include</span> <span class="fstring">"stdio.h"</span>

<span class="comment">// to set the critical error handler
</span>#<span class="preproc">ifdef</span> _WIN32
#<span class="preproc">include</span> <span class="fstring">&lt;windows.h&gt;</span>
#<span class="preproc">include</span> <span class="fstring">&lt;stdio.h&gt;</span>
#<span class="preproc">endif</span>

<span class="qualifier">int</span> main(<span class="qualifier">int</span> argc, <span class="qualifier">char</span> **argv) 
{
  #<span class="preproc">ifdef</span> _WIN32
  SetErrorMode (SEM_FAILCRITICALERRORS);
  #<span class="preproc">endif</span>
  <span class="comment">//fprintf(stderr,"Felix mainline flx_run_main starts!\n");
</span>  <span class="small_keyword">return</span> felix_run(argc, argv);
}
</pre></p></div></div><h1 id='Driver_executable_config_h'><img src='/share/src/web/images/minus.gif' id='Driver executable config' onclick='toggle(this,"Driver_executable_config_d")' alt='+'/> 2 Driver executable config</h1><div id='Driver_executable_config_d' style='display:block'>
<pre class='inclusion'>
$PWD/src/config/flx_arun.fpc</pre>
<p><pre class="prefmtbg">Name: flx_arun
Description: Felix standard driver, async support
Requires: flx_async faio demux flx_pthread flx flx_gc flx_dynlink flx_strutil
flx_requires_driver: flx_arun
srcdir: src/flx_drivers
src: flx_arun_lib\.cpp|flx_arun_main\.cxx
</pre></p><pre class='inclusion'>
$PWD/src/config/flx_run.fpc</pre>
<p><pre class="prefmtbg">Name: flx_run
Description: Felix standard driver, no async support
Requires: flx_pthread flx flx_gc flx_dynlink flx_strutil
srcdir: src/flx_drivers
src: flx_run_lib\.cpp|flx_run_main\.cxx
</pre></p><pre class='inclusion'>
$PWD/src/config/flx_thread_free_run.fpc</pre>
<p><pre class="prefmtbg">Name: flx_thread_free_run
Description: Felix driver, no thread or async support
Description: WORK IN PROGRESS
Requires: flx flx_gc dl
srcdir: src/flx_drivers
src: flx_run_lib\.cpp|flx_run_main\.cxx
</pre></p></div><h1 id='Build_Code_h'><img src='/share/src/web/images/minus.gif' id='Build Code' onclick='toggle(this,"Build_Code_d")' alt='+'/> 3 Build Code</h1><div id='Build_Code_d' style='display:block'>
<pre class='inclusion'>
$PWD/buildsystem/flx_drivers.py</pre>
<p><pre class="prefmtbg">import fbuild
from fbuild.functools import call
from fbuild.path import Path
from fbuild.record import Record
import buildsystem
from buildsystem.config import config_call

# ------------------------------------------------------------------------------

def build( phase):
    #print("[fbuild:flx_drivers.py:build (in src/packages/driver.html)] ********** BUILDING DRIVERS ***********************************************")
    path = Path(phase.ctx.buildroot/'share'/'src/flx_drivers')

    #dlfcn_h = config_call('fbuild.config.c.posix.dlfcn_h',
    #    phase.platform,
    #    phase.cxx.static,
    #    phase.cxx.shared)

    #if dlfcn_h.dlopen:
    #    external_libs = dlfcn_h.external_libs
    #    print("HAVE dlfcn.h, library=" + str (external_libs))
    #else:
    #    print("NO dlfcn.h available")
    #    external_libs = []
    external_libs = []

    run_includes = [
        phase.ctx.buildroot / 'host/lib/rtl',
        phase.ctx.buildroot / 'share/lib/rtl'
    ]

    arun_includes = run_includes + [
        'src/demux',
    ] + ([], ['src/demux/win'])['win32' in phase.platform]

    # Make four object files for flx_run 
    # two for async, two without
    # each pair made static and non static

    flx_run_static_static_obj = phase.cxx.static.compile(
        dst='host/lib/rtl/flx_run_lib_static',
        src=path / 'flx_run_lib_static.cpp',
        includes=run_includes,
        macros=['FLX_STATIC_LINK'],
    )

    flx_run_static_dynamic_obj = phase.cxx.shared.compile(
        dst='host/lib/rtl/flx_run_lib_static',
        src=path / 'flx_run_lib_static.cpp',
        includes=run_includes,
    )


    flx_run_dynamic_dynamic_obj = phase.cxx.shared.compile(
        dst='host/lib/rtl/flx_run_lib_dynamic',
        src=path / 'flx_run_lib_dynamic.cpp',
        includes=run_includes,
    )


    flx_arun_static_static_obj = phase.cxx.static.compile(
        dst='host/lib/rtl/flx_arun_lib_static',
        src=path / 'flx_arun_lib_static.cpp',
        includes=arun_includes,
        macros=['FLX_STATIC_LINK'],
    )

    flx_arun_static_dynamic_obj = phase.cxx.shared.compile(
        dst='host/lib/rtl/flx_arun_lib_static',
        src=path / 'flx_arun_lib_static.cpp',
        includes=arun_includes,
    )


    flx_arun_dynamic_dynamic_obj = phase.cxx.shared.compile(
        dst='host/lib/rtl/flx_arun_lib_dynamic',
        src=path / 'flx_arun_lib_dynamic.cpp',
        includes=arun_includes,
    )


    # Now, the mainline object files for static links
    flx_run_main_static= phase.cxx.static.compile(
        dst='host/lib/rtl/flx_run_main',
        src=path / 'flx_run_main.cxx',
        includes=run_includes,
        macros=['FLX_STATIC_LINK'],
    )

    flx_arun_main_static= phase.cxx.static.compile(
        dst='host/lib/rtl/flx_arun_main',
        src=path / 'flx_arun_main.cxx',
        includes=arun_includes,
        macros=['FLX_STATIC_LINK'],
    )

    # Now, the mainline object files for dynamic links
    flx_run_main_dynamic= phase.cxx.shared.compile(
        dst='host/lib/rtl/flx_run_main',
        src=path / 'flx_run_main.cxx',
        includes=run_includes,
    )

    flx_arun_main_dynamic= phase.cxx.shared.compile(
        dst='host/lib/rtl/flx_arun_main',
        src=path / 'flx_arun_main.cxx',
        includes=arun_includes,
    )


    # And then the mainline executable for dynamic links
    flx_run_exe = phase.cxx.shared.build_exe(
        dst='host/bin/flx_run',
        srcs=[path / 'flx_run_main.cxx', path / 'flx_run_lib_dynamic.cpp'],
        includes=run_includes,
        external_libs=external_libs,
        libs=[call('buildsystem.flx_rtl.build_runtime',  phase).shared],
    )

    flx_arun_exe = phase.cxx.shared.build_exe(
        dst='host/bin/flx_arun',
        srcs=[path / 'flx_arun_main.cxx', path/ 'flx_arun_lib_dynamic.cpp'],
        includes=arun_includes,
        external_libs=external_libs,
        libs=[
           call('buildsystem.flx_rtl.build_runtime',  phase).shared,
           call('buildsystem.flx_pthread.build_runtime', phase).shared,
           call('buildsystem.flx_async.build_runtime', phase).shared,
           call('buildsystem.demux.build_runtime', phase).shared,
           call('buildsystem.faio.build_runtime', phase).shared],
    )

    return Record(
        flx_run_lib_static_static=flx_run_static_static_obj,
        flx_run_lib_static_dynamic=flx_run_static_dynamic_obj,
        flx_run_lib_dynamic_dynamic=flx_run_dynamic_dynamic_obj,
        flx_arun_lib_static_static=flx_arun_static_static_obj,
        flx_arun_lib_static_dynamic=flx_arun_static_dynamic_obj,
        flx_arun_lib_dynamic_dynamic=flx_arun_dynamic_dynamic_obj,
        flx_run_main_static=flx_run_main_static,
        flx_run_main_dynamic=flx_run_main_dynamic,
        flx_run_exe=flx_run_exe,
        flx_arun_main_static=flx_arun_main_static,
        flx_arun_main_dynamic=flx_arun_main_dynamic,
        flx_arun_exe=flx_arun_exe,
    )
</pre></p></div><!--Main Content Body End-->

          </div> <!-- rightpanel contents end -->
          <hr>
        </span> <!-- rightpanel end -->

        <span id="panemover" style="cursor:col-resize;"
         onmousedown="dragStart(event, 'left', 'right'); return false;"
         onmousemove="drag(event, 'left', 'right');"
         onmouseout="dragRelease();"
         onmouseup="dragRelease();"
        >
        </span> <!-- panemover end -->
      </div> <!-- bottom panel end -->
    </div> <!-- container end -->
</body></html>

