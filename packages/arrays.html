<html><head>
<style type="text/css">
body {margin:3%; }
h1 {color:gray; font-size:120%;}
h2 {color:gray; font-size:105%;}
h3 {font-size:100%;}
h4 {font-size:95%;}
h5 {font-size:95%;}
span.fstring {color:darkblue; font-style:italic; }
span.comment {font-family:arial; color:blue; font-style:italic; }
span.doccomment {font-family:arial; color:green; font-style:italic; }
span.big_keyword {color:#FF1010; }
span.small_keyword {color:#802040; }
span.qualifier {color:#A02020; }
span.library {color:#A02000; }
span.ctor {color:#406020; }
span.hack {color:#66DD00; }
span.preproc {color:#005500; }
span.embedded_c{background-color:#DDDDDD; }
span.fpc_fieldname {color:#DD0000; }
span.lineno {color:#101010; background-color:#E0E0E0; font-size:80%; font-family:"courier",monospace; font-style:normal; }
pre.flxbg {background-color:#A0FFA0; color:black; padding:2px; box-shadow:5px 5px 2px #807080; }
pre.uncheckedflxbg {background-color:#D0D0D0; color:black; padding:2px; box-shadow:5px 5px 2px #807080; }
pre.cppbg {background-color:#80FF80; color:black; }
pre.prefmtbg {background-color:#D0D0D0; color:black; }
pre.expected {background-color:#E0FF80; color:black; }
pre.input {background-color:#E08080; color:black; }
pre.inclusion {background-color:#D070D0; color:black; }
code.inclusion {background-color:#D070D0; color:black; }
.obsolete { background-color:#FFEFEF; font-size: small; color:black; }
.future { background-color:#FF8080; font-size: small; color:black; }
.implementation_detail { background-color:#E0E0E0; font-size: small; color:black;  }
.bug { background-color:#FFE0E0; font-size: small; color:black; }
.fixed{ background-color:#FFE0E0; font-size: small; color:black; }
.done { background-color:#FFE0E0; font-size: small; color:black; }
.caveat { background-color:#FF8080; color:black; }
</style>

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
        skipTags: ["script","noscript","style","textarea"]
    }
  });
</script>
<title>Arrays</title></head><body>
<style>
body {margin:3%; font-family: sans-serif; }
h1 {color:black; font-size:120%; border-bottom: 2px solid #ddd; padding: 0 0 3px 0;}
h2 {color:#202020; font-size:105%;}
h3 {font-size:100%;}
h4 {font-size:95%;}
h5 {font-size:95%;}
span.fstring {color:darkblue; font-style:italic; }
span.comment {font-family:arial; color:blue; font-style:italic; }
span.doccomment {font-family:arial; color:green; font-style:italic; }
span.big_keyword {color:#FF1010; }
span.small_keyword {color:#802040; }
span.qualifier {color:#A02020; }
span.library {color:#A02000; }
span.ctor {color:#406020; }
span.hack {color:#66DD00; }
span.preproc {color:#005500; }
span.embedded_c{background-color:#DDDDDD; }
span.fpc_fieldname {color:#DD0000; }
span.lineno {color:#101010; background-color:#E0E0E0; font-size:80%; font-family:"courier",monospace; font-style:normal; }
pre { border: 1px solid #ccc; color: black; box-shadow:3px 3px 2px rgba(0,0,0,0.1); padding:2px; }
pre.flxbg {background-color:#C2FDC2; box-shadow:3px 3px 2px rgba(0,0,0,0.1) }
pre.uncheckedflxbg {background-color:#eee; box-shadow:3px 3px 2px rgba(0,0,0,0.1); }
pre.cppbg {background-color:#C2FDC2; }
pre.prefmtbg {background-color:#F1F1F1; }
pre.expected {background-color:hsla(74,94%,88%,1); }
pre.input {background-color:hsla(20,94%,88%,1); }
pre.inclusion {
    font-family: Arial;
    font-weight: normal;
    font-size: 0.9em;
    color: #555;
    border: none;
    box-shadow: none;
    text-align: right;
    margin: -7px 11px -12px 0;
    padding: 0;
    background-color:#fafafa;
}
code.inclusion {background-color:#D070D0; color:black; }
.obsolete { background-color:#FFEFEF; font-size: small; color:black; }
.future { background-color:#FF8080; font-size: small; color:black; }
.implementation_detail { background-color:#E0E0E0; font-size: small; color:black;  }
.bug { background-color:#FFE0E0; font-size: small; color:black; }
.fixed{ background-color:#FFE0E0; font-size: small; color:black; }
.done { background-color:#FFE0E0; font-size: small; color:black; }
.caveat { background-color:hsla(0,100%,91%,1); color:black; padding: 0.6em; }
.container {
  position: fixed;
  top:0px;
  left:0px;
  height : 100%;
  width: 100%;
  background-color: grey;
  margin: 0px;
  padding: 0px;
  border-width: 0px;
  color: #404040;
}
.maincontent {
  padding:4px;
  padding-left:8px;
  line-height:1.3em;
  color:#404040; background-color:#fafafa;
}
.maincontent h1 { margin-left:-8px; position: relative; font-family: georgia, serif; font-size: 1.8em; font-weight: normal; }
.maincontent h2 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent h3 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent h4 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent code { color:#902030; }
.toppanel {
  position:absolute; left:0px; top:0px; height:20px; right:0px;
  background-color: #e0e0e0;
}
.bottompanel {
  position:absolute; left:0px; top:22px; bottom:0px; right:0px;
  background-color: #fafafa;
  font-size:14px;
}
.leftpanel {
  position:absolute; left:0px; top:0px; bottom:0px; width: 150px;
  background-color: #eaeaea; overflow: auto;
}
.rightpanel {
  position:absolute; right: 0px; left:160px; top:0px; bottom: 0px;
  background-color: #fafafa; overflow: auto;
}
.divider {
  position:absolute; left: 150px; top:0px; bottom:0px;
  background-color: black; width:2px;
  box-shadow: 0 0 8px #000;
}

#panemover {
    position:absolute;
    left: 150px;
    width : 10px;
    top: 0px;
    bottom: 0px;
    opacity: 0.3;
    cursor:col-resize;
}

div.m {
    margin: 0px;
    padding:0px;
    border-width:2px;
    border-color: green;
}

div.m1 {
    background-color: #86E870;
    border-style:outset;
    border-color:#ccc;
    border-width:2px 0;
    font-size:90%;
    padding: 1px 0 2px 10px;
}

div.m2 {
    background-color: #70C070;
    padding-left:15px;
    padding-top:2px;
    border-style:outset;
    border-color:green;
    border-width:0 0 1px 0;
    font-size:80%;
}

div.m1:hover, div.m2:hover {
    background-color: white;
}

#leftmargintoc a {
    text-decoration: none;
    color: #404040;
}
</style>

<style>
div.m {
    margin: 0px;
    padding:0px;
    border-width:2px;
    border-color: green;
}

div.m1 {
    background-color: #86E870;
    border-style:outset;
    border-color:#ccc;
    border-width:2px 0;
    font-size:90%;
    padding: 1px 0 2px 10px;
}

div.m2 {
    background-color: #70C070;
    padding-left:15px;
    padding-top:2px;
    border-style:outset;
    border-color:green;
    border-width:0 0 1px 0;
    font-size:80%;
}

div.m1:hover, div.m2:hover {
    background-color: white;
}

#leftmargintoc a {
    text-decoration: none;
    color: #404040;
}


</style>

    <script async="true">
      function dragStart(e, left, right){
        document.getElementById("panemover").style.width="70%";
        document.getElementById("panemover").style.left="50px";
        mousedown = true;
        x = e.clientX
        dragOffsetLeft =
          document.getElementById(left).getBoundingClientRect().right -
          document.getElementById(left).getBoundingClientRect().left -
          x
        ;
        dragOffsetDivider= document.getElementById("divider").getBoundingClientRect().left - x;
        dragOffsetRight = document.getElementById(right).getBoundingClientRect().left - x;
      }
      function dragRelease(){
        document.getElementById('panemover').style.width = '10px';
        document.getElementById('panemover').style.left = document.getElementById('divider').offsetLeft + 'px';
        mousedown = false;
      }
      function drag(e, left, right){
        if(!mousedown){return}
        x = e.clientX
        tmpLeft = dragOffsetLeft + x
        tmpDivider= dragOffsetDivider + x
        tmpRight = dragOffsetRight + x
        document.getElementById(left).style.width= tmpLeft + 'px';
        document.getElementById("divider").style.left= tmpDivider + 'px';
        document.getElementById(right).style.left = tmpRight + 'px';
      };
    </script>

<script type="text/javascript">

  function mexpand(id)
  {
    var n = document.getElementById(id).style;
    n.display = "block";
  }

  function mcollapse(id)
  {
    var n = document.getElementById(id).style;
    n.display = "none";
  }

  var counter_max = 0;
  function mshow(id,loc)
  {
    var i;
    for(i=1; i<=counter_max; ++i)
      mcollapse("menu"+String(i));
    mexpand(id);
    window.location.replace(loc);
  }
</script>

<script type="text/javascript">

function expand(but,id)
{
  var n = document.getElementById(id).style;
  var button = document.getElementById(but);
  button.src = "/share/src/web/images/minus.gif";
  button.alt = "-";
  n.display = "block";
}
function collapse(but,id)
{
  var n = document.getElementById(id).style;
  var button = document.getElementById(but);
  button.src = "/share/src/web/images/plus.gif";
  button.alt = "+";
  n.display = "none";
}
function toggle(button,id)
{
  var n = document.getElementById(id).style;
  if (n.display == "none")
  {
    button.src = "/share/src/web/images/minus.gif";
    button.alt = "-";
    n.display = "block";
  }
  else
  {
    button.src = "/share/src/web/images/plus.gif";
    button.alt = "+";
    n.display = "none";
  }
}
var allbuttons = [
"Array Abstactions.",
"Array Value.",
"Core methods.",
"Array length <code>len</code>.",
"Get element by index <code>unsafe_get</code>.",
"Get element by index with bound check: <code>get</code>.",
"Derived methods.",
"Projection function wrapper.",
"Callback based value iterator <code>iter</code>.",
"Callback based index and value iterator <code>iiter</code>.",
"Streaming iterator <code>iterator</code>.",
"Callback based left fold <code>fold_left</code>.",
"Callback based right fold <code>fold_right</code>.",
"Callback base fold <code>fold</code>",
"Value search by predicate <code>mem</code>.",
"Value search by relation to given value <code>mem</code>.",
"Value search by default equality <code>in</code>.",
"Value find and return using predicate <code>find</code>",
"Value find and return using relation <code>find</code>",
"Sum",
"Product",
"Missing.",
"True Arrays.",
"Array Object.",
"Storing a value with <code>unsafe_set</code>.",
"Fetching a pointer to an element with <code>unsafe_get_ref</code>.",
"Storing a value with <code>set</code>.",
"Getting a pointer to an array element.",
"True Array Object.",
"Contiguous Arrays.",
"The <code>stl_begin</code> and <code>stl_end</code> methods.",
"A pointer to an element by index <code>+</code>.",
"Sort method using supplied comparator <code>sort</code>.",
"Sort method using default comparator <code>sort</code>.",
"True Contiguous Array Object.",
"Array",
"Varray",
"Darray",
"<code>darray</code>: an array with dynamic, unbounded length.",
"Representation",
"Default resize function.",
"<code>darray</code> type.",
"Force a resize of the bound.",
"Constructors.",
"As a value.",
"As an object.",
"As an contiguous array.",
"Size changing mutators.",
"Slice",
"Convert a darray to a string.",
"Enable map on darray objects.",
"Enable filter on darray objects",
"As a set",
"Sarray",
"Bsarray"
];
function expand_all(dummy)
{
  for (i in allbuttons)
  {
    expand(allbuttons[i], allbuttons[i]+"_d");
  }
}
function collapse_all(dummy)
{
  for (i in allbuttons)
  {
    collapse(allbuttons[i], allbuttons[i]+"_d");
  }
}
</script>

<script>
function mouseover(id)
{
  var elt = document.getElementById(id);
  elt.style.display="none";
  var elt2 = document.getElementById(id+"_mo");
  elt2.style.display="inline";
}

function mouseout(id)
{
  var elt = document.getElementById(id+"_mo");
  elt.style.display="none";
  var elt2 = document.getElementById(id);
  elt2.style.display="inline";
}

</script>
<script> function nop(dummy) {} </script>
    <div class="container">
      <div class="toppanel">
    <!--Main Content top navbar-->
<span style="position:relative; bottom:6px"
  onmouseover="mouseover('expand')"
  onmouseout="mouseout('expand')"
  onclick="expand_all('expand')"
  ><span id="expand"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:blue;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Expand</text></svg></span><span id="expand_mo" style="display:none"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:red;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Expand</text></svg></span></span><span style="position:relative; bottom:6px"
  onmouseover="mouseover('collapse')"
  onmouseout="mouseout('collapse')"
  onclick="collapse_all('collapse')"
  ><span id="collapse"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:blue;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Collapse</text></svg></span><span id="collapse_mo" style="display:none"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:red;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Collapse</text></svg></span></span>    <!--Main Content top navbar End-->

      </div> <!-- toppanel end -->
      <div class="bottompanel">
        <span id="divider" class="divider"></span>

        <span id="left" class="leftpanel" >
          <div class="menucontent">
  <!--Left Margin Toc-->
  <div id="leftmargintoc">
    <!--Left Margin Toc Main Contents-->
      <div class=m1 onclick="mshow('menu1','#Array Abstactions._h')"> <a href="#Array_Abstactions._h">Array Abstactions.</a></div>
      <div class=sm id=menu1>
      <div class=m2><a href="#Array_Value._h">Array Value.</a></div>
      <div class=m2><a href="#True_Arrays._h">True Arrays.</a></div>
      <div class=m2><a href="#Array_Object._h">Array Object.</a></div>
      <div class=m2><a href="#True_Array_Object._h">True Array Object.</a></div>
      <div class=m2><a href="#Contiguous_Arrays._h">Contiguous Arrays.</a></div>
      <div class=m2><a href="#True_Contiguous_Array_Object._h">True Contiguous Array Object.</a></div>
      </div>
      <div class=m1 onclick="mshow('menu2','#Array_h')"> <a href="#Array_h">Array</a></div>
      <div class=sm id=menu2>
      </div>
      <div class=m1 onclick="mshow('menu3','#Varray_h')"> <a href="#Varray_h">Varray</a></div>
      <div class=sm id=menu3>
      </div>
      <div class=m1 onclick="mshow('menu4','#Darray_h')"> <a href="#Darray_h">Darray</a></div>
      <div class=sm id=menu4>
      </div>
      <div class=m1 onclick="mshow('menu5','#<code>darray</code>: an array with dynamic, unbounded length._h')"> <a href="#<code>darray</code>:_an_array_with_dynamic,_unbounded_length._h"><code>darray</code>: an array with dynamic, unbounded length.</a></div>
      <div class=sm id=menu5>
      <div class=m2><a href="#Representation_h">Representation</a></div>
      <div class=m2><a href="#Default_resize_function._h">Default resize function.</a></div>
      <div class=m2><a href="#<code>darray</code>_type._h"><code>darray</code> type.</a></div>
      <div class=m2><a href="#Force_a_resize_of_the_bound._h">Force a resize of the bound.</a></div>
      <div class=m2><a href="#Constructors._h">Constructors.</a></div>
      <div class=m2><a href="#As_a_value._h">As a value.</a></div>
      <div class=m2><a href="#As_an_object._h">As an object.</a></div>
      <div class=m2><a href="#As_an_contiguous_array._h">As an contiguous array.</a></div>
      <div class=m2><a href="#Size_changing_mutators._h">Size changing mutators.</a></div>
      <div class=m2><a href="#Slice_h">Slice</a></div>
      <div class=m2><a href="#Convert_a_darray_to_a_string._h">Convert a darray to a string.</a></div>
      <div class=m2><a href="#Enable_map_on_darray_objects._h">Enable map on darray objects.</a></div>
      <div class=m2><a href="#Enable_filter_on_darray_objects_h">Enable filter on darray objects</a></div>
      <div class=m2><a href="#As_a_set_h">As a set</a></div>
      </div>
      <div class=m1 onclick="mshow('menu6','#Sarray_h')"> <a href="#Sarray_h">Sarray</a></div>
      <div class=sm id=menu6>
      </div>
      <div class=m1 onclick="mshow('menu7','#Bsarray_h')"> <a href="#Bsarray_h">Bsarray</a></div>
      <div class=sm id=menu7>
      </div>
    <script>counter_max=7;</script>
  </div>
  <!--End Left Margin Toc-->

          </div> <!-- leftpanel contents end -->
        </span> <!-- leftpanel end -->

        <span id="right" class="rightpanel">
          <div class="maincontent">
<!--Main Content Body-->
<h1 id='Array_Abstactions._h'><img src='/share/src/web/images/minus.gif' id='Array Abstactions.' onclick='toggle(this,"Array_Abstactions._d")' alt='+'/> 1 Array Abstactions.</h1><div id='Array_Abstactions._d' style='display:block'>
<p>We specify two core array abstractions: arrays as values
and arrays as objects.
</p><h2 id='Array_Value._h'><img src='/share/src/web/images/minus.gif' id='Array Value.' onclick='toggle(this,"Array_Value._d")' alt='+'/> 1.1 Array Value.</h2><div id='Array_Value._d' style='display:block'>
<p>The ArrayValue class construes an array as a value, that is,
a purely functional, immutable data structure characterised
by two properties: its length, and a way to fetch a 
value from the array using a integral index.
</p><p>Many routines can be written using only these two functions.
</p><p>Note: an array is not intrinsically a <code>Container</code> because that
would require it to also be a <code>Set</code>, which in turn requires
a membership operator which would require some standard
comparison. Arrays don't come equipped with a comparison.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">Array as Value (immutable).</span>
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Define a type class">class</span> ArrayValue[t,v]
<span class="lineno" id=line3></span>  {
</pre></p><h3 id='Core_methods._h'><img src='/share/src/web/images/minus.gif' id='Core methods.' onclick='toggle(this,"Core_methods._d")' alt='+'/> 1.1.1 Core methods.</h3><div id='Core_methods._d' style='display:block'>
<h4 id='Array_length_<code>len</code>._h'><img src='/share/src/web/images/minus.gif' id='Array length <code>len</code>.' onclick='toggle(this,"Array_length_<code>len</code>._d")' alt='+'/> 1.1.1.1 Array length <code>len</code>.</h4><div id='Array_length_<code>len</code>._d' style='display:block'>
<p>The length of the array.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Length.</span>
<span class="lineno" id=line2></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="number of elements in data structure">len</span>: t -&gt; <span class="library" title="binding of C size_t type">size</span>;
<span class="lineno" id=line3></span>  
</pre></p></div><h4 id='Get_element_by_index_<code>unsafe_get</code>._h'><img src='/share/src/web/images/minus.gif' id='Get element by index <code>unsafe_get</code>.' onclick='toggle(this,"Get_element_by_index_<code>unsafe_get</code>._d")' alt='+'/> 1.1.1.2 Get element by index <code>unsafe_get</code>.</h4><div id='Get_element_by_index_<code>unsafe_get</code>._d' style='display:block'>
<p>Performance routine to fetch the n'th element
of an array without any bounds checking.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Unchecked common indexing.</span>
<span class="lineno" id=line2></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> unsafe_get: t * <span class="library" title="binding of C size_t type">size</span> -&gt; v;
</pre></p></div><h4 id='Get_element_by_index_with_bound_check:_<code>get</code>._h'><img src='/share/src/web/images/minus.gif' id='Get element by index with bound check: <code>get</code>.' onclick='toggle(this,"Get_element_by_index_with_bound_check:_<code>get</code>._d")' alt='+'/> 1.1.1.3 Get element by index with bound check: <code>get</code>.</h4><div id='Get_element_by_index_with_bound_check:_<code>get</code>._d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Checked common indexing.</span>
<span class="lineno" id=line2></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> get[I <span class="small_keyword" title="membership operator, function mem">in</span> ints] (x:t, i:I) = { 
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Run time assertion">assert</span> i.<span class="library" title="binding of C size_t type">size</span> &lt; x.<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line4></span>      <span class="small_keyword" title="return">return</span> unsafe_get (x,i.<span class="library" title="binding of C size_t type">size</span>);
<span class="lineno" id=line5></span>    }
</pre></p></div></div><h3 id='Derived_methods._h'><img src='/share/src/web/images/minus.gif' id='Derived methods.' onclick='toggle(this,"Derived_methods._d")' alt='+'/> 1.1.2 Derived methods.</h3><div id='Derived_methods._d' style='display:block'>
<p>The following methods depend only on the implementation
of the core methods. Most are either simple remaps
to provide more convenient nottion, or we use
virtual function so that the default definitions
can be replaced by a more efficient implemention
for some particular types.
</p><h4 id='Projection_function_wrapper._h'><img src='/share/src/web/images/minus.gif' id='Projection function wrapper.' onclick='toggle(this,"Projection_function_wrapper._d")' alt='+'/> 1.1.2.1 Projection function wrapper.</h4><div id='Projection_function_wrapper._d' style='display:block'>
<p>We use the special lookup rules for provided by
the <code>apply</code> function so that an application of
an integer to an array is translated into a 
call on the get method:
</p><p><pre class="prefmtbg">  n a -&gt; get (a,n)
  a. n -&gt; n a -&gt; get (a,n)
</pre></p><p>Note that the more usual reverse application using
operator dot <code>.</code> is also made available this way.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>    <span class="doccomment"> Checked common indexing.</span>
<span class="lineno" id=line3></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> apply [I <span class="small_keyword" title="membership operator, function mem">in</span> ints] (i:I, x:t) =&gt; get (x,i.<span class="library" title="binding of C size_t type">size</span>);
<span class="lineno" id=line4></span>  
</pre></p></div><h4 id='Callback_based_value_iterator_<code>iter</code>._h'><img src='/share/src/web/images/minus.gif' id='Callback based value iterator <code>iter</code>.' onclick='toggle(this,"Callback_based_value_iterator_<code>iter</code>._d")' alt='+'/> 1.1.2.2 Callback based value iterator <code>iter</code>.</h4><div id='Callback_based_value_iterator_<code>iter</code>._d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Callback based value iterator.</span>
<span class="lineno" id=line2></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> <span class="library" title="call procedure on each element of data structure">iter</span> (_f:v-&gt;<span class="library" title="Type with no values, returning void indicates a procedure">void</span>) (x:t) {
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Define an immutable value">val</span> n = x.<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line4></span>      <span class="small_keyword" title="conditional">if</span> n &gt; 0uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line5></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i:<span class="library" title="binding of C size_t type">size</span> <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> n - 1uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line6></span>          _f$ unsafe_get(x,i);
<span class="lineno" id=line7></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line8></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line9></span>    }
<span class="lineno" id=line10></span>  
</pre></p></div><h4 id='Callback_based_index_and_value_iterator_<code>iiter</code>._h'><img src='/share/src/web/images/minus.gif' id='Callback based index and value iterator <code>iiter</code>.' onclick='toggle(this,"Callback_based_index_and_value_iterator_<code>iiter</code>._d")' alt='+'/> 1.1.2.3 Callback based index and value iterator <code>iiter</code>.</h4><div id='Callback_based_index_and_value_iterator_<code>iiter</code>._d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Callback based index and value iterator.</span>
<span class="lineno" id=line2></span>    <span class="doccomment">Callback f index value.</span>
<span class="lineno" id=line3></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> iiter (_f:<span class="library" title="binding of C size_t type">size</span> -&gt; v-&gt;<span class="library" title="Type with no values, returning void indicates a procedure">void</span>) (x:t) {
<span class="lineno" id=line4></span>      <span class="big_keyword" title="Define an immutable value">val</span> n = x.<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line5></span>      <span class="small_keyword" title="conditional">if</span> n &gt; 0uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line6></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i:<span class="library" title="binding of C size_t type">size</span> <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> n - 1uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line7></span>          _f i  (x,i).unsafe_get;
<span class="lineno" id=line8></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line9></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line10></span>    }
<span class="lineno" id=line11></span>  
</pre></p></div><h4 id='Streaming_iterator_<code>iterator</code>._h'><img src='/share/src/web/images/minus.gif' id='Streaming iterator <code>iterator</code>.' onclick='toggle(this,"Streaming_iterator_<code>iterator</code>._d")' alt='+'/> 1.1.2.4 Streaming iterator <code>iterator</code>.</h4><div id='Streaming_iterator_<code>iterator</code>._d' style='display:block'>
<p>Class <code>Streamable</code> provides a set of functions based
on a generated named <code>iterator</code> which returns an
infinite stream of option values. Loops based on such
streams work with any <code>Streamable</code> data type, 
including <code>ArrayValue</code>.
</p><p>Such loops operate by providing the loop body with the
argument of the <code>Some</code> constructor of the option type
obtained by a call to a closure of the <code>iterator</code> generator.
When that object finally returns <code>None</code> to signal the end
of data, the loop terminates.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> Iterable[t,v] {
<span class="lineno" id=line2></span>      <span class="doccomment">Stream  value iterator.</span>
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> iterator(xs:t) () : <span class="library" title="option type: Some x or None">opt</span>[v] = 
<span class="lineno" id=line4></span>      {
<span class="lineno" id=line5></span>        <span class="small_keyword" title="conditional">if</span> xs.<span class="library" title="number of elements in data structure">len</span> &gt; 0uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line6></span>          <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> j <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> xs.<span class="library" title="number of elements in data structure">len</span> - 1uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line7></span>            <span class="small_keyword" title="return a value saving the current location for future resumption">yield</span> Some (xs,j).unsafe_get;
<span class="lineno" id=line8></span>          <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line9></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line10></span>        <span class="small_keyword" title="return">return</span> None[v];
<span class="lineno" id=line11></span>      } 
<span class="lineno" id=line12></span>    }
<span class="lineno" id=line13></span>  
<span class="lineno" id=line14></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> Streamable[t,v];
</pre></p></div><h4 id='Callback_based_left_fold_<code>fold_left</code>._h'><img src='/share/src/web/images/minus.gif' id='Callback based left fold <code>fold_left</code>.' onclick='toggle(this,"Callback_based_left_fold_<code>fold_left</code>._d")' alt='+'/> 1.1.2.5 Callback based left fold <code>fold_left</code>.</h4><div id='Callback_based_left_fold_<code>fold_left</code>._d' style='display:block'>
<p>This HOF folds the values in an array into an accumulator
using the supplied function. The scan is left to right.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Traditional left fold.</span>
<span class="lineno" id=line2></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="accumulated values of data structure from left into initial value using function">fold_left</span>[u] (_f:u-&gt;v-&gt;u) (init:u) (x:t): u = {
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Define a mutable variable">var</span> o = init;
<span class="lineno" id=line4></span>      <span class="big_keyword" title="Define an immutable value">val</span> n = x.<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line5></span>      <span class="small_keyword" title="conditional">if</span> n &gt; 0uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line6></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i:<span class="library" title="binding of C size_t type">size</span> <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> n - 1uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line7></span>          o = _f o (unsafe_get(x,i));
<span class="lineno" id=line8></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line9></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line10></span>      <span class="small_keyword" title="return">return</span> o;
<span class="lineno" id=line11></span>    }
<span class="lineno" id=line12></span>  
</pre></p></div><h4 id='Callback_based_right_fold_<code>fold_right</code>._h'><img src='/share/src/web/images/minus.gif' id='Callback based right fold <code>fold_right</code>.' onclick='toggle(this,"Callback_based_right_fold_<code>fold_right</code>._d")' alt='+'/> 1.1.2.6 Callback based right fold <code>fold_right</code>.</h4><div id='Callback_based_right_fold_<code>fold_right</code>._d' style='display:block'>
<p>This HOF folds the values in an array into an accumulator
using the supplied function. The scan is right to left.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">Traditional right fold.</span>
<span class="lineno" id=line2></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="accumulated values of data structure from right into initial value using function">fold_right</span>[u] (_f:v-&gt;u-&gt;u) (x:t) (init:u): u = {
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Define a mutable variable">var</span> o = init;
<span class="lineno" id=line4></span>      <span class="big_keyword" title="Define an immutable value">val</span> n = x.<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line5></span>      <span class="small_keyword" title="conditional">if</span> n &gt; 0uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line6></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i:<span class="library" title="binding of C size_t type">size</span> <span class="small_keyword" title="membership operator, function mem">in</span> n - 1uz <span class="small_keyword" title="downwards counting for loop">downto</span> 0uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line7></span>          o = _f (unsafe_get(x,i)) o;
<span class="lineno" id=line8></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line9></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line10></span>      <span class="small_keyword" title="return">return</span> o;
<span class="lineno" id=line11></span>    }
<span class="lineno" id=line12></span>  
</pre></p></div><h4 id='Callback_base_fold_<code>fold</code>_h'><img src='/share/src/web/images/minus.gif' id='Callback base fold <code>fold</code>' onclick='toggle(this,"Callback_base_fold_<code>fold</code>_d")' alt='+'/> 1.1.2.7 Callback base fold <code>fold</code></h4><div id='Callback_base_fold_<code>fold</code>_d' style='display:block'>
<p>This HOF folds array array into an accumulator
using an associative user supplied function.
Associative here means that the order in which
the fold is done does not matter. This constraint
is currently not checked. The default order is a left
fold but the function is virtual and may be replaced
by another more efficient ordering in an overriding function.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> fold[u] (_f:u-&gt;v-&gt;u) (init:u) (x:t): u =&gt; 
<span class="lineno" id=line2></span>      <span class="library" title="accumulated values of data structure from left into initial value using function">fold_left</span> _f init x
<span class="lineno" id=line3></span>    ;
</pre></p></div><h4 id='Value_search_by_predicate_<code>mem</code>._h'><img src='/share/src/web/images/minus.gif' id='Value search by predicate <code>mem</code>.' onclick='toggle(this,"Value_search_by_predicate_<code>mem</code>._d")' alt='+'/> 1.1.2.8 Value search by predicate <code>mem</code>.</h4><div id='Value_search_by_predicate_<code>mem</code>._d' style='display:block'>
<p>This function searches an array for a value that satifies
the given predicate and returns a boolean value
indicating whether one exists.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Membership by predicate.</span>
<span class="lineno" id=line2></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> mem(pred:v-&gt;bool) (x:t): bool = {
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Define an immutable value">val</span> n = x.<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line4></span>      <span class="small_keyword" title="conditional">if</span> n &gt; 0uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line5></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i:<span class="library" title="binding of C size_t type">size</span> <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> n  - 1uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line6></span>          <span class="small_keyword" title="conditional">if</span> pred(unsafe_get(x,i)) <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line7></span>            <span class="small_keyword" title="return">return</span> <span class="library" title="truth value">true</span>;
<span class="lineno" id=line8></span>          <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line9></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line10></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line11></span>      <span class="small_keyword" title="return">return</span> <span class="library" title="false value">false</span>;
<span class="lineno" id=line12></span>    }
<span class="lineno" id=line13></span>  
</pre></p></div><h4 id='Value_search_by_relation_to_given_value_<code>mem</code>._h'><img src='/share/src/web/images/minus.gif' id='Value search by relation to given value <code>mem</code>.' onclick='toggle(this,"Value_search_by_relation_to_given_value_<code>mem</code>._d")' alt='+'/> 1.1.2.9 Value search by relation to given value <code>mem</code>.</h4><div id='Value_search_by_relation_to_given_value_<code>mem</code>._d' style='display:block'>
<p>This function searches an array for a value <code>i</code> that stands
in the specified relation <code>rel</code> to a given value <code>v</code>,
where the relation is applied in that order: <code>rel(i,v)</code>.
The usual relation to use is equality.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Membership by relation to given value. </span>
<span class="lineno" id=line2></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> mem[u] (rel:v*u-&gt;bool) (x:t) (e:u): bool =&gt;
<span class="lineno" id=line3></span>      mem (<span class="big_keyword" title="Define a function with no side-effects">fun</span> (i:v) =&gt; rel(i, e)) x
<span class="lineno" id=line4></span>    ;
<span class="lineno" id=line5></span>  
</pre></p></div><h4 id='Value_search_by_default_equality_<code>in</code>._h'><img src='/share/src/web/images/minus.gif' id='Value search by default equality <code>in</code>.' onclick='toggle(this,"Value_search_by_default_equality_<code>in</code>._d")' alt='+'/> 1.1.2.10 Value search by default equality <code>in</code>.</h4><div id='Value_search_by_default_equality_<code>in</code>._d' style='display:block'>
<p>This function uses the default equality operator <code>Eq[v]::==</code> for
the array value type t to perform a search.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Array as Set:</span>
<span class="lineno" id=line2></span>    <span class="doccomment">Membership by equality of value type.</span>
<span class="lineno" id=line3></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[<span class="small_keyword" title="type-class constraint">with</span> Eq[v]] Set[t,v] {
<span class="lineno" id=line4></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="tex_symbol" title="\in">\(\in\)</span> (elt:v, a:t) =&gt; mem eq of (v * v) a elt;
<span class="lineno" id=line5></span>    }
<span class="lineno" id=line6></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span>[t,v <span class="small_keyword" title="type-class constraint">with</span> Eq[v]] Set[t,v];
<span class="lineno" id=line7></span>  
</pre></p></div><h4 id='Value_find_and_return_using_predicate_<code>find</code>_h'><img src='/share/src/web/images/minus.gif' id='Value find and return using predicate <code>find</code>' onclick='toggle(this,"Value_find_and_return_using_predicate_<code>find</code>_d")' alt='+'/> 1.1.2.11 Value find and return using predicate <code>find</code></h4><div id='Value_find_and_return_using_predicate_<code>find</code>_d' style='display:block'>
<p>Same as our <code>mem</code> function except it returns the located value
as an option type.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Searching for value satisfying predicate.</span>
<span class="lineno" id=line2></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> find(pred:v-&gt;bool) (x:t): <span class="library" title="option type: Some x or None">opt</span>[v] = {
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Define an immutable value">val</span> n = x.<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line4></span>      <span class="small_keyword" title="conditional">if</span>  n &gt; 0uz <span class="small_keyword" title="imperative code begins">do</span> 
<span class="lineno" id=line5></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i:<span class="library" title="binding of C size_t type">size</span> <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> n - 1uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line6></span>          <span class="small_keyword" title="conditional">if</span> pred(unsafe_get(x,i)) <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line7></span>            <span class="small_keyword" title="return">return</span> Some$ unsafe_get(x,i);
<span class="lineno" id=line8></span>          <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line9></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line10></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line11></span>      <span class="small_keyword" title="return">return</span> None[v];
<span class="lineno" id=line12></span>    }
<span class="lineno" id=line13></span>  
</pre></p></div><h4 id='Value_find_and_return_using_relation_<code>find</code>_h'><img src='/share/src/web/images/minus.gif' id='Value find and return using relation <code>find</code>' onclick='toggle(this,"Value_find_and_return_using_relation_<code>find</code>_d")' alt='+'/> 1.1.2.12 Value find and return using relation <code>find</code></h4><div id='Value_find_and_return_using_relation_<code>find</code>_d' style='display:block'>
<p>Same as our <code>mem</code> function except it returns the located value
as an option type.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Searching for value satisfying relation to given value.</span>
<span class="lineno" id=line2></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> find (rel:v*v-&gt;bool) (x:t) (e:v): <span class="library" title="option type: Some x or None">opt</span>[v] = {
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Define an immutable value">val</span> n = x.<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line4></span>      <span class="small_keyword" title="conditional">if</span> n &gt; 0uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line5></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i:<span class="library" title="binding of C size_t type">size</span> <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> n - 1uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line6></span>          <span class="small_keyword" title="conditional">if</span> rel(unsafe_get (x,i), e) <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line7></span>            <span class="small_keyword" title="return">return</span> Some$ unsafe_get (x,i);
<span class="lineno" id=line8></span>          <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line9></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line10></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line11></span>  
<span class="lineno" id=line12></span>      <span class="small_keyword" title="return">return</span> None[v];
<span class="lineno" id=line13></span>    }
<span class="lineno" id=line14></span>  
</pre></p></div><h4 id='Sum_h'><img src='/share/src/web/images/minus.gif' id='Sum' onclick='toggle(this,"Sum_d")' alt='+'/> 1.1.2.13 Sum</h4><div id='Sum_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="tex_symbol" title="\sum">\(\sum\)</span> [<span class="small_keyword" title="type-class constraint">with</span> FloatAddgrp[v]] (it:t) =
<span class="lineno" id=line2></span>    {
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Define a mutable variable">var</span> init = #zero[v];
<span class="lineno" id=line4></span>      <span class="small_keyword" title="for loop">for</span> v <span class="small_keyword" title="membership operator, function mem">in</span> it <span class="small_keyword" title="imperative code begins">do</span> init = init + v; <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line5></span>      <span class="small_keyword" title="return">return</span> init;
<span class="lineno" id=line6></span>    }
<span class="lineno" id=line7></span>  
</pre></p></div><h4 id='Product_h'><img src='/share/src/web/images/minus.gif' id='Product' onclick='toggle(this,"Product_d")' alt='+'/> 1.1.2.14 Product</h4><div id='Product_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="tex_symbol" title="\prod">\(\prod\)</span>[<span class="small_keyword" title="type-class constraint">with</span> FloatMultSemi1[v]] (it:t) =
<span class="lineno" id=line2></span>    {
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Define a mutable variable">var</span> init = #one[v];
<span class="lineno" id=line4></span>      <span class="small_keyword" title="for loop">for</span> v <span class="small_keyword" title="membership operator, function mem">in</span> it <span class="small_keyword" title="imperative code begins">do</span> init = init * v; <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line5></span>      <span class="small_keyword" title="return">return</span> init;
<span class="lineno" id=line6></span>    }
<span class="lineno" id=line7></span>  
<span class="lineno" id=line8></span>  
</pre></p></div><h4 id='Missing._h'><img src='/share/src/web/images/minus.gif' id='Missing.' onclick='toggle(this,"Missing._d")' alt='+'/> 1.1.2.15 Missing.</h4><div id='Missing._d' style='display:block'>
<p>Should have a functional update? Find methods should have
directions. Search method should really be instances of
a class derived from Set. Find functions should have a
version that also returns the index.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  }
<span class="lineno" id=line2></span>  
</pre></p></div></div></div><h2 id='True_Arrays._h'><img src='/share/src/web/images/minus.gif' id='True Arrays.' onclick='toggle(this,"True_Arrays._d")' alt='+'/> 1.2 True Arrays.</h2><div id='True_Arrays._d' style='display:block'>
<p>This is an attempt to represent arrays in a more precise setting.
Ordinary arrays just use integer indexes. But a true array uses
a precise type as the index, an it must provide a value for all
possible values of the index. As such, bounds checks are not
required.
</p><p>This work is incomplete.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Define a type class">class</span> TrueArrayValue [t,x,v] 
<span class="lineno" id=line3></span>  {
<span class="lineno" id=line4></span>     <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> ArrayValue[t,v];
<span class="lineno" id=line5></span>     <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> render : x -&gt; <span class="library" title="binding of C size_t type">size</span>;
<span class="lineno" id=line6></span>     <span class="big_keyword" title="Define a function with no side-effects">fun</span> true_unsafe_get (a:t, i:x) =&gt; unsafe_get (a, render i);
<span class="lineno" id=line7></span>  }
<span class="lineno" id=line8></span>  
</pre></p></div><h2 id='Array_Object._h'><img src='/share/src/web/images/minus.gif' id='Array Object.' onclick='toggle(this,"Array_Object._d")' alt='+'/> 1.3 Array Object.</h2><div id='Array_Object._d' style='display:block'>
<p>The ArrayObject class extends the capabilities of an ArrayValue
by allowing mutation. A mutable array is typically abstract and
represented by a pointer, so it also uses pass by reference.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">Array as Object (mutable).</span>
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Define a type class">class</span> ArrayObject[t,v]
<span class="lineno" id=line3></span>  {
<span class="lineno" id=line4></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> ArrayValue[t,v];
<span class="lineno" id=line5></span>  
</pre></p><h3 id='Storing_a_value_with_<code>unsafe_set</code>._h'><img src='/share/src/web/images/minus.gif' id='Storing a value with <code>unsafe_set</code>.' onclick='toggle(this,"Storing_a_value_with_<code>unsafe_set</code>._d")' alt='+'/> 1.3.1 Storing a value with <code>unsafe_set</code>.</h3><div id='Storing_a_value_with_<code>unsafe_set</code>._d' style='display:block'>
<p>Modify an array object at a given index position
by assigning a new value without a bounds check.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="comment">// Unsafe store value into array by common index.</span>
<span class="lineno" id=line2></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> unsafe_set: t * <span class="library" title="binding of C size_t type">size</span> * v;
<span class="lineno" id=line3></span>  
</pre></p></div><h3 id='Fetching_a_pointer_to_an_element_with_<code>unsafe_get_ref</code>._h'><img src='/share/src/web/images/minus.gif' id='Fetching a pointer to an element with <code>unsafe_get_ref</code>.' onclick='toggle(this,"Fetching_a_pointer_to_an_element_with_<code>unsafe_get_ref</code>._d")' alt='+'/> 1.3.2 Fetching a pointer to an element with <code>unsafe_get_ref</code>.</h3><div id='Fetching_a_pointer_to_an_element_with_<code>unsafe_get_ref</code>._d' style='display:block'>
<p>Note this is problematic as it forces a value to
addressabe be stored as an object. A bitarray
will not satisfy this requirement. Do we need
another abstraction?
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> unsafe_get_ref : t * <span class="library" title="binding of C size_t type">size</span> -&gt; &amp;v;
<span class="lineno" id=line2></span>  
</pre></p></div><h3 id='Storing_a_value_with_<code>set</code>._h'><img src='/share/src/web/images/minus.gif' id='Storing a value with <code>set</code>.' onclick='toggle(this,"Storing_a_value_with_<code>set</code>._d")' alt='+'/> 1.3.3 Storing a value with <code>set</code>.</h3><div id='Storing_a_value_with_<code>set</code>._d' style='display:block'>
<p>Modify an array object by assigning a new value
to the slot at a given index position. Bounds checked.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="comment">// Checked store value into array by common index.</span>
<span class="lineno" id=line2></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> set[I <span class="small_keyword" title="membership operator, function mem">in</span> ints] (x:t, i:I, a:v) { 
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Run time assertion">assert</span> i.<span class="library" title="binding of C size_t type">size</span> &lt; x.<span class="library" title="number of elements in data structure">len</span>; unsafe_set (x,i.<span class="library" title="binding of C size_t type">size</span>,a); 
<span class="lineno" id=line4></span>    } 
<span class="lineno" id=line5></span>  
</pre></p></div><h3 id='Getting_a_pointer_to_an_array_element._h'><img src='/share/src/web/images/minus.gif' id='Getting a pointer to an array element.' onclick='toggle(this,"Getting_a_pointer_to_an_array_element._d")' alt='+'/> 1.3.4 Getting a pointer to an array element.</h3><div id='Getting_a_pointer_to_an_array_element._d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> n<span class="fstring">"&amp;."</span> [I <span class="small_keyword" title="membership operator, function mem">in</span> ints] (x:t, i:I) : &amp;v = {
<span class="lineno" id=line2></span>      <span class="big_keyword" title="Run time assertion">assert</span> i.<span class="library" title="binding of C size_t type">size</span> &lt; x.<span class="library" title="number of elements in data structure">len</span>; 
<span class="lineno" id=line3></span>      <span class="small_keyword" title="return">return</span> unsafe_get_ref (x,i.<span class="library" title="binding of C size_t type">size</span>); 
<span class="lineno" id=line4></span>    }
<span class="lineno" id=line5></span>  }
<span class="lineno" id=line6></span>  
</pre></p></div></div><h2 id='True_Array_Object._h'><img src='/share/src/web/images/minus.gif' id='True Array Object.' onclick='toggle(this,"True_Array_Object._d")' alt='+'/> 1.4 True Array Object.</h2><div id='True_Array_Object._d' style='display:block'>
<p>Incomplete work for arrays in a more precise setting
where the index type is fixed.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Define a type class">class</span> TrueArrayObject[t,x, v]
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> TrueArrayValue[t,x,v];
<span class="lineno" id=line4></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> ArrayObject[t,v];
<span class="lineno" id=line5></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> true_unsafe_set(a:t, i:x, e:v) =&gt; unsafe_set (a, render i, e);
<span class="lineno" id=line6></span>  }
<span class="lineno" id=line7></span>  
</pre></p></div><h2 id='Contiguous_Arrays._h'><img src='/share/src/web/images/minus.gif' id='Contiguous Arrays.' onclick='toggle(this,"Contiguous_Arrays._d")' alt='+'/> 1.5 Contiguous Arrays.</h2><div id='Contiguous_Arrays._d' style='display:block'>
<p>A contiguous array is one for which the store is
certain to be contiguous and admits scanning
the array directly using a pointer.
</p><p>Two methods, <code>stl_begin</code> and <code>stl_end</code> provide
pointers to the first element and one past the
location of the last element, for traditional
STL like array operations. These pointers have 
type <code>+v</code> where <code>v</code> is the element type. The named
type <code>carray[v]</code> is an alias for <code>+v</code>.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">Array as Contiguous STL Object.</span>
<span class="lineno" id=line2></span>  <span class="doccomment">Provides STL iterators type +v</span>
<span class="lineno" id=line3></span>  <span class="big_keyword" title="Define a type class">class</span> ContiguousArrayObject[t,v]
<span class="lineno" id=line4></span>  {
<span class="lineno" id=line5></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> ArrayObject[t,v];
<span class="lineno" id=line6></span>  
</pre></p><h3 id='The_<code>stl_begin</code>_and_<code>stl_end</code>_methods._h'><img src='/share/src/web/images/minus.gif' id='The <code>stl_begin</code> and <code>stl_end</code> methods.' onclick='toggle(this,"The_<code>stl_begin</code>_and_<code>stl_end</code>_methods._d")' alt='+'/> 1.5.1 The <code>stl_begin</code> and <code>stl_end</code> methods.</h3><div id='The_<code>stl_begin</code>_and_<code>stl_end</code>_methods._d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Start of array iterator.</span>
<span class="lineno" id=line2></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> stl_begin: t -&gt; +v;
<span class="lineno" id=line3></span>  
<span class="lineno" id=line4></span>    <span class="doccomment">One past the end of array iterator.</span>
<span class="lineno" id=line5></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> stl_end: t -&gt; +v;
<span class="lineno" id=line6></span>  
</pre></p></div><h3 id='A_pointer_to_an_element_by_index_<code>+</code>._h'><img src='/share/src/web/images/minus.gif' id='A pointer to an element by index <code>+</code>.' onclick='toggle(this,"A_pointer_to_an_element_by_index_<code>+</code>._d")' alt='+'/> 1.5.2 A pointer to an element by index <code>+</code>.</h3><div id='A_pointer_to_an_element_by_index_<code>+</code>._d' style='display:block'>
<p>We allow adding an integer to an array object to yield
an incrementable pointer to that element. 
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Add integer to iterator.</span>
<span class="lineno" id=line2></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> + [I <span class="small_keyword" title="membership operator, function mem">in</span> ints] (pa:t, i:I) : carray [v] = { 
<span class="lineno" id=line3></span>       <span class="big_keyword" title="Run time assertion">assert</span> i.<span class="library" title="binding of C size_t type">size</span> &lt; pa.<span class="library" title="number of elements in data structure">len</span>; 
<span class="lineno" id=line4></span>       <span class="small_keyword" title="return">return</span> pa.stl_begin + i.<span class="library" title="binding of C size_t type">size</span>; 
<span class="lineno" id=line5></span>    }
<span class="lineno" id=line6></span>  
</pre></p></div><h3 id='Sort_method_using_supplied_comparator_<code>sort</code>._h'><img src='/share/src/web/images/minus.gif' id='Sort method using supplied comparator <code>sort</code>.' onclick='toggle(this,"Sort_method_using_supplied_comparator_<code>sort</code>._d")' alt='+'/> 1.5.3 Sort method using supplied comparator <code>sort</code>.</h3><div id='Sort_method_using_supplied_comparator_<code>sort</code>._d' style='display:block'>
<p>In place sort the contents of a contiuous array using STL
sort and a supplied comparator, which must be a
total order.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">In place sort using STL sort with Felix comparator.</span>
<span class="lineno" id=line2></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> sort (cmp: v * v -&gt; bool) (a:t) {
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Define a mutable variable">var</span> first = a.stl_begin;
<span class="lineno" id=line4></span>      <span class="big_keyword" title="Define a mutable variable">var</span> last = a.stl_end;
<span class="lineno" id=line5></span>      <span class="big_keyword" title="Define a mutable variable">var</span> z = Sort::stl_comparator (cmp);
<span class="lineno" id=line6></span>      Sort::stl_sort (z,first,last);
<span class="lineno" id=line7></span>    }
<span class="lineno" id=line8></span>  
</pre></p></div><h3 id='Sort_method_using_default_comparator_<code>sort</code>._h'><img src='/share/src/web/images/minus.gif' id='Sort method using default comparator <code>sort</code>.' onclick='toggle(this,"Sort_method_using_default_comparator_<code>sort</code>._d")' alt='+'/> 1.5.4 Sort method using default comparator <code>sort</code>.</h3><div id='Sort_method_using_default_comparator_<code>sort</code>._d' style='display:block'>
<p>Inplace sort using default comparator.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">In place sort using STL sort with default comparison.</span>
<span class="lineno" id=line2></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> sort[<span class="small_keyword" title="type-class constraint">with</span> Tord[v]] (a:t) =&gt; sort (&lt; of (v*v)) a;
<span class="lineno" id=line3></span>  
<span class="lineno" id=line4></span>  }
<span class="lineno" id=line5></span>  
</pre></p></div></div><h2 id='True_Contiguous_Array_Object._h'><img src='/share/src/web/images/minus.gif' id='True Contiguous Array Object.' onclick='toggle(this,"True_Contiguous_Array_Object._d")' alt='+'/> 1.6 True Contiguous Array Object.</h2><div id='True_Contiguous_Array_Object._d' style='display:block'>
<p>A contiguous array in a more precise setting.
Incomplete.
</p><pre class='inclusion'>
share/lib/std/datatype/array_class.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Define a type class">class</span> TrueContiguousArrayObject[t,x, v] 
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> TrueArrayObject [t,x,v];
<span class="lineno" id=line4></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> ContiguousArrayObject[t,v];
<span class="lineno" id=line5></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> + (pa:t, i:x) : carray [v] =&gt; pa + render i;
<span class="lineno" id=line6></span>  }
<span class="lineno" id=line7></span>  
</pre></p></div></div><h1 id='Array_h'><img src='/share/src/web/images/minus.gif' id='Array' onclick='toggle(this,"Array_d")' alt='+'/> 2 Array</h1><div id='Array_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/array.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="doccomment">Compile time fix length array.</span>
<span class="lineno" id=line3></span>  <span class="big_keyword" title="Open a module or class">open</span> <span class="big_keyword" title="Define a type class">class</span> Farray
<span class="lineno" id=line4></span>  {
<span class="lineno" id=line5></span>    <span class="big_keyword" title="Define an alias for a type expression">typedef</span> <span class="library" title="array type, a tuple of all components the same type">array</span>[t,n:COMPACTLINEAR] = t ^ n;
<span class="lineno" id=line6></span>  
<span class="lineno" id=line7></span>    <span class="comment">//ctor[T,N] array[T,N] (x:array[T,N]) =&gt; x;</span>
<span class="lineno" id=line8></span>  
<span class="lineno" id=line9></span>    <span class="doccomment">Array copy.</span>
<span class="lineno" id=line10></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> copy[T,N:COMPACTLINEAR] (<span class="big_keyword" title="Define a mutable variable">var</span> x:<span class="library" title="array type, a tuple of all components the same type">array</span>[T,N]) =&gt; x;
<span class="lineno" id=line11></span>  
<span class="lineno" id=line12></span>    <span class="doccomment">Array of one element.</span>
<span class="lineno" id=line13></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span>[T] <span class="library" title="array type, a tuple of all components the same type">array</span>[T,1] (x:T) =&gt; x :&gt;&gt; <span class="library" title="array type, a tuple of all components the same type">array</span>[T,1];
<span class="lineno" id=line14></span>  
<span class="lineno" id=line15></span>    <span class="doccomment">Array as value.</span>
<span class="lineno" id=line16></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[t,n:COMPACTLINEAR] ArrayValue[<span class="library" title="array type, a tuple of all components the same type">array</span>[t,n], t] {
<span class="lineno" id=line17></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="number of elements in data structure">len</span> (x:<span class="library" title="array type, a tuple of all components the same type">array</span>[t, n]): <span class="library" title="binding of C size_t type">size</span> =&gt; Typing::arrayindexcount[n];
<span class="lineno" id=line18></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> unsafe_get (<span class="big_keyword" title="Define a mutable variable">var</span> a: <span class="library" title="array type, a tuple of all components the same type">array</span>[t, n], j: <span class="library" title="binding of C size_t type">size</span>): t =&gt; a . (j :&gt;&gt; n);
<span class="lineno" id=line19></span>    }
<span class="lineno" id=line20></span>  
<span class="lineno" id=line21></span>    <span class="doccomment">Pointer to array as value.</span>
<span class="lineno" id=line22></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[t,n:COMPACTLINEAR] ArrayValue[&amp;<span class="library" title="array type, a tuple of all components the same type">array</span>[t,n], &amp;t] {
<span class="lineno" id=line23></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="number of elements in data structure">len</span> (x:&amp;<span class="library" title="array type, a tuple of all components the same type">array</span>[t, n]): <span class="library" title="binding of C size_t type">size</span> =&gt; Typing::arrayindexcount[n];
<span class="lineno" id=line24></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> unsafe_get (<span class="big_keyword" title="Define a mutable variable">var</span> a: &amp;<span class="library" title="array type, a tuple of all components the same type">array</span>[t, n],  j: <span class="library" title="binding of C size_t type">size</span>) : &amp;t  =&gt; a.(aproj (j :&gt;&gt; n) of (&amp;(t^n)));
<span class="lineno" id=line25></span>    }
<span class="lineno" id=line26></span>  
<span class="lineno" id=line27></span>    <span class="doccomment">Pointer to array as value.</span>
<span class="lineno" id=line28></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[t,n:COMPACTLINEAR] ArrayValue[&amp;<span class="library" title="array type, a tuple of all components the same type">array</span>[t,n], _pclt&lt;<span class="library" title="array type, a tuple of all components the same type">array</span>[t,n],t&gt;] {
<span class="lineno" id=line29></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="number of elements in data structure">len</span> (x:&amp;<span class="library" title="array type, a tuple of all components the same type">array</span>[t, n]): <span class="library" title="binding of C size_t type">size</span> =&gt; Typing::arrayindexcount[n];
<span class="lineno" id=line30></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> unsafe_get (<span class="big_keyword" title="Define a mutable variable">var</span> a: &amp;<span class="library" title="array type, a tuple of all components the same type">array</span>[t, n],  j: <span class="library" title="binding of C size_t type">size</span>) : _pclt&lt;<span class="library" title="array type, a tuple of all components the same type">array</span>[t,n],t&gt;  =&gt; a.(aproj (j :&gt;&gt; n) of (&amp;(t^n)));
<span class="lineno" id=line31></span>    }
<span class="lineno" id=line32></span>  
<span class="lineno" id=line33></span>    <span class="doccomment">Compact Linear Pointer to array as value.</span>
<span class="lineno" id=line34></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[t,n:COMPACTLINEAR] ArrayValue[_pclt&lt;<span class="library" title="array type, a tuple of all components the same type">array</span>[t,n],t&gt;, _pclt&lt;<span class="library" title="array type, a tuple of all components the same type">array</span>[t,n],t&gt;] {
<span class="lineno" id=line35></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="number of elements in data structure">len</span> (x:&amp;<span class="library" title="array type, a tuple of all components the same type">array</span>[t, n]): <span class="library" title="binding of C size_t type">size</span> =&gt; Typing::arrayindexcount[n];
<span class="lineno" id=line36></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> unsafe_get (<span class="big_keyword" title="Define a mutable variable">var</span> a: &amp;<span class="library" title="array type, a tuple of all components the same type">array</span>[t, n],  j: <span class="library" title="binding of C size_t type">size</span>) =&gt; a.(aproj (j :&gt;&gt; n) of (&amp;(t^n)));
<span class="lineno" id=line37></span>    }
<span class="lineno" id=line38></span>  
<span class="lineno" id=line39></span>    <span class="comment">// this one should</span>
<span class="lineno" id=line40></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> unsafe_set[t,n:COMPACTLINEAR] (a: &amp;(t^n), i:<span class="library" title="binding of C size_t type">size</span>, v:t) { a . (i.<span class="library" title="binding of C int type">int</span>) &lt;- v; }
<span class="lineno" id=line41></span>  
<span class="lineno" id=line42></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> set[t,n:COMPACTLINEAR, I <span class="small_keyword" title="membership operator, function mem">in</span> ints] (a: &amp;<span class="library" title="array type, a tuple of all components the same type">array</span>[t,n], i:I,v:t) {
<span class="lineno" id=line43></span>      <span class="big_keyword" title="Run time assertion">assert</span> i.<span class="library" title="binding of C size_t type">size</span> &lt; (*a).<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line44></span>      unsafe_set (a,i.<span class="library" title="binding of C size_t type">size</span>,v);
<span class="lineno" id=line45></span>    }
<span class="lineno" id=line46></span>  
<span class="lineno" id=line47></span>    <span class="comment">// these cannot work for compact linear arrays</span>
<span class="lineno" id=line48></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> stl_begin[t,n:COMPACTLINEAR]: &amp;<span class="library" title="array type, a tuple of all components the same type">array</span>[t,n] -&gt; +t = <span class="fstring">"(?1*)($1-&gt;data)"</span>;
<span class="lineno" id=line49></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> stl_end[t,n:COMPACTLINEAR] ( x:&amp;<span class="library" title="array type, a tuple of all components the same type">array</span>[t,n] ) : +t =&gt; stl_begin x + x*.<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line50></span>  
<span class="lineno" id=line51></span>    <span class="doccomment">Array map.</span>
<span class="lineno" id=line52></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="return data structure with function applied to each value">map</span>[V,N:COMPACTLINEAR,U] (_f:V-&gt;U) (x:<span class="library" title="array type, a tuple of all components the same type">array</span>[V,N]):<span class="library" title="array type, a tuple of all components the same type">array</span>[U,N] = {
<span class="lineno" id=line53></span>      <span class="big_keyword" title="Define a mutable variable">var</span> o : <span class="library" title="array type, a tuple of all components the same type">array</span>[U,N];
<span class="lineno" id=line54></span>      <span class="hack">C_hack</span>::ignore(&amp;o); <span class="comment">// fool use before init algo</span>
<span class="lineno" id=line55></span>      <span class="big_keyword" title="Define an immutable value">val</span> n = x.<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line56></span>      <span class="small_keyword" title="conditional">if</span> n &gt; 0uz 
<span class="lineno" id=line57></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i: <span class="library" title="binding of C size_t type">size</span> <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> n - 1uz
<span class="lineno" id=line58></span>          <span class="small_keyword" title="call a procedure">call</span> set (&amp;o,i, _f x.i)
<span class="lineno" id=line59></span>      ;
<span class="lineno" id=line60></span>      <span class="small_keyword" title="return">return</span> o;
<span class="lineno" id=line61></span>    }
<span class="lineno" id=line62></span>  
<span class="lineno" id=line63></span>    <span class="comment">// not very efficient!</span>
<span class="lineno" id=line64></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> rev_map[V,N:COMPACTLINEAR,U] (_f:V-&gt;U) (x:<span class="library" title="array type, a tuple of all components the same type">array</span>[V,N]):<span class="library" title="array type, a tuple of all components the same type">array</span>[U,N] =&gt; 
<span class="lineno" id=line65></span>      <span class="library" title="return data structure with elements reversed">rev</span> (<span class="library" title="return data structure with function applied to each value">map</span> _f x)
<span class="lineno" id=line66></span>    ;
<span class="lineno" id=line67></span>  
<span class="lineno" id=line68></span>    <span class="comment">// Note: for many loops below, note we're using unsigned values</span>
<span class="lineno" id=line69></span>    <span class="comment">// iterating from 0 to N-1. Subtraction N-1 fails for n == 0</span>
<span class="lineno" id=line70></span>    <span class="comment">// so we need a special test. </span>
<span class="lineno" id=line71></span>  
<span class="lineno" id=line72></span>    <span class="doccomment">Join two arrays (functional).</span>
<span class="lineno" id=line73></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> join[T, N:UNITSUM, M:UNITSUM] (x:<span class="library" title="array type, a tuple of all components the same type">array</span>[T, N]) (y:<span class="library" title="array type, a tuple of all components the same type">array</span>[T, M]):<span class="library" title="array type, a tuple of all components the same type">array</span>[T, N `+ M] = {
<span class="lineno" id=line74></span>      <span class="big_keyword" title="Define a mutable variable">var</span> o : <span class="library" title="array type, a tuple of all components the same type">array</span>[T, N `+ M];
<span class="lineno" id=line75></span>      <span class="hack">C_hack</span>::ignore(&amp;o); <span class="comment">// fool use before init algo</span>
<span class="lineno" id=line76></span>      <span class="small_keyword" title="conditional">if</span> x.<span class="library" title="number of elements in data structure">len</span> &gt; 0uz
<span class="lineno" id=line77></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> <span class="library" title="number of elements in data structure">len</span>(x) - 1uz
<span class="lineno" id=line78></span>          <span class="small_keyword" title="call a procedure">call</span> set (&amp;o, i,x.i)
<span class="lineno" id=line79></span>      ;
<span class="lineno" id=line80></span>      i = x.<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line81></span>      <span class="small_keyword" title="conditional">if</span> y.<span class="library" title="number of elements in data structure">len</span> &gt; 0uz
<span class="lineno" id=line82></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> k <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> <span class="library" title="number of elements in data structure">len</span>(y) - 1uz
<span class="lineno" id=line83></span>          <span class="small_keyword" title="call a procedure">call</span> set(&amp;o,i + k, y.k)
<span class="lineno" id=line84></span>      ;
<span class="lineno" id=line85></span>      <span class="small_keyword" title="return">return</span> o;
<span class="lineno" id=line86></span>    }
<span class="lineno" id=line87></span>  
<span class="lineno" id=line88></span>    <span class="comment">// this routine SHOULD check FIRST + LEN &lt;= N</span>
<span class="lineno" id=line89></span>    <span class="comment">// we can perform that calculation now .. but there's no way yet to assert it</span>
<span class="lineno" id=line90></span>    <span class="comment">// we can, actually, add it as a constraint ..</span>
<span class="lineno" id=line91></span>    <span class="comment">// but we want the constraint to fail on monomorphisation</span>
<span class="lineno" id=line92></span>    <span class="comment">// NOT during overload resolution .. because that would just reject</span>
<span class="lineno" id=line93></span>    <span class="comment">// the candidate and lead to a not found error instead of a constraint violation error....</span>
<span class="lineno" id=line94></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> subarray[
<span class="lineno" id=line95></span>      FIRST:UNITSUM,
<span class="lineno" id=line96></span>      LEN:UNITSUM,
<span class="lineno" id=line97></span>      T,
<span class="lineno" id=line98></span>      N:UNITSUM, 
<span class="lineno" id=line99></span>      K:UNITSUM=_unitsum_min(LEN, N `- FIRST)
<span class="lineno" id=line100></span>    ] 
<span class="lineno" id=line101></span>    (a:T^N) : T ^ K
<span class="lineno" id=line102></span>    = 
<span class="lineno" id=line103></span>    {
<span class="lineno" id=line104></span>      <span class="hack">C_hack</span>::ignore(&amp;o); <span class="comment">// fool use before init algo</span>
<span class="lineno" id=line105></span>      <span class="big_keyword" title="Define a mutable variable">var</span> o : T ^ K;
<span class="lineno" id=line106></span>      <span class="small_keyword" title="for loop">for</span> i <span class="small_keyword" title="membership operator, function mem">in</span> ..[K] <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line107></span>        <span class="big_keyword" title="Define a mutable variable">var</span> first = Typing::arrayindexcount[FIRST].<span class="library" title="binding of C int type">int</span>;
<span class="lineno" id=line108></span>        <span class="big_keyword" title="Define a mutable variable">var</span> outix = <span class="small_keyword" title="Integer index of value of a sum type">caseno</span> i;
<span class="lineno" id=line109></span>        <span class="big_keyword" title="Define a mutable variable">var</span> inpix = (first + outix) :&gt;&gt; N; <span class="comment">// checked at run time?</span>
<span class="lineno" id=line110></span>        &amp;o.i &lt;- a.inpix;
<span class="lineno" id=line111></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line112></span>      <span class="small_keyword" title="return">return</span> o;
<span class="lineno" id=line113></span>    }
<span class="lineno" id=line114></span>  
<span class="lineno" id=line115></span>  
<span class="lineno" id=line116></span>    <span class="doccomment">Append value to end of an array (functional).</span>
<span class="lineno" id=line117></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> join[T, N:UNITSUM] (x:<span class="library" title="array type, a tuple of all components the same type">array</span>[T, N]) (y:T):<span class="library" title="array type, a tuple of all components the same type">array</span>[T, N `+ 1] = {
<span class="lineno" id=line118></span>      <span class="big_keyword" title="Define a mutable variable">var</span> o : <span class="library" title="array type, a tuple of all components the same type">array</span>[T, N `+ 1];
<span class="lineno" id=line119></span>      <span class="hack">C_hack</span>::ignore(&amp;o); <span class="comment">// fool use before init algo</span>
<span class="lineno" id=line120></span>  
<span class="lineno" id=line121></span>      <span class="small_keyword" title="conditional">if</span> x.<span class="library" title="number of elements in data structure">len</span> &gt; 0uz
<span class="lineno" id=line122></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> <span class="library" title="number of elements in data structure">len</span>(x) - 1uz
<span class="lineno" id=line123></span>          <span class="small_keyword" title="call a procedure">call</span> set (&amp;o, i,x.i)
<span class="lineno" id=line124></span>      ;
<span class="lineno" id=line125></span>      set(&amp;o,x.<span class="library" title="number of elements in data structure">len</span>, y);
<span class="lineno" id=line126></span>      <span class="small_keyword" title="return">return</span> o;
<span class="lineno" id=line127></span>    }
<span class="lineno" id=line128></span>  
<span class="lineno" id=line129></span>    <span class="doccomment">Prepand value to start of an array (functional).</span>
<span class="lineno" id=line130></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> join[T, M:UNITSUM] (x:T) (y:<span class="library" title="array type, a tuple of all components the same type">array</span>[T, M]):<span class="library" title="array type, a tuple of all components the same type">array</span>[T, 1 `+ M] = {
<span class="lineno" id=line131></span>      <span class="big_keyword" title="Define a mutable variable">var</span> o : <span class="library" title="array type, a tuple of all components the same type">array</span>[T, 1 `+ M];
<span class="lineno" id=line132></span>  
<span class="lineno" id=line133></span>      set (&amp;o, 0, x);
<span class="lineno" id=line134></span>      <span class="small_keyword" title="conditional">if</span> y.<span class="library" title="number of elements in data structure">len</span> &gt; 0uz
<span class="lineno" id=line135></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> k <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> <span class="library" title="number of elements in data structure">len</span>(y) - 1uz
<span class="lineno" id=line136></span>          <span class="small_keyword" title="call a procedure">call</span> set(&amp;o,1uz + k, y.k)
<span class="lineno" id=line137></span>      ;
<span class="lineno" id=line138></span>      <span class="small_keyword" title="return">return</span> o;
<span class="lineno" id=line139></span>    }
<span class="lineno" id=line140></span>  
<span class="lineno" id=line141></span>  
<span class="lineno" id=line142></span>    <span class="doccomment">Join two arrays (functional).</span>
<span class="lineno" id=line143></span>    <span class="comment">// will probably clash with tuple joining functions if we implement them</span>
<span class="lineno" id=line144></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> + [T, N:UNITSUM, M:UNITSUM] (x:<span class="library" title="array type, a tuple of all components the same type">array</span>[T, N], y:<span class="library" title="array type, a tuple of all components the same type">array</span>[T, M]):<span class="library" title="array type, a tuple of all components the same type">array</span>[T, N `+ M] =&gt; join x y;
<span class="lineno" id=line145></span>  
<span class="lineno" id=line146></span>    <span class="doccomment">Transpose and array.</span>
<span class="lineno" id=line147></span>    <span class="doccomment">Subsumes zip.</span>
<span class="lineno" id=line148></span>    <span class="doccomment">Example: transpose ( (1,2,3), (4,5,6) ) = ( (1,4), (2,5), (3,6) ).</span>
<span class="lineno" id=line149></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> transpose[T,N:COMPACTLINEAR,M:COMPACTLINEAR] (y:<span class="library" title="array type, a tuple of all components the same type">array</span>[<span class="library" title="array type, a tuple of all components the same type">array</span>[T,M],N]) : <span class="library" title="array type, a tuple of all components the same type">array</span>[<span class="library" title="array type, a tuple of all components the same type">array</span>[T,N],M] = {
<span class="lineno" id=line150></span>      <span class="big_keyword" title="Define a mutable variable">var</span> o : <span class="library" title="array type, a tuple of all components the same type">array</span>[<span class="library" title="array type, a tuple of all components the same type">array</span>[T,N],M];
<span class="lineno" id=line151></span>      <span class="hack">C_hack</span>::ignore(&amp;o); <span class="comment">// fool use before init algo</span>
<span class="lineno" id=line152></span>      <span class="big_keyword" title="Define a mutable variable">var</span> n = <span class="library" title="number of elements in data structure">len</span> y;
<span class="lineno" id=line153></span>      <span class="big_keyword" title="Define a mutable variable">var</span> m = <span class="library" title="number of elements in data structure">len</span> y.0;
<span class="lineno" id=line154></span>      <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> n - 1uz 
<span class="lineno" id=line155></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> j <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> m - 1uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line156></span>          <span class="big_keyword" title="Define an immutable value">val</span> pfirst : +<span class="library" title="array type, a tuple of all components the same type">array</span>[T,N] = &amp;o.stl_begin;
<span class="lineno" id=line157></span>          <span class="big_keyword" title="Define an immutable value">val</span> psub: +<span class="library" title="array type, a tuple of all components the same type">array</span>[T,N] = pfirst + j;
<span class="lineno" id=line158></span>          <span class="big_keyword" title="Define an immutable value">val</span> pelt : +T = psub.stl_begin;
<span class="lineno" id=line159></span>          set(pelt,i, y.i.j);
<span class="lineno" id=line160></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line161></span>      <span class="small_keyword" title="return">return</span> o;
<span class="lineno" id=line162></span>    }
<span class="lineno" id=line163></span>  
<span class="lineno" id=line164></span>    <span class="doccomment">Reverse elements of an array.</span>
<span class="lineno" id=line165></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="return data structure with elements reversed">rev</span>[T, N:COMPACTLINEAR] (x:<span class="library" title="array type, a tuple of all components the same type">array</span>[T, N]): <span class="library" title="array type, a tuple of all components the same type">array</span>[T, N] = {
<span class="lineno" id=line166></span>      <span class="big_keyword" title="Define a mutable variable">var</span> o : <span class="library" title="array type, a tuple of all components the same type">array</span>[T, N];
<span class="lineno" id=line167></span>      <span class="big_keyword" title="Define a mutable variable">var</span> n = <span class="library" title="number of elements in data structure">len</span> x;
<span class="lineno" id=line168></span>      <span class="hack">C_hack</span>::ignore(&amp;o); <span class="comment">// to fool use before init</span>
<span class="lineno" id=line169></span>      <span class="small_keyword" title="conditional">if</span> n &gt; 0uz
<span class="lineno" id=line170></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i:<span class="library" title="binding of C size_t type">size</span> <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> n - 1uz
<span class="lineno" id=line171></span>          <span class="small_keyword" title="call a procedure">call</span> set(&amp;o,n - 1uz - i, x.i)
<span class="lineno" id=line172></span>      ;
<span class="lineno" id=line173></span>      <span class="small_keyword" title="return">return</span> o;
<span class="lineno" id=line174></span>    }
<span class="lineno" id=line175></span>  
<span class="lineno" id=line176></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> sort[T,N:COMPACTLINEAR] (cmp: T * T -&gt; bool) (<span class="big_keyword" title="Define a mutable variable">var</span> x:<span class="library" title="array type, a tuple of all components the same type">array</span>[T,N]) : <span class="library" title="array type, a tuple of all components the same type">array</span>[T,N] = {
<span class="lineno" id=line177></span>      Sort::stl_sort (Sort::stl_comparator cmp, stl_begin (&amp;x), stl_end (&amp;x));
<span class="lineno" id=line178></span>      <span class="small_keyword" title="return">return</span> x;
<span class="lineno" id=line179></span>    }
<span class="lineno" id=line180></span>  
<span class="lineno" id=line181></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> sort[T,N:COMPACTLINEAR] (<span class="big_keyword" title="Define a mutable variable">var</span> x:<span class="library" title="array type, a tuple of all components the same type">array</span>[T,N]) : <span class="library" title="array type, a tuple of all components the same type">array</span>[T,N] = {
<span class="lineno" id=line182></span>      Sort::stl_sort (stl_begin (&amp;x), stl_end (&amp;x));
<span class="lineno" id=line183></span>      <span class="small_keyword" title="return">return</span> x;
<span class="lineno" id=line184></span>    }
<span class="lineno" id=line185></span>  
<span class="lineno" id=line186></span>  
<span class="lineno" id=line187></span>    <span class="doccomment">Display: convert to string like (1,2,3).</span>
<span class="lineno" id=line188></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[T,N:COMPACTLINEAR <span class="small_keyword" title="type-class constraint">with</span> Show[T]] Str[<span class="library" title="array type, a tuple of all components the same type">array</span>[T, N]] {
<span class="lineno" id=line189></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="Convert a value to a string">str</span> (xs:<span class="library" title="array type, a tuple of all components the same type">array</span>[T,N]) = {
<span class="lineno" id=line190></span>        <span class="big_keyword" title="Define a mutable variable">var</span> o = <span class="fstring">'('</span>;
<span class="lineno" id=line191></span>        <span class="big_keyword" title="Define an immutable value">val</span> n = xs.<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line192></span>        <span class="small_keyword" title="conditional">if</span> n  &gt; 0uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line193></span>          o += repr xs.0;
<span class="lineno" id=line194></span>  
<span class="lineno" id=line195></span>          <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i:<span class="library" title="binding of C size_t type">size</span> <span class="small_keyword" title="membership operator, function mem">in</span> 1uz <span class="small_keyword" title="upwards counting for loop">upto</span> n - 1uz
<span class="lineno" id=line196></span>            perform o += <span class="fstring">', '</span> + repr xs.i
<span class="lineno" id=line197></span>          ;
<span class="lineno" id=line198></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line199></span>        <span class="small_keyword" title="return">return</span> o + <span class="fstring">')'</span>;
<span class="lineno" id=line200></span>      }
<span class="lineno" id=line201></span>    }
<span class="lineno" id=line202></span>  
<span class="lineno" id=line203></span>    <span class="doccomment">Equality and Inequality.</span>
<span class="lineno" id=line204></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[T,N:COMPACTLINEAR <span class="small_keyword" title="type-class constraint">with</span> Eq[T]] Eq[<span class="library" title="array type, a tuple of all components the same type">array</span>[T, N]] {
<span class="lineno" id=line205></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> == (xs:<span class="library" title="array type, a tuple of all components the same type">array</span>[T,N],ys:<span class="library" title="array type, a tuple of all components the same type">array</span>[T,N]) = {
<span class="lineno" id=line206></span>        <span class="big_keyword" title="Define an immutable value">val</span> n = xs.<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line207></span>        <span class="comment">// assert n == ys.len;</span>
<span class="lineno" id=line208></span>        <span class="small_keyword" title="conditional">if</span> n == 0uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line209></span>          <span class="small_keyword" title="return">return</span> <span class="library" title="truth value">true</span>;
<span class="lineno" id=line210></span>        <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line211></span>          <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i:<span class="library" title="binding of C size_t type">size</span> <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> n - 1uz
<span class="lineno" id=line212></span>            <span class="small_keyword" title="conditional">if</span> <span class="small_keyword" title="logical negation">not</span> (xs.i == ys.i) <span class="small_keyword" title="return">return</span> <span class="library" title="false value">false</span>;
<span class="lineno" id=line213></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line214></span>        <span class="small_keyword" title="return">return</span> <span class="library" title="truth value">true</span>;
<span class="lineno" id=line215></span>      }
<span class="lineno" id=line216></span>    }
<span class="lineno" id=line217></span>  
<span class="lineno" id=line218></span>    <span class="doccomment">Lexicographical total order based on</span>
<span class="lineno" id=line219></span>    <span class="doccomment">total order of elements.</span>
<span class="lineno" id=line220></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[T,N:COMPACTLINEAR <span class="small_keyword" title="type-class constraint">with</span> Tord[T]] Tord[<span class="library" title="array type, a tuple of all components the same type">array</span>[T,N]] {
<span class="lineno" id=line221></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> &lt; (xs:<span class="library" title="array type, a tuple of all components the same type">array</span>[T,N],ys:<span class="library" title="array type, a tuple of all components the same type">array</span>[T,N]) = {
<span class="lineno" id=line222></span>        <span class="big_keyword" title="Define an immutable value">val</span> n = xs.<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line223></span>        <span class="small_keyword" title="conditional">if</span> n == 0uz <span class="small_keyword" title="return">return</span> <span class="library" title="false value">false</span>;
<span class="lineno" id=line224></span>        <span class="comment">// assert n == ys.len;</span>
<span class="lineno" id=line225></span>        <span class="big_keyword" title="Define a mutable variable">var</span> i:<span class="library" title="binding of C size_t type">size</span>;
<span class="lineno" id=line226></span>        ph1:<span class="small_keyword" title="for loop">for</span> i <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> n - 1uz
<span class="lineno" id=line227></span>          <span class="small_keyword" title="conditional">if</span> <span class="small_keyword" title="logical negation">not</span> (xs.i &lt; ys.i) break ph1;
<span class="lineno" id=line228></span>        <span class="small_keyword" title="for loop">for</span> i <span class="small_keyword" title="membership operator, function mem">in</span> i <span class="small_keyword" title="upwards counting for loop">upto</span> n - 1uz
<span class="lineno" id=line229></span>          <span class="small_keyword" title="conditional">if</span> <span class="small_keyword" title="logical negation">not</span> (xs.i &lt;= ys.i) <span class="small_keyword" title="return">return</span> <span class="library" title="false value">false</span>;
<span class="lineno" id=line230></span>        <span class="small_keyword" title="return">return</span> <span class="library" title="truth value">true</span>;
<span class="lineno" id=line231></span>      }
<span class="lineno" id=line232></span>    }
<span class="lineno" id=line233></span>  }
<span class="lineno" id=line234></span>  
<span class="lineno" id=line235></span>  <span class="big_keyword" title="Open a module or class">open</span>[T,N:COMPACTLINEAR] Eq[<span class="library" title="array type, a tuple of all components the same type">array</span>[T,N]];
<span class="lineno" id=line236></span>  <span class="big_keyword" title="Open a module or class">open</span>[T,N:COMPACTLINEAR] Tord[<span class="library" title="array type, a tuple of all components the same type">array</span>[T,N]];
<span class="lineno" id=line237></span>  <span class="big_keyword" title="Open a module or class">open</span>[T,N:COMPACTLINEAR <span class="small_keyword" title="type-class constraint">with</span> Eq[T]] Set[<span class="library" title="array type, a tuple of all components the same type">array</span>[T,N],T];
<span class="lineno" id=line238></span>  
<span class="lineno" id=line239></span>  <span class="big_keyword" title="Open a module or class">open</span>[T,N:COMPACTLINEAR] ArrayValue[<span class="library" title="array type, a tuple of all components the same type">array</span>[T,N], T];
<span class="lineno" id=line240></span>  <span class="big_keyword" title="Open a module or class">open</span>[T,N:COMPACTLINEAR] ArrayValue[&amp;<span class="library" title="array type, a tuple of all components the same type">array</span>[T,N], &amp;T];
<span class="lineno" id=line241></span>  
</pre></p></div><h1 id='Varray_h'><img src='/share/src/web/images/minus.gif' id='Varray' onclick='toggle(this,"Varray_d")' alt='+'/> 3 Varray</h1><div id='Varray_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/varray.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="doccomment">Bounded Variable length arrays, bound set at construction time.</span>
<span class="lineno" id=line3></span>  <span class="doccomment">A bound of 0 is allowed, the result is a NULL pointer.</span>
<span class="lineno" id=line4></span>  
<span class="lineno" id=line5></span>  <span class="big_keyword" title="Open a module or class">open</span> <span class="big_keyword" title="Define a type class">class</span> Varray
<span class="lineno" id=line6></span>  {
<span class="lineno" id=line7></span>    <span class="doccomment">A varray is just a pointer. </span>
<span class="lineno" id=line8></span>    <span class="doccomment">The current length and bound are maintained by the GC.</span>
<span class="lineno" id=line9></span>    _gc_pointer <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t] = <span class="fstring">"?1*"</span>;
<span class="lineno" id=line10></span>  
<span class="lineno" id=line11></span>    <span class="doccomment">An ordinary carray, but owned by the GC.</span>
<span class="lineno" id=line12></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span>[t] carray[t] : <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t] = <span class="fstring">"$1"</span>;
<span class="lineno" id=line13></span>  
<span class="lineno" id=line14></span>    <span class="doccomment">Create an empty varray with the given bound.</span>
<span class="lineno" id=line15></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span>[t] <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t]: <span class="library" title="binding of C size_t type">size</span> =
<span class="lineno" id=line16></span>      <span class="fstring">"(?1*)(ptf-&gt; gcp-&gt;collector-&gt;create_empty_array(&amp;@?1,$1))"</span>
<span class="lineno" id=line17></span>      <span class="big_keyword" title="specify requirements">requires</span> property <span class="fstring">"needs_gc"</span>
<span class="lineno" id=line18></span>    ;
<span class="lineno" id=line19></span>  
<span class="lineno" id=line20></span>    <span class="doccomment">Raw memory initialisation (really, this belongs in C_hack).</span>
<span class="lineno" id=line21></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> _init[T]: &amp;T * T = <span class="fstring">"new((void*)$1) ?1($2);"</span>;
<span class="lineno" id=line22></span>   
<span class="lineno" id=line23></span>  
<span class="lineno" id=line24></span>    <span class="doccomment">Construct a varray filled up with a default value.</span>
<span class="lineno" id=line25></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span>[t] <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t] (bound:<span class="library" title="binding of C size_t type">size</span>, default:t) = {
<span class="lineno" id=line26></span>      <span class="big_keyword" title="Define a mutable variable">var</span> o = <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t] bound;
<span class="lineno" id=line27></span>      <span class="small_keyword" title="conditional">if</span> o.maxlen != bound <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line28></span>        eprintln$ <span class="fstring">"Constructor failed, wrong bound"</span>;
<span class="lineno" id=line29></span>        eprintln$ <span class="fstring">"input Bound = "</span> + bound.<span class="library" title="Convert a value to a string">str</span> + <span class="fstring">", actual maxlen = "</span> + o.maxlen.<span class="library" title="Convert a value to a string">str</span>;
<span class="lineno" id=line30></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line31></span>      <span class="small_keyword" title="conditional">if</span> bound &gt; 0uz <span class="small_keyword" title="imperative code begins">do</span> <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> bound - 1uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line32></span>      <span class="small_keyword" title="conditional">if</span> o.<span class="library" title="number of elements in data structure">len</span> &gt;= o.maxlen <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line33></span>        eprintln (<span class="fstring">"ctor1: attempt to push_back on full varray size "</span> + o.maxlen.<span class="library" title="Convert a value to a string">str</span>);
<span class="lineno" id=line34></span>        eprintln$ <span class="fstring">"bound = "</span> + bound.<span class="library" title="Convert a value to a string">str</span>;
<span class="lineno" id=line35></span>        eprintln$ <span class="fstring">"index = "</span> + i.<span class="library" title="Convert a value to a string">str</span>;
<span class="lineno" id=line36></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line37></span>        push_back(o, default);
<span class="lineno" id=line38></span>      <span class="small_keyword" title="end of body">done</span> <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line39></span>      <span class="small_keyword" title="return">return</span> o;
<span class="lineno" id=line40></span>    }
<span class="lineno" id=line41></span>  
<span class="lineno" id=line42></span>    <span class="doccomment">Construct a partially filled varray with a default value computed by a function.</span>
<span class="lineno" id=line43></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span>[t] <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t] (bound:<span class="library" title="binding of C size_t type">size</span>, used:<span class="library" title="binding of C size_t type">size</span>, f:size-&gt;t <span class="small_keyword" title="predicative type constraint or precondition">when</span> used &lt;= bound) = {
<span class="lineno" id=line44></span>      <span class="big_keyword" title="Define a mutable variable">var</span> o = <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t] bound;
<span class="lineno" id=line45></span>      <span class="small_keyword" title="conditional">if</span> used &gt; 0uz <span class="small_keyword" title="imperative code begins">do</span> <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> used - 1uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line46></span>      <span class="small_keyword" title="conditional">if</span> o.<span class="library" title="number of elements in data structure">len</span> &gt;= o.maxlen <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line47></span>        eprintln (<span class="fstring">"ctor2: attempt to push_back on full varray size "</span> + o.maxlen.<span class="library" title="Convert a value to a string">str</span>);
<span class="lineno" id=line48></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line49></span>        push_back(o, f i);
<span class="lineno" id=line50></span>      <span class="small_keyword" title="end of body">done</span> <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line51></span>      <span class="small_keyword" title="return">return</span> o;
<span class="lineno" id=line52></span>    }
<span class="lineno" id=line53></span>  
<span class="lineno" id=line54></span>    <span class="doccomment">Construct a full varray from an array.</span>
<span class="lineno" id=line55></span>    <span class="comment">// funny, the N isn't explicitly used.</span>
<span class="lineno" id=line56></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span>[t,N:COMPACTLINEAR] <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t] (x:<span class="library" title="array type, a tuple of all components the same type">array</span>[t,N]) =&gt; 
<span class="lineno" id=line57></span>       <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t] (<span class="library" title="number of elements in data structure">len</span> x, <span class="library" title="number of elements in data structure">len</span> x, (<span class="big_keyword" title="Define a function with no side-effects">fun</span> (i:<span class="library" title="binding of C size_t type">size</span>):t =&gt;x.i))
<span class="lineno" id=line58></span>    ;
<span class="lineno" id=line59></span>  
<span class="lineno" id=line60></span>    <span class="doccomment">Construct a partially full varray from a varray.</span>
<span class="lineno" id=line61></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span>[t] <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t] (x:<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t], maxlen:<span class="library" title="binding of C size_t type">size</span>) =&gt;
<span class="lineno" id=line62></span>      <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t] (maxlen, min(maxlen,<span class="library" title="number of elements in data structure">len</span> x), (<span class="big_keyword" title="Define a function with no side-effects">fun</span> (i:<span class="library" title="binding of C size_t type">size</span>):t=&gt; x.i))
<span class="lineno" id=line63></span>    ;
<span class="lineno" id=line64></span>  
<span class="lineno" id=line65></span>    <span class="doccomment">Construct a full varray from a varray (copy constructor).</span>
<span class="lineno" id=line66></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span>[t] <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t] (x:<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t]) =&gt;
<span class="lineno" id=line67></span>      <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t] (<span class="library" title="number of elements in data structure">len</span> x, <span class="library" title="number of elements in data structure">len</span> x, (<span class="big_keyword" title="Define a function with no side-effects">fun</span> (i:<span class="library" title="binding of C size_t type">size</span>):t=&gt; x.i))
<span class="lineno" id=line68></span>    ;
<span class="lineno" id=line69></span>  
<span class="lineno" id=line70></span>    <span class="comment">// Construct a varray from a list</span>
<span class="lineno" id=line71></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span>[t] <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t] (x:<span class="library" title="functional, singly linked list">list</span>[t]) = {
<span class="lineno" id=line72></span>      <span class="big_keyword" title="Define an immutable value">val</span> n = x.<span class="library" title="number of elements in data structure">len</span>.<span class="library" title="binding of C size_t type">size</span>;
<span class="lineno" id=line73></span>      <span class="big_keyword" title="Define a mutable variable">var</span> a = <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t] n;
<span class="lineno" id=line74></span>      <span class="library" title="call procedure on each element of data structure">iter</span> (<span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> (v:t) { 
<span class="lineno" id=line75></span>        <span class="small_keyword" title="conditional">if</span> a.<span class="library" title="number of elements in data structure">len</span> &gt;= a.maxlen <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line76></span>          eprintln (<span class="fstring">"ctor3: attempt to push_back on full varray size "</span> + a.maxlen.<span class="library" title="Convert a value to a string">str</span>);
<span class="lineno" id=line77></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line78></span>        push_back(a,v); 
<span class="lineno" id=line79></span>       }) x;
<span class="lineno" id=line80></span>      <span class="small_keyword" title="return">return</span> a;
<span class="lineno" id=line81></span>    }
<span class="lineno" id=line82></span>  
<span class="lineno" id=line83></span>    <span class="doccomment">Construct a varray from a string.</span>
<span class="lineno" id=line84></span>    <span class="doccomment">Include a trailing nul byte.</span>
<span class="lineno" id=line85></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[<span class="library" title="binding of C char type">char</span>] (<span class="big_keyword" title="Define a mutable variable">var</span> x:<span class="library" title="binding of C++ string type">string</span>) = {
<span class="lineno" id=line86></span>      <span class="big_keyword" title="Define a mutable variable">var</span> n = x.<span class="library" title="number of elements in data structure">len</span>; 
<span class="lineno" id=line87></span>      <span class="big_keyword" title="Define a mutable variable">var</span> v = <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[<span class="library" title="binding of C char type">char</span>] (n + 1uz);
<span class="lineno" id=line88></span>      <span class="big_keyword" title="Define a mutable variable">var</span> p = &amp;x.stl_begin;
<span class="lineno" id=line89></span>      <span class="big_keyword" title="Define a mutable variable">var</span> q = v.stl_begin;
<span class="lineno" id=line90></span>      Memory::memcpy (q.<span class="library" title="special binding of C void* type">address</span>, p.<span class="library" title="special binding of C void* type">address</span>, n);
<span class="lineno" id=line91></span>      set(q,n, <span class="library" title="binding of C char type">char</span> <span class="fstring">""</span>);
<span class="lineno" id=line92></span>      set_used (v,n + 1uz);
<span class="lineno" id=line93></span>      <span class="small_keyword" title="return">return</span> v;
<span class="lineno" id=line94></span>    } 
<span class="lineno" id=line95></span>  
<span class="lineno" id=line96></span>    <span class="doccomment">Construct a varray from a string.</span>
<span class="lineno" id=line97></span>    <span class="doccomment">Exclude trailing nul byte.</span>
<span class="lineno" id=line98></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> varray_nonul (<span class="big_keyword" title="Define a mutable variable">var</span> x:<span class="library" title="binding of C++ string type">string</span>) = {
<span class="lineno" id=line99></span>      <span class="big_keyword" title="Define a mutable variable">var</span> n = x.<span class="library" title="number of elements in data structure">len</span>; 
<span class="lineno" id=line100></span>      <span class="big_keyword" title="Define a mutable variable">var</span> v = <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[<span class="library" title="binding of C char type">char</span>] (n);
<span class="lineno" id=line101></span>      <span class="big_keyword" title="Define a mutable variable">var</span> q = v.stl_begin;
<span class="lineno" id=line102></span>      <span class="big_keyword" title="Define a mutable variable">var</span> p = &amp;x.stl_begin;
<span class="lineno" id=line103></span>      Memory::memcpy (q.<span class="library" title="special binding of C void* type">address</span>, p.<span class="library" title="special binding of C void* type">address</span>, n);
<span class="lineno" id=line104></span>      set_used (v,n);
<span class="lineno" id=line105></span>      <span class="small_keyword" title="return">return</span> v;
<span class="lineno" id=line106></span>    } 
<span class="lineno" id=line107></span>  
<span class="lineno" id=line108></span>  
<span class="lineno" id=line109></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> set_used[t]: <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t] * <span class="library" title="binding of C size_t type">size</span> =
<span class="lineno" id=line110></span>      <span class="fstring">"ptf-&gt; gcp-&gt;collector-&gt;set_used($1,$2);"</span>
<span class="lineno" id=line111></span>      <span class="big_keyword" title="specify requirements">requires</span> property <span class="fstring">"needs_gc"</span>
<span class="lineno" id=line112></span>    ;
<span class="lineno" id=line113></span>  
<span class="lineno" id=line114></span>    <span class="doccomment">Treat a varray as an ArrayValue.</span>
<span class="lineno" id=line115></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[v] ArrayValue[<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[v],v] {
<span class="lineno" id=line116></span>      <span class="doccomment">Length of a varray (used).</span>
<span class="lineno" id=line117></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="number of elements in data structure">len</span>: <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[v] -&gt; <span class="library" title="binding of C size_t type">size</span> =
<span class="lineno" id=line118></span>        <span class="fstring">"ptf-&gt; gcp-&gt;collector-&gt;get_used($1)"</span>
<span class="lineno" id=line119></span>        <span class="big_keyword" title="specify requirements">requires</span> property <span class="fstring">"needs_gc"</span>
<span class="lineno" id=line120></span>      ;
<span class="lineno" id=line121></span>      <span class="doccomment">Unsafe get value at position.</span>
<span class="lineno" id=line122></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> unsafe_get: <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[v] * <span class="library" title="binding of C size_t type">size</span> -&gt; v = <span class="fstring">"$1[$2]"</span>;
<span class="lineno" id=line123></span>    } 
<span class="lineno" id=line124></span>  
<span class="lineno" id=line125></span>    <span class="doccomment">Treat a varray as an ArrayObject.</span>
<span class="lineno" id=line126></span>    <span class="doccomment">Allows modifications.</span>
<span class="lineno" id=line127></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[v] ArrayObject[<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[v],v] {
<span class="lineno" id=line128></span>      <span class="doccomment">Store the given value at the given position.</span>
<span class="lineno" id=line129></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> unsafe_set: <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[v] * <span class="library" title="binding of C size_t type">size</span> * v = <span class="fstring">"$1[$2]=$3;"</span>;
<span class="lineno" id=line130></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> unsafe_get_ref: <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[v] * <span class="library" title="binding of C size_t type">size</span> -&gt; &amp;v = <span class="fstring">"$1+$2"</span>;
<span class="lineno" id=line131></span>    }
<span class="lineno" id=line132></span>  
<span class="lineno" id=line133></span>    <span class="doccomment">Treat a varray as a ContiguousArrayObject.</span>
<span class="lineno" id=line134></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[v] ContiguousArrayObject[<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[v],v] {
<span class="lineno" id=line135></span>      <span class="doccomment">STL iterator to start of array.</span>
<span class="lineno" id=line136></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> stl_begin: <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[v] -&gt; +v = <span class="fstring">"$1"</span>;
<span class="lineno" id=line137></span>  
<span class="lineno" id=line138></span>      <span class="doccomment">STL iterator to end of array.</span>
<span class="lineno" id=line139></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> stl_end: <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[v] -&gt; +v = <span class="fstring">"($1+ptf-&gt; gcp-&gt;collector-&gt;get_used($1))"</span>;
<span class="lineno" id=line140></span>    }
<span class="lineno" id=line141></span>  
<span class="lineno" id=line142></span>    <span class="doccomment">Get the bound of a varray.</span>
<span class="lineno" id=line143></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> maxlen[t]: <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t] -&gt; <span class="library" title="binding of C size_t type">size</span> =
<span class="lineno" id=line144></span>      <span class="fstring">"ptf-&gt; gcp-&gt;collector-&gt;get_count($1)"</span>
<span class="lineno" id=line145></span>      <span class="big_keyword" title="specify requirements">requires</span> property <span class="fstring">"needs_gc"</span>
<span class="lineno" id=line146></span>    ;
<span class="lineno" id=line147></span>  
<span class="lineno" id=line148></span>    <span class="doccomment">Append a new element to the end of a varray.</span>
<span class="lineno" id=line149></span>    <span class="doccomment">Aborts if you go past the bound.</span>
<span class="lineno" id=line150></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> += [t] (pa:&amp;<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t],v:t) { 
<span class="lineno" id=line151></span>      <span class="small_keyword" title="conditional">if</span> pa*.<span class="library" title="number of elements in data structure">len</span> &gt;= pa*.maxlen <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line152></span>        eprintln (<span class="fstring">"attempt to += on full varray size "</span> + (pa*.maxlen).<span class="library" title="Convert a value to a string">str</span>);
<span class="lineno" id=line153></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line154></span>      push_back (*pa,v); 
<span class="lineno" id=line155></span>    }
<span class="lineno" id=line156></span>  
<span class="lineno" id=line157></span>    <span class="doccomment">Append a new element to the end of a varray.</span>
<span class="lineno" id=line158></span>    <span class="doccomment">Aborts if you go past the bound.</span>
<span class="lineno" id=line159></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> _push_back[t] : <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t] * t = <span class="fstring">"""
<span class="lineno" id=line160></span>      {
<span class="lineno" id=line161></span>        //?1 * _p = *$1;
<span class="lineno" id=line162></span>        size_t n = ptf-&gt; gcp-&gt;collector-&gt;get_used($1);
<span class="lineno" id=line163></span>        ptf-&gt; gcp-&gt;collector-&gt;incr_used($1,1L);
<span class="lineno" id=line164></span>        new($1+n) ?1($2);
<span class="lineno" id=line165></span>      }
<span class="lineno" id=line166></span>    """</span>
<span class="lineno" id=line167></span>      <span class="big_keyword" title="specify requirements">requires</span> property <span class="fstring">"needs_gc"</span>
<span class="lineno" id=line168></span>    ;
<span class="lineno" id=line169></span>  
<span class="lineno" id=line170></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> push_back[t] (x: <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t], v: t)
<span class="lineno" id=line171></span>    {
<span class="lineno" id=line172></span>      <span class="small_keyword" title="conditional">if</span> x.<span class="library" title="number of elements in data structure">len</span> &gt;= x.maxlen <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line173></span>        eprintln (<span class="fstring">"attempt to push_back on full varray size "</span> + x.maxlen.<span class="library" title="Convert a value to a string">str</span>);
<span class="lineno" id=line174></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line175></span>      _push_back (x,v);  
<span class="lineno" id=line176></span>    }
<span class="lineno" id=line177></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> push_back[t] (x:<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t]) (v:t) =&gt; push_back(x,v);
<span class="lineno" id=line178></span>  
<span class="lineno" id=line179></span>    <span class="doccomment">Pop an element off the end of a varray.</span>
<span class="lineno" id=line180></span>    <span class="doccomment">Aborts if the array is empty.</span>
<span class="lineno" id=line181></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> pop_back[t] : <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t] = <span class="fstring">"""
<span class="lineno" id=line182></span>      { // pop varray
<span class="lineno" id=line183></span>        ?1 * _p = $1;
<span class="lineno" id=line184></span>        size_t n = ptf-&gt; gcp-&gt;collector-&gt;get_used(_p);
<span class="lineno" id=line185></span>        ptf-&gt; gcp-&gt;collector-&gt;incr_used(_p,-1L);
<span class="lineno" id=line186></span>        destroy(_p+n-1); // from flx_compiler_support_bodies
<span class="lineno" id=line187></span>      }
<span class="lineno" id=line188></span>    """</span>
<span class="lineno" id=line189></span>      <span class="big_keyword" title="specify requirements">requires</span> property <span class="fstring">"needs_gc"</span>;
<span class="lineno" id=line190></span>    ;
<span class="lineno" id=line191></span>  
<span class="lineno" id=line192></span>    <span class="doccomment">Erase elements of array between and including first and last.</span>
<span class="lineno" id=line193></span>    <span class="doccomment">Include first and last, intersect with array span.</span>
<span class="lineno" id=line194></span>    <span class="doccomment">Cannot fail.</span>
<span class="lineno" id=line195></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> erase[v] (a:<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[v], first:<span class="library" title="binding of C int type">int</span>, last:<span class="library" title="binding of C int type">int</span>)
<span class="lineno" id=line196></span>    {
<span class="lineno" id=line197></span>      <span class="small_keyword" title="conditional">if</span> first &gt; last <span class="small_keyword" title="return">return</span>;
<span class="lineno" id=line198></span>      <span class="big_keyword" title="Define a mutable variable">var</span> l = a.<span class="library" title="number of elements in data structure">len</span>.<span class="library" title="binding of C int type">int</span>;
<span class="lineno" id=line199></span>      <span class="big_keyword" title="Define a mutable variable">var</span> b = <span class="small_keyword" title="conditional">if</span> first &lt; 0 <span class="small_keyword" title="conditional">then</span> 0 <span class="small_keyword" title="conditional">else</span> first;
<span class="lineno" id=line200></span>      <span class="big_keyword" title="Define a mutable variable">var</span> e = <span class="small_keyword" title="conditional">if</span> last &gt;= l <span class="small_keyword" title="conditional">then</span> l - 1 <span class="small_keyword" title="conditional">else</span> last;
<span class="lineno" id=line201></span>      <span class="big_keyword" title="Define a mutable variable">var</span> d = e - b + 1;
<span class="lineno" id=line202></span>      <span class="small_keyword" title="conditional">if</span> d &gt; 0 <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line203></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i <span class="small_keyword" title="membership operator, function mem">in</span> b <span class="small_keyword" title="upwards counting for loop">upto</span> l - d - 1 <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line204></span>           unsafe_set (a, i.<span class="library" title="binding of C size_t type">size</span>, unsafe_get (a, <span class="library" title="binding of C size_t type">size</span> (i + d)));
<span class="lineno" id=line205></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line206></span>        <span class="big_keyword" title="Define a mutable variable">var</span> s : carray[v] = a.stl_begin;
<span class="lineno" id=line207></span>        <span class="small_keyword" title="for loop">for</span> i <span class="small_keyword" title="membership operator, function mem">in</span> l - d <span class="small_keyword" title="upwards counting for loop">upto</span> l - 1 <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line208></span>          <span class="big_keyword" title="Define a mutable variable">var</span> p : carray[v] = s + i;
<span class="lineno" id=line209></span>          <span class="hack">C_hack</span>::destroy$ -p;
<span class="lineno" id=line210></span>        <span class="small_keyword" title="end of body">done</span> 
<span class="lineno" id=line211></span>        set_used$ a, (l - d).<span class="library" title="binding of C size_t type">size</span>;
<span class="lineno" id=line212></span>      <span class="small_keyword" title="end of body">done</span> 
<span class="lineno" id=line213></span>    }
<span class="lineno" id=line214></span>  
<span class="lineno" id=line215></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> erase[v] (a:<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[v], i:<span class="library" title="binding of C int type">int</span>) =&gt; erase (a,i,i);
<span class="lineno" id=line216></span>  
<span class="lineno" id=line217></span>    <span class="doccomment">insert (a,i,v) inserts v in a at position i</span>
<span class="lineno" id=line218></span>    <span class="doccomment">that is, inserts before element i.</span>
<span class="lineno" id=line219></span>    <span class="doccomment">If i is negative, position relative to end,</span>
<span class="lineno" id=line220></span>    <span class="doccomment">that is, -1 is last element, so insert (a,-1,v)</span>
<span class="lineno" id=line221></span>    <span class="doccomment">inserts before the last element (not after!)</span>
<span class="lineno" id=line222></span>    <span class="doccomment">If i equals the length, element is appended.</span>
<span class="lineno" id=line223></span>    <span class="doccomment">If the index is out of range, nothing happens.</span>
<span class="lineno" id=line224></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> insert[t] (a:<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[t], i:<span class="library" title="binding of C int type">int</span>, v:t)
<span class="lineno" id=line225></span>    {
<span class="lineno" id=line226></span>      <span class="big_keyword" title="Define a mutable variable">var</span> l = a.<span class="library" title="number of elements in data structure">len</span>.<span class="library" title="binding of C int type">int</span>;
<span class="lineno" id=line227></span>      <span class="big_keyword" title="Define a mutable variable">var</span> n = a.maxlen.<span class="library" title="binding of C int type">int</span>;
<span class="lineno" id=line228></span>      <span class="small_keyword" title="conditional">if</span> l == n <span class="small_keyword" title="return">return</span>; <span class="comment">// fail: no space</span>
<span class="lineno" id=line229></span>      <span class="big_keyword" title="Define a mutable variable">var</span> ix = <span class="small_keyword" title="conditional">if</span> i &lt; 0 <span class="small_keyword" title="conditional">then</span>  l - i <span class="small_keyword" title="conditional">else</span> i;
<span class="lineno" id=line230></span>      <span class="small_keyword" title="conditional">if</span> ix &lt; 0 <span class="small_keyword" title="logical disjunction">or</span> ix &gt; l <span class="small_keyword" title="return">return</span>; <span class="comment">// fail: bad index</span>
<span class="lineno" id=line231></span>      <span class="small_keyword" title="conditional">if</span> ix == l <span class="small_keyword" title="imperative code begins">do</span> 
<span class="lineno" id=line232></span>      <span class="small_keyword" title="conditional">if</span> a.<span class="library" title="number of elements in data structure">len</span> &gt;= a.maxlen <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line233></span>        eprintln (<span class="fstring">"insert: attempt to push_back on full varray size "</span> + a.maxlen.<span class="library" title="Convert a value to a string">str</span>);
<span class="lineno" id=line234></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line235></span>        push_back (a,v);
<span class="lineno" id=line236></span>      <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line237></span>        <span class="big_keyword" title="Run time assertion">assert</span> l &gt; 0;
<span class="lineno" id=line238></span>      <span class="small_keyword" title="conditional">if</span> a.<span class="library" title="number of elements in data structure">len</span> &gt;= a.maxlen <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line239></span>        eprintln (<span class="fstring">"insert: attempt to push_back on full varray size "</span> + a.maxlen.<span class="library" title="Convert a value to a string">str</span>);
<span class="lineno" id=line240></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line241></span>        push_back (a, a.(l - 1)); <span class="comment">// dups last element</span>
<span class="lineno" id=line242></span>        <span class="small_keyword" title="conditional">if</span> l - 2 &gt; ix <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line243></span>          <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> j <span class="small_keyword" title="membership operator, function mem">in</span> l - 2 <span class="small_keyword" title="downwards counting for loop">downto</span> ix <span class="small_keyword" title="imperative code begins">do</span> <span class="comment">// copy from second last pos</span>
<span class="lineno" id=line244></span>             unsafe_set (a, j.<span class="library" title="binding of C size_t type">size</span> + 1uz, unsafe_get (a, j.<span class="library" title="binding of C size_t type">size</span>));
<span class="lineno" id=line245></span>          <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line246></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line247></span>        unsafe_set (a, ix.<span class="library" title="binding of C size_t type">size</span>, v); 
<span class="lineno" id=line248></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line249></span>    }
<span class="lineno" id=line250></span>  
<span class="lineno" id=line251></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> apply[T] (x:slice[<span class="library" title="binding of C int type">int</span>], v:<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T])  {
<span class="lineno" id=line252></span>      <span class="big_keyword" title="Define a mutable variable">var</span> minr = max (min x,0);
<span class="lineno" id=line253></span>      <span class="big_keyword" title="Define a mutable variable">var</span> maxr = min (max x,v.<span class="library" title="number of elements in data structure">len</span>.<span class="library" title="binding of C int type">int</span> - 1);
<span class="lineno" id=line254></span>      <span class="big_keyword" title="Define a mutable variable">var</span> out = <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T] (maxr - minr + 1).<span class="library" title="binding of C size_t type">size</span>;
<span class="lineno" id=line255></span>      <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i <span class="small_keyword" title="membership operator, function mem">in</span> minr <span class="small_keyword" title="upwards counting for loop">upto</span> maxr perform
<span class="lineno" id=line256></span>        out.push_back v.i;
<span class="lineno" id=line257></span>      <span class="small_keyword" title="return">return</span> out;
<span class="lineno" id=line258></span>    }
<span class="lineno" id=line259></span>  
<span class="lineno" id=line260></span>    <span class="doccomment">Traditional map varray to varray.</span>
<span class="lineno" id=line261></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="return data structure with function applied to each value">map</span>[T, U] (_f:T-&gt;U) (x:<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T]): <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[U] = {
<span class="lineno" id=line262></span>      <span class="big_keyword" title="Define a mutable variable">var</span> o = <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[U]$ <span class="library" title="number of elements in data structure">len</span>(x);
<span class="lineno" id=line263></span>  
<span class="lineno" id=line264></span>      <span class="small_keyword" title="conditional">if</span> <span class="library" title="number of elements in data structure">len</span> x &gt; 0uz <span class="small_keyword" title="imperative code begins">do</span> <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> <span class="library" title="number of elements in data structure">len</span>(x) - 1uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line265></span>      <span class="small_keyword" title="conditional">if</span> o.<span class="library" title="number of elements in data structure">len</span> &gt;= o.maxlen <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line266></span>        eprintln (<span class="fstring">"insert: attempt to push_back on full varray size "</span> + o.maxlen.<span class="library" title="Convert a value to a string">str</span>);
<span class="lineno" id=line267></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line268></span>        push_back (o, _f x.i);
<span class="lineno" id=line269></span>      <span class="small_keyword" title="end of body">done</span> <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line270></span>      <span class="small_keyword" title="return">return</span> o;
<span class="lineno" id=line271></span>    }
<span class="lineno" id=line272></span>  
<span class="lineno" id=line273></span>    <span class="doccomment">R like operations</span>
<span class="lineno" id=line274></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> rop[T] (op:T * T -&gt; T) (x:<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T], y:<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T]) : <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T] =&gt;
<span class="lineno" id=line275></span>      <span class="small_keyword" title="let binder">let</span> n = x.<span class="library" title="number of elements in data structure">len</span> <span class="small_keyword" title="membership operator, function mem">in</span>
<span class="lineno" id=line276></span>      <span class="small_keyword" title="let binder">let</span> m = y.<span class="library" title="number of elements in data structure">len</span> <span class="small_keyword" title="membership operator, function mem">in</span>
<span class="lineno" id=line277></span>      <span class="small_keyword" title="conditional">if</span> m == 0uz <span class="small_keyword" title="logical disjunction">or</span> n == 0uz <span class="small_keyword" title="conditional">then</span> <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T](0uz) <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line278></span>      <span class="small_keyword" title="let binder">let</span> l = max(n,m) <span class="small_keyword" title="membership operator, function mem">in</span>
<span class="lineno" id=line279></span>      <span class="small_keyword" title="let binder">let</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> g (i:<span class="library" title="binding of C size_t type">size</span>): T =&gt; op (x.(i%n), y.(i%m)) <span class="small_keyword" title="membership operator, function mem">in</span>
<span class="lineno" id=line280></span>      <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T] (l,l,g)
<span class="lineno" id=line281></span>    ;
<span class="lineno" id=line282></span>  
<span class="lineno" id=line283></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> as_list[T] (x:<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T]): List::<span class="library" title="functional, singly linked list">list</span>[T]  {
<span class="lineno" id=line284></span>      <span class="big_keyword" title="Define a mutable variable">var</span> y = List::Empty[T];
<span class="lineno" id=line285></span>      <span class="small_keyword" title="for loop">for</span> elt <span class="small_keyword" title="membership operator, function mem">in</span> x perform y = List::Snoc(y,elt);
<span class="lineno" id=line286></span>      <span class="small_keyword" title="return">return</span> y.<span class="library" title="return data structure with elements reversed">rev</span>.unbox; 
<span class="lineno" id=line287></span>    }
<span class="lineno" id=line288></span>  }
<span class="lineno" id=line289></span>  
<span class="lineno" id=line290></span>  <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[T <span class="small_keyword" title="type-class constraint">with</span> Show[T]] Str[Varray::<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T]] {
<span class="lineno" id=line291></span>    <span class="doccomment">Convert a varray[T] to a string.</span>
<span class="lineno" id=line292></span>    <span class="doccomment">Requires Show[T]</span>
<span class="lineno" id=line293></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="Convert a value to a string">str</span> (xs:<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T]) = {
<span class="lineno" id=line294></span>      <span class="big_keyword" title="Define a mutable variable">var</span> o = <span class="fstring">'varray('</span>;
<span class="lineno" id=line295></span>  
<span class="lineno" id=line296></span>      <span class="small_keyword" title="conditional">if</span> <span class="library" title="number of elements in data structure">len</span> xs &gt; 0uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line297></span>        o += repr xs.0;
<span class="lineno" id=line298></span>  
<span class="lineno" id=line299></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i <span class="small_keyword" title="membership operator, function mem">in</span> 1uz <span class="small_keyword" title="upwards counting for loop">upto</span> <span class="library" title="number of elements in data structure">len</span> xs - 1uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line300></span>          o += <span class="fstring">', '</span> + repr xs.i;
<span class="lineno" id=line301></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line302></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line303></span>  
<span class="lineno" id=line304></span>      <span class="small_keyword" title="return">return</span> o + <span class="fstring">')'</span>;
<span class="lineno" id=line305></span>    }
<span class="lineno" id=line306></span>  }
<span class="lineno" id=line307></span>  
<span class="lineno" id=line308></span>  <span class="doccomment">Treat varray as Set.</span>
<span class="lineno" id=line309></span>  <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[T <span class="small_keyword" title="type-class constraint">with</span> Eq[T]] Set[<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T],T] {
<span class="lineno" id=line310></span>    <span class="doccomment">Check is a value is stored in a varray.</span>
<span class="lineno" id=line311></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="tex_symbol" title="\in">\(\in\)</span> (x:T, a:<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T]) : bool = {
<span class="lineno" id=line312></span>      <span class="small_keyword" title="conditional">if</span> <span class="library" title="number of elements in data structure">len</span> a &gt; 0uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line313></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> <span class="library" title="number of elements in data structure">len</span> a - 1uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line314></span>          <span class="small_keyword" title="conditional">if</span> a.i == x <span class="small_keyword" title="imperative code begins">do</span> <span class="small_keyword" title="return">return</span> <span class="library" title="truth value">true</span>; <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line315></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line316></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line317></span>      <span class="small_keyword" title="return">return</span> <span class="library" title="false value">false</span>;
<span class="lineno" id=line318></span>    } 
<span class="lineno" id=line319></span>  }
<span class="lineno" id=line320></span>  
<span class="lineno" id=line321></span>  <span class="big_keyword" title="Open a module or class">open</span>[T] Show[Varray::<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T]];
<span class="lineno" id=line322></span>  <span class="big_keyword" title="Open a module or class">open</span>[T] Set[Varray::<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T],T];
<span class="lineno" id=line323></span>  <span class="big_keyword" title="Open a module or class">open</span>[T] ArrayValue[<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T], T];
<span class="lineno" id=line324></span>  <span class="big_keyword" title="Open a module or class">open</span>[T] ArrayObject[<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T], T];
<span class="lineno" id=line325></span>  <span class="big_keyword" title="Open a module or class">open</span>[T] ContiguousArrayObject[<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T], T];
<span class="lineno" id=line326></span>  
</pre></p></div><h1 id='Darray_h'><img src='/share/src/web/images/minus.gif' id='Darray' onclick='toggle(this,"Darray_d")' alt='+'/> 4 Darray</h1><div id='Darray_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/darray.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  
</pre></p></div><h1 id='<code>darray</code>:_an_array_with_dynamic,_unbounded_length._h'><img src='/share/src/web/images/minus.gif' id='<code>darray</code>: an array with dynamic, unbounded length.' onclick='toggle(this,"<code>darray</code>:_an_array_with_dynamic,_unbounded_length._d")' alt='+'/> 5 <code>darray</code>: an array with dynamic, unbounded length.</h1><div id='<code>darray</code>:_an_array_with_dynamic,_unbounded_length._d' style='display:block'>
<p>A <code>darray</code> is a contiguous store of variable, unbounded length.
It is implemented by a pointer to a <code>varray</code>. When the <code>varray</code> becomes
full, a new one with a large bound is created, the contents of
the old array copied over, and the old array forgotten.
</p><p>Similarly when the <code>varray</code> is not sufficiently full,
a new <code>varray</code> of smaller extent is allocated and the contents
of the old array copied over, and the old array is forgotten.
</p><p>A user specifiable function is used to control the threshholds
for and amount of expansion and contraction. The user function
defines the amortised performance. With higher expansion factors,
O(1) speed is obtained at the cost of a lot of memory wastage.
</p><pre class='inclusion'>
share/lib/std/datatype/darray.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">Unbounded Variable length object array.</span>
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Open a module or class">open</span> <span class="big_keyword" title="Define a type class">class</span> Darray
<span class="lineno" id=line3></span>  {
</pre></p><h2 id='Representation_h'><img src='/share/src/web/images/minus.gif' id='Representation' onclick='toggle(this,"Representation_d")' alt='+'/> 5.1 Representation</h2><div id='Representation_d' style='display:block'>
<p>We use a control block <code>darray_ctl</code> to store the data
required to access a <code>darray</code>, it contains a
varray and a <code>resize</code> function.
The resize function takes two arguments: the current <code>varray</code>
bound and the requested amount of store. It returns a
recommended amount of store.
</p><pre class='inclusion'>
share/lib/std/datatype/darray.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> <span class="big_keyword" title="Define a structure">struct</span> darray_ctl[T]
<span class="lineno" id=line2></span>    {
<span class="lineno" id=line3></span>      a: <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T];
<span class="lineno" id=line4></span>      resize: <span class="library" title="binding of C size_t type">size</span> * <span class="library" title="binding of C size_t type">size</span> --&gt; <span class="library" title="binding of C size_t type">size</span>;
<span class="lineno" id=line5></span>    }
<span class="lineno" id=line6></span>  
</pre></p></div><h2 id='Default_resize_function._h'><img src='/share/src/web/images/minus.gif' id='Default resize function.' onclick='toggle(this,"Default_resize_function._d")' alt='+'/> 5.2 Default resize function.</h2><div id='Default_resize_function._d' style='display:block'>
<p>This function increases the bound to 150% of the requested size
when the requested size exceeds the current bound.
</p><p>It decreases the current bound to 150% of the requested size
if the requested size is less that 50% of the current bound.
</p><p>There is a hard minimum of 20 elements except in the special
case the array is empty, when the size is set to 0.
</p><pre class='inclusion'>
share/lib/std/datatype/darray.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">This is the default array resize function.</span>
<span class="lineno" id=line2></span>    <span class="doccomment">If we run out of space, allocate what we have + 50%.</span>
<span class="lineno" id=line3></span>    <span class="doccomment">If we need less than half the allocated space, return the requested size + 50%.</span>
<span class="lineno" id=line4></span>    <span class="doccomment">Otherwise return the existing allocated space.</span>
<span class="lineno" id=line5></span>    <span class="big_keyword" title="Define a C function">cfun</span> dflt_resize(old_max:<span class="library" title="binding of C size_t type">size</span>, requested:<span class="library" title="binding of C size_t type">size</span>):<span class="library" title="binding of C size_t type">size</span>=
<span class="lineno" id=line6></span>    {
<span class="lineno" id=line7></span>      <span class="comment">// GOTCHA: don't forget that division has a higher precedence than multiplication!</span>
<span class="lineno" id=line8></span>      <span class="comment">// sensible minimum size of 20, except if zero length</span>
<span class="lineno" id=line9></span>      <span class="small_keyword" title="conditional">if</span> requested == 0uz <span class="small_keyword" title="return">return</span> 0uz;
<span class="lineno" id=line10></span>      <span class="small_keyword" title="conditional">if</span> requested &lt; 20uz <span class="small_keyword" title="return">return</span> 20uz; 
<span class="lineno" id=line11></span>      <span class="small_keyword" title="conditional">if</span> requested &lt; old_max / 2uz <span class="small_keyword" title="return">return</span> (3uz * requested) / 2uz;
<span class="lineno" id=line12></span>      <span class="small_keyword" title="conditional">if</span> requested &gt; old_max <span class="small_keyword" title="return">return</span> (requested * 3uz) / 2uz;
<span class="lineno" id=line13></span>      <span class="small_keyword" title="return">return</span> old_max;
<span class="lineno" id=line14></span>    }
<span class="lineno" id=line15></span>  
</pre></p></div><h2 id='<code>darray</code>_type._h'><img src='/share/src/web/images/minus.gif' id='<code>darray</code> type.' onclick='toggle(this,"<code>darray</code>_type._d")' alt='+'/> 5.3 <code>darray</code> type.</h2><div id='<code>darray</code>_type._d' style='display:block'>
<p>We define <code>darray</code> as a pointer to a darray control block <code>darray_ctl</code>.
This means, in particular, that <code>darray</code> is passed by reference.
The definition is abstract, so the client us not able to fiddle with
the underlying control block.
</p><pre class='inclusion'>
share/lib/std/datatype/darray.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Type of a darray.</span>
<span class="lineno" id=line2></span>    <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> <span class="library" title="array with unbounded dynamically variable limit">darray</span>[T] = new &amp;darray_ctl[T];
<span class="lineno" id=line3></span>  
</pre></p></div><h2 id='Force_a_resize_of_the_bound._h'><img src='/share/src/web/images/minus.gif' id='Force a resize of the bound.' onclick='toggle(this,"Force_a_resize_of_the_bound._d")' alt='+'/> 5.4 Force a resize of the bound.</h2><div id='Force_a_resize_of_the_bound._d' style='display:block'>
<p>This procedure forcibly resizes a darray to a new bound.
The number of use elements is the maximum of the old 
number of elements and the new bound.
</p><p>This procedure is analogous to the C++ string <code>reserve</code> function,
however it is primarily intended for internal use. If this function
is called the new bound will be adjusted on the next size changing
operation such as a <code>push_back</code> or <code>pop_back</code>.
</p><pre class='inclusion'>
share/lib/std/datatype/darray.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Force a resize.</span>
<span class="lineno" id=line2></span>    <span class="doccomment">Similar to C++ vector reserve function.</span>
<span class="lineno" id=line3></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> do_resize[T] (pd: <span class="library" title="array with unbounded dynamically variable limit">darray</span>[T], new_size: <span class="library" title="binding of C size_t type">size</span>)
<span class="lineno" id=line4></span>    {
<span class="lineno" id=line5></span>      <span class="big_keyword" title="Define a mutable variable">var</span> old = (_repr_ pd)*.a;
<span class="lineno" id=line6></span>      (_repr_ pd).a &lt;- <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T] (new_size, (<span class="library" title="number of elements in data structure">len</span> old), (<span class="big_keyword" title="Define a function with no side-effects">fun</span>(i:<span class="library" title="binding of C size_t type">size</span>)=&gt;old.i));
<span class="lineno" id=line7></span>    }
<span class="lineno" id=line8></span>  
</pre></p></div><h2 id='Constructors._h'><img src='/share/src/web/images/minus.gif' id='Constructors.' onclick='toggle(this,"Constructors._d")' alt='+'/> 5.5 Constructors.</h2><div id='Constructors._d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/darray.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Make an empty darray, give it 20 slots for no particular reason.</span>
<span class="lineno" id=line2></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span>[T] <span class="library" title="array with unbounded dynamically variable limit">darray</span>[T] () =&gt; 
<span class="lineno" id=line3></span>      _make_darray[T]$ new darray_ctl[T](<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T] 20uz , dflt_resize);
<span class="lineno" id=line4></span>  
<span class="lineno" id=line5></span>    <span class="doccomment">Make a darray from an array</span>
<span class="lineno" id=line6></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span>[T,N:UNITSUM] <span class="library" title="array with unbounded dynamically variable limit">darray</span>[T] (a:<span class="library" title="array type, a tuple of all components the same type">array</span>[T,N]) =&gt;  
<span class="lineno" id=line7></span>      _make_darray[T]$ new darray_ctl[T]( <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T] a, dflt_resize);
<span class="lineno" id=line8></span>  
<span class="lineno" id=line9></span>    <span class="doccomment">Make a darray from a varray</span>
<span class="lineno" id=line10></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span>[T] <span class="library" title="array with unbounded dynamically variable limit">darray</span>[T] (a:<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T]) =&gt;  
<span class="lineno" id=line11></span>      _make_darray[T]$ new darray_ctl[T]( <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T] a, dflt_resize);
<span class="lineno" id=line12></span>  
<span class="lineno" id=line13></span>    <span class="doccomment">Make a darray from a darray (copy)</span>
<span class="lineno" id=line14></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span>[T] <span class="library" title="array with unbounded dynamically variable limit">darray</span>[T] (a:<span class="library" title="array with unbounded dynamically variable limit">darray</span>[T]) =&gt; <span class="library" title="array with unbounded dynamically variable limit">darray</span> ((_repr_ a)*.a);
<span class="lineno" id=line15></span>  
<span class="lineno" id=line16></span>  
<span class="lineno" id=line17></span>    <span class="doccomment">make a darray of a certain size initialised with some default value</span>
<span class="lineno" id=line18></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span>[T] <span class="library" title="array with unbounded dynamically variable limit">darray</span>[T] (n:<span class="library" title="binding of C size_t type">size</span>, default:T) =&gt; <span class="library" title="array with unbounded dynamically variable limit">darray</span>[T] (<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T](n,default));
<span class="lineno" id=line19></span>  
</pre></p></div><h2 id='As_a_value._h'><img src='/share/src/web/images/minus.gif' id='As a value.' onclick='toggle(this,"As_a_value._d")' alt='+'/> 5.6 As a value.</h2><div id='As_a_value._d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/darray.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Basic array value stuff.</span>
<span class="lineno" id=line2></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[v] ArrayValue[<span class="library" title="array with unbounded dynamically variable limit">darray</span>[v],v] {
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="number of elements in data structure">len</span> (a:<span class="library" title="array with unbounded dynamically variable limit">darray</span>[v])=&gt; <span class="library" title="number of elements in data structure">len</span> (_repr_ a)*.a;
<span class="lineno" id=line4></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> unsafe_get (a:<span class="library" title="array with unbounded dynamically variable limit">darray</span>[v], i:<span class="library" title="binding of C size_t type">size</span>) =&gt; (_repr_ a)*.a.i;
<span class="lineno" id=line5></span>    }
<span class="lineno" id=line6></span>  
</pre></p></div><h2 id='As_an_object._h'><img src='/share/src/web/images/minus.gif' id='As an object.' onclick='toggle(this,"As_an_object._d")' alt='+'/> 5.7 As an object.</h2><div id='As_an_object._d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/darray.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Basic array object stuff.</span>
<span class="lineno" id=line2></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[v] ArrayObject[<span class="library" title="array with unbounded dynamically variable limit">darray</span>[v],v] {
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> unsafe_set (b:<span class="library" title="array with unbounded dynamically variable limit">darray</span>[v],  n:<span class="library" title="binding of C size_t type">size</span>, x:v) =&gt; unsafe_set ((_repr_ b)*.a,n,x);
<span class="lineno" id=line4></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> unsafe_get_ref (b:<span class="library" title="array with unbounded dynamically variable limit">darray</span>[v],  n:<span class="library" title="binding of C size_t type">size</span>) : &amp;v =&gt; unsafe_get_ref ((_repr_ b)*.a,n);
<span class="lineno" id=line5></span>    }
<span class="lineno" id=line6></span>  
</pre></p></div><h2 id='As_an_contiguous_array._h'><img src='/share/src/web/images/minus.gif' id='As an contiguous array.' onclick='toggle(this,"As_an_contiguous_array._d")' alt='+'/> 5.8 As an contiguous array.</h2><div id='As_an_contiguous_array._d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/darray.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Contrue as contiguous store.</span>
<span class="lineno" id=line2></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[v] ContiguousArrayObject[<span class="library" title="array with unbounded dynamically variable limit">darray</span>[v],v] {
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> stl_begin(b:<span class="library" title="array with unbounded dynamically variable limit">darray</span>[v]) =&gt; stl_begin b._repr_*.a;
<span class="lineno" id=line4></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> stl_end(b:<span class="library" title="array with unbounded dynamically variable limit">darray</span>[v]) =&gt; stl_end b._repr_*.a;
<span class="lineno" id=line5></span>    }
<span class="lineno" id=line6></span>  
</pre></p></div><h2 id='Size_changing_mutators._h'><img src='/share/src/web/images/minus.gif' id='Size changing mutators.' onclick='toggle(this,"Size_changing_mutators._d")' alt='+'/> 5.9 Size changing mutators.</h2><div id='Size_changing_mutators._d' style='display:block'>
<p>There's no <code>push_front</code> but there should be.
Generally, this class is very incomplete.
</p><pre class='inclusion'>
share/lib/std/datatype/darray.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Pop a value from the end.</span>
<span class="lineno" id=line2></span>    <span class="doccomment">Same as pop_back in C++.</span>
<span class="lineno" id=line3></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> pop_back[t](a:<span class="library" title="array with unbounded dynamically variable limit">darray</span>[t]) {
<span class="lineno" id=line4></span>      pop_back (_repr_ a)*.a;
<span class="lineno" id=line5></span>      newsize := (_repr_ a)*.resize (maxlen (_repr_ a)*.a, <span class="library" title="number of elements in data structure">len</span> (_repr_ a)*.a);
<span class="lineno" id=line6></span>      <span class="small_keyword" title="conditional">if</span> newsize != maxlen (_repr_ a)*.a <span class="small_keyword" title="call a procedure">call</span> do_resize (a,newsize);
<span class="lineno" id=line7></span>    }
<span class="lineno" id=line8></span>  
<span class="lineno" id=line9></span>    <span class="doccomment">Push a value onto the end.</span>
<span class="lineno" id=line10></span>    <span class="doccomment">Same as push_back in C++.</span>
<span class="lineno" id=line11></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> += [t] (a:&amp;<span class="library" title="array with unbounded dynamically variable limit">darray</span>[t],v:t) {
<span class="lineno" id=line12></span>      push_back (*a, v);
<span class="lineno" id=line13></span>    }
<span class="lineno" id=line14></span>  
<span class="lineno" id=line15></span>    <span class="doccomment">Push a value onto the end.</span>
<span class="lineno" id=line16></span>    <span class="doccomment">Same as push_back in C++.</span>
<span class="lineno" id=line17></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> push_back[t] (a:<span class="library" title="array with unbounded dynamically variable limit">darray</span>[t], v:t) {
<span class="lineno" id=line18></span>      r := _repr_ a; 
<span class="lineno" id=line19></span>      newsize := r*.resize (maxlen r*.a, <span class="library" title="number of elements in data structure">len</span> r*.a + 1uz);
<span class="lineno" id=line20></span>      <span class="small_keyword" title="conditional">if</span> newsize != maxlen r*.a <span class="small_keyword" title="call a procedure">call</span> do_resize(a,newsize);
<span class="lineno" id=line21></span>      <span class="small_keyword" title="conditional">if</span> r*.a.<span class="library" title="number of elements in data structure">len</span> &gt;= r*.a.maxlen <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line22></span>        eprintln (<span class="fstring">"darray push_back: attempt to push_back on full varray size "</span> + r*.a.maxlen.<span class="library" title="Convert a value to a string">str</span>);
<span class="lineno" id=line23></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line24></span>      push_back (r*.a, v); <span class="comment">// hack to workaround compiler error Address non variable</span>
<span class="lineno" id=line25></span>    }
<span class="lineno" id=line26></span>  
<span class="lineno" id=line27></span>    <span class="doccomment">insert</span>
<span class="lineno" id=line28></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> insert[t] (a:<span class="library" title="array with unbounded dynamically variable limit">darray</span>[t], i:<span class="library" title="binding of C int type">int</span>, v:t)
<span class="lineno" id=line29></span>    {
<span class="lineno" id=line30></span>      <span class="big_keyword" title="Define a mutable variable">var</span> r = _repr_ a; 
<span class="lineno" id=line31></span>      newsize := r*.resize (maxlen r*.a, <span class="library" title="number of elements in data structure">len</span> r*.a + 1uz);
<span class="lineno" id=line32></span>      <span class="small_keyword" title="conditional">if</span> newsize != maxlen r*.a <span class="small_keyword" title="call a procedure">call</span> do_resize(a,newsize);
<span class="lineno" id=line33></span>      r = _repr_ a;
<span class="lineno" id=line34></span>      insert (r*.a,i,v);
<span class="lineno" id=line35></span>    }
<span class="lineno" id=line36></span>  
<span class="lineno" id=line37></span>    <span class="doccomment">Erase an element, note doesn't resize the varray,</span>
<span class="lineno" id=line38></span>    <span class="doccomment">probably should ..</span>
<span class="lineno" id=line39></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> erase[t] (a:<span class="library" title="array with unbounded dynamically variable limit">darray</span>[t], i:<span class="library" title="binding of C int type">int</span>) =&gt; erase ((_repr_ a)*.a,i);
<span class="lineno" id=line40></span>  
<span class="lineno" id=line41></span>    <span class="doccomment">Erase multiple elements, note doesn't resize the varray,</span>
<span class="lineno" id=line42></span>    <span class="doccomment">probably should ..</span>
<span class="lineno" id=line43></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> erase[t] (a:<span class="library" title="array with unbounded dynamically variable limit">darray</span>[t], first:<span class="library" title="binding of C int type">int</span>, last:<span class="library" title="binding of C int type">int</span>) =&gt; 
<span class="lineno" id=line44></span>      erase ((_repr_ a)*.a, first,last);
</pre></p></div><h2 id='Slice_h'><img src='/share/src/web/images/minus.gif' id='Slice' onclick='toggle(this,"Slice_d")' alt='+'/> 5.10 Slice</h2><div id='Slice_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/darray.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> apply[T] (x:slice[<span class="library" title="binding of C int type">int</span>], v:<span class="library" title="array with unbounded dynamically variable limit">darray</span>[T])  {
<span class="lineno" id=line2></span>      <span class="big_keyword" title="Define a mutable variable">var</span> minr = max (min x,0);
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Define a mutable variable">var</span> maxr = min (max x,v.<span class="library" title="number of elements in data structure">len</span>.<span class="library" title="binding of C int type">int</span> - 1);
<span class="lineno" id=line4></span>      <span class="big_keyword" title="Define a mutable variable">var</span> out = <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T] (maxr - minr + 1).<span class="library" title="binding of C size_t type">size</span>;
<span class="lineno" id=line5></span>      <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i <span class="small_keyword" title="membership operator, function mem">in</span> minr <span class="small_keyword" title="upwards counting for loop">upto</span> maxr perform
<span class="lineno" id=line6></span>        out.push_back v.i;
<span class="lineno" id=line7></span>      <span class="small_keyword" title="return">return</span> <span class="library" title="array with unbounded dynamically variable limit">darray</span> out;
<span class="lineno" id=line8></span>    }
<span class="lineno" id=line9></span>  
</pre></p></div><h2 id='Convert_a_darray_to_a_string._h'><img src='/share/src/web/images/minus.gif' id='Convert a darray to a string.' onclick='toggle(this,"Convert_a_darray_to_a_string._d")' alt='+'/> 5.11 Convert a darray to a string.</h2><div id='Convert_a_darray_to_a_string._d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/darray.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="comment">// uses _repr_ so has to be in the module</span>
<span class="lineno" id=line2></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[T <span class="small_keyword" title="type-class constraint">with</span> Show[T]] Str[Darray::<span class="library" title="array with unbounded dynamically variable limit">darray</span>[T]] {
<span class="lineno" id=line3></span>      <span class="doccomment">Convert an array to a string,</span>
<span class="lineno" id=line4></span>      <span class="doccomment">provided the element type is convertible.</span>
<span class="lineno" id=line5></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="Convert a value to a string">str</span> (x:<span class="library" title="array with unbounded dynamically variable limit">darray</span>[T])=&gt; <span class="library" title="Convert a value to a string">str</span> (_repr_ x)*.a;
<span class="lineno" id=line6></span>    }
<span class="lineno" id=line7></span>  
</pre></p></div><h2 id='Enable_map_on_darray_objects._h'><img src='/share/src/web/images/minus.gif' id='Enable map on darray objects.' onclick='toggle(this,"Enable_map_on_darray_objects._d")' alt='+'/> 5.12 Enable map on darray objects.</h2><div id='Enable_map_on_darray_objects._d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/darray.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="doccomment">Traditional map darray to darray.</span>
<span class="lineno" id=line2></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="return data structure with function applied to each value">map</span>[T, U] (_f:T-&gt;U) (arr:<span class="library" title="array with unbounded dynamically variable limit">darray</span>[T]): <span class="library" title="array with unbounded dynamically variable limit">darray</span>[U] = {
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Define a mutable variable">var</span> o = <span class="library" title="array with unbounded dynamically variable limit">darray</span>[U]();
<span class="lineno" id=line4></span>  
<span class="lineno" id=line5></span>      <span class="small_keyword" title="conditional">if</span> arr.<span class="library" title="number of elements in data structure">len</span> &gt; 0uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line6></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> arr.<span class="library" title="number of elements in data structure">len</span> - 1uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line7></span>        push_back (o, _f arr.i);
<span class="lineno" id=line8></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line9></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line10></span>      
<span class="lineno" id=line11></span>      <span class="small_keyword" title="return">return</span> o;
<span class="lineno" id=line12></span>    }
<span class="lineno" id=line13></span>  
</pre></p></div><h2 id='Enable_filter_on_darray_objects_h'><img src='/share/src/web/images/minus.gif' id='Enable filter on darray objects' onclick='toggle(this,"Enable_filter_on_darray_objects_d")' alt='+'/> 5.13 Enable filter on darray objects</h2><div id='Enable_filter_on_darray_objects_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/darray.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>    <span class="doccomment">Return a sub list with elements satisfying the given predicate.</span>
<span class="lineno" id=line3></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> filter[T] (P:T -&gt; bool) (arr:<span class="library" title="array with unbounded dynamically variable limit">darray</span>[T]) : <span class="library" title="array with unbounded dynamically variable limit">darray</span>[T] =
<span class="lineno" id=line4></span>    {
<span class="lineno" id=line5></span>      <span class="big_keyword" title="Define a mutable variable">var</span> o = <span class="library" title="array with unbounded dynamically variable limit">darray</span>[T]();
<span class="lineno" id=line6></span>  
<span class="lineno" id=line7></span>      <span class="small_keyword" title="conditional">if</span> arr.<span class="library" title="number of elements in data structure">len</span> &gt; 0uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line8></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> arr.<span class="library" title="number of elements in data structure">len</span> - 1uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line9></span>          <span class="small_keyword" title="conditional">if</span> (P(arr.i)) <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line10></span>        	  push_back (o, arr.i);
<span class="lineno" id=line11></span>          <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line12></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line13></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line14></span>      
<span class="lineno" id=line15></span>      <span class="small_keyword" title="return">return</span> o;
<span class="lineno" id=line16></span>    }
<span class="lineno" id=line17></span>  
<span class="lineno" id=line18></span>  
<span class="lineno" id=line19></span>  }
<span class="lineno" id=line20></span>  
</pre></p></div><h2 id='As_a_set_h'><img src='/share/src/web/images/minus.gif' id='As a set' onclick='toggle(this,"As_a_set_d")' alt='+'/> 5.14 As a set</h2><div id='As_a_set_d' style='display:block'>
<p>Should be in main class body.
</p><pre class='inclusion'>
share/lib/std/datatype/darray.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="doccomment">Construe a darray as a Set.</span>
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[T <span class="small_keyword" title="type-class constraint">with</span> Eq[T]] Set[<span class="library" title="array with unbounded dynamically variable limit">darray</span>[T],T] {
<span class="lineno" id=line3></span>   <span class="doccomment">element membership test.</span>
<span class="lineno" id=line4></span>   <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="tex_symbol" title="\in">\(\in\)</span> (x:T, a:<span class="library" title="array with unbounded dynamically variable limit">darray</span>[T]) : bool = {
<span class="lineno" id=line5></span>     <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> <span class="library" title="number of elements in data structure">len</span> a -1uz 
<span class="lineno" id=line6></span>       <span class="small_keyword" title="conditional">if</span> a.i == x <span class="small_keyword" title="return">return</span> <span class="library" title="truth value">true</span>
<span class="lineno" id=line7></span>     ; 
<span class="lineno" id=line8></span>     <span class="small_keyword" title="return">return</span> <span class="library" title="false value">false</span>;
<span class="lineno" id=line9></span>   } 
<span class="lineno" id=line10></span>  }
<span class="lineno" id=line11></span>  
<span class="lineno" id=line12></span>  <span class="big_keyword" title="Open a module or class">open</span>[T] Show[Darray::<span class="library" title="array with unbounded dynamically variable limit">darray</span>[T]];
<span class="lineno" id=line13></span>  <span class="big_keyword" title="Open a module or class">open</span>[T] Set[Darray::<span class="library" title="array with unbounded dynamically variable limit">darray</span>[T],T];
<span class="lineno" id=line14></span>  
<span class="lineno" id=line15></span>  <span class="big_keyword" title="Open a module or class">open</span>[T] ArrayValue[<span class="library" title="array with unbounded dynamically variable limit">darray</span>[T], T];
<span class="lineno" id=line16></span>  <span class="big_keyword" title="Open a module or class">open</span>[T] ArrayObject[<span class="library" title="array with unbounded dynamically variable limit">darray</span>[T], T];
<span class="lineno" id=line17></span>  <span class="big_keyword" title="Open a module or class">open</span>[T] ContiguousArrayObject[<span class="library" title="array with unbounded dynamically variable limit">darray</span>[T], T];
<span class="lineno" id=line18></span>  
</pre></p></div></div><h1 id='Sarray_h'><img src='/share/src/web/images/minus.gif' id='Sarray' onclick='toggle(this,"Sarray_d")' alt='+'/> 6 Sarray</h1><div id='Sarray_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/sarray.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="doccomment">Unbounded sparse psuedo-array sarray.</span>
<span class="lineno" id=line3></span>  <span class="doccomment">This data type is not a real array because it has no bounds</span>
<span class="lineno" id=line4></span>  <span class="doccomment">and therefore cannot support iteration.</span>
<span class="lineno" id=line5></span>  <span class="big_keyword" title="Open a module or class">open</span> <span class="big_keyword" title="Define a type class">class</span> Sarray
<span class="lineno" id=line6></span>  {
<span class="lineno" id=line7></span>    <span class="big_keyword" title="Open a module or class">open</span> Judy;
<span class="lineno" id=line8></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> <span class="big_keyword" title="Define a structure">struct</span> sarray_ctl[T] { a: <span class="library" title="array with unbounded dynamically variable limit">darray</span>[T]; j:JLArray; free:J1Array; dflt:T; };
<span class="lineno" id=line9></span>  
<span class="lineno" id=line10></span>    <span class="doccomment">Type of a sarray.</span>
<span class="lineno" id=line11></span>    <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> <span class="library" title="unbounded sparse array">sarray</span>[T] = new &amp;sarray_ctl[T];
<span class="lineno" id=line12></span>  
<span class="lineno" id=line13></span>    <span class="doccomment">Construct an infinite sarray with all values set to the given default.</span>
<span class="lineno" id=line14></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span>[T] <span class="library" title="unbounded sparse array">sarray</span>[T] (dflt:T) =&gt; _make_sarray[T]$ new sarray_ctl[T] (<span class="library" title="array with unbounded dynamically variable limit">darray</span>[T](), JLArray(), J1Array(),dflt);
<span class="lineno" id=line15></span>  
<span class="lineno" id=line16></span>    <span class="doccomment">Get the value at the given position.</span>
<span class="lineno" id=line17></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> get[T] (a:<span class="library" title="unbounded sparse array">sarray</span>[T], i:<span class="library" title="binding of C size_t type">size</span>) : T = {
<span class="lineno" id=line18></span>       <span class="big_keyword" title="Define a mutable variable">var</span> pk: &amp;word;
<span class="lineno" id=line19></span>       <span class="big_keyword" title="Define a mutable variable">var</span> e: JError_t;
<span class="lineno" id=line20></span>       JudyLGet ( (_repr_ a)*.j, i.word, &amp;e, &amp;pk);
<span class="lineno" id=line21></span>       <span class="big_keyword" title="Define a mutable variable">var</span> r = <span class="small_keyword" title="conditional">if</span> <span class="hack">C_hack</span>::isNULL pk <span class="small_keyword" title="conditional">then</span> (_repr_ a)*.dflt <span class="small_keyword" title="conditional">else</span> (_repr_ a)*.a.(<span class="library" title="binding of C size_t type">size</span>(*pk));
<span class="lineno" id=line22></span>       <span class="small_keyword" title="return">return</span> r;
<span class="lineno" id=line23></span>    }
<span class="lineno" id=line24></span>      
<span class="lineno" id=line25></span>    <span class="doccomment">Set the given value at the given position.</span>
<span class="lineno" id=line26></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> set[T] (a:<span class="library" title="unbounded sparse array">sarray</span>[T], i:<span class="library" title="binding of C size_t type">size</span>, v:T) {
<span class="lineno" id=line27></span>      <span class="big_keyword" title="Define a mutable variable">var</span> pk: &amp;word;
<span class="lineno" id=line28></span>      <span class="big_keyword" title="Define a mutable variable">var</span> e: JError_t;
<span class="lineno" id=line29></span>      JudyLGet ( (_repr_ a)*.j, i.word, &amp;e, &amp;pk);    <span class="comment">// see if already in array</span>
<span class="lineno" id=line30></span>      <span class="small_keyword" title="conditional">if</span> <span class="hack">C_hack</span>::isNULL pk <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line31></span>        <span class="big_keyword" title="Define a mutable variable">var</span> idx: word = word 0;
<span class="lineno" id=line32></span>        <span class="big_keyword" title="Define a mutable variable">var</span> b: <span class="library" title="binding of C int type">int</span>;
<span class="lineno" id=line33></span>        Judy1First((_repr_ a)*.free,&amp;idx,&amp;e,&amp;b);     <span class="comment">// try to find a free slot</span>
<span class="lineno" id=line34></span>        <span class="small_keyword" title="conditional">if</span> b == 0 <span class="small_keyword" title="imperative code begins">do</span>                                <span class="comment">// none?</span>
<span class="lineno" id=line35></span>          idx = word (<span class="library" title="number of elements in data structure">len</span> (_repr_ a)*.a);
<span class="lineno" id=line36></span>          push_back ((_repr_ a)*.a, v);              <span class="comment">// then push onto array end</span>
<span class="lineno" id=line37></span>        <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line38></span>          Judy1Unset((_repr_ a)*.free,idx,&amp;e,&amp;b);     <span class="comment">// remove free slot from free set</span>
<span class="lineno" id=line39></span>          set ((_repr_ a)*.a,<span class="library" title="binding of C size_t type">size</span> idx,v);            <span class="comment">// store value</span>
<span class="lineno" id=line40></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line41></span>        JudyLIns ( (_repr_ a)*.j,i.word, &amp;e, &amp;pk);    <span class="comment">// add new index to j mapping</span>
<span class="lineno" id=line42></span>        pk &lt;- idx;
<span class="lineno" id=line43></span>      <span class="small_keyword" title="conditional">else</span> 
<span class="lineno" id=line44></span>        set ((_repr_ a)*.a, <span class="library" title="binding of C size_t type">size</span> (*pk), v);
<span class="lineno" id=line45></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line46></span>    }
<span class="lineno" id=line47></span>  
<span class="lineno" id=line48></span>    <span class="doccomment">Replace the value at a given position with the default.</span>
<span class="lineno" id=line49></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> del[T] (a:<span class="library" title="unbounded sparse array">sarray</span>[T], i:<span class="library" title="binding of C size_t type">size</span>) {
<span class="lineno" id=line50></span>      <span class="big_keyword" title="Define a mutable variable">var</span> pk: &amp;word;
<span class="lineno" id=line51></span>      <span class="big_keyword" title="Define a mutable variable">var</span> e: JError_t;
<span class="lineno" id=line52></span>      JudyLGet ( (_repr_ a)*.j, i.word, &amp;e, &amp;pk);     <span class="comment">// see if already in array</span>
<span class="lineno" id=line53></span>      <span class="small_keyword" title="conditional">if</span> <span class="small_keyword" title="logical negation">not</span> <span class="hack">C_hack</span>::isNULL pk <span class="small_keyword" title="imperative code begins">do</span>                    <span class="comment">// if it is</span>
<span class="lineno" id=line54></span>        <span class="big_keyword" title="Define a mutable variable">var</span> b:<span class="library" title="binding of C int type">int</span>;
<span class="lineno" id=line55></span>        Judy1Set ((_repr_ a)*.free, i.word, &amp;e, &amp;b);  <span class="comment">// add slot to free set</span>
<span class="lineno" id=line56></span>        set ( (_repr_ a)*.a, pk*.<span class="library" title="binding of C size_t type">size</span>, (_repr_ a)*.dflt); <span class="comment">// replace old value with default</span>
<span class="lineno" id=line57></span>      <span class="small_keyword" title="end of body">done</span>    
<span class="lineno" id=line58></span>    }
<span class="lineno" id=line59></span>  
<span class="lineno" id=line60></span>    <span class="doccomment">Pack a sparse array. </span>
<span class="lineno" id=line61></span>    <span class="doccomment">This is an optimisation with no semantics.</span>
<span class="lineno" id=line62></span>    <span class="doccomment">Reorganises the sarray to reduce memory use and optimise lookup.</span>
<span class="lineno" id=line63></span>    <span class="doccomment">  // Make a new varray with max number</span>
<span class="lineno" id=line64></span>    <span class="comment">// of elements in the j mapping, then fill it in order</span>
<span class="lineno" id=line65></span>    <span class="comment">// of the j mapping, replacing the j value with the new index</span>
<span class="lineno" id=line66></span>    <span class="comment">// finally replace the original darray with a new one made</span>
<span class="lineno" id=line67></span>    <span class="comment">// from the constructed varray: this is packed and in sequence</span>
<span class="lineno" id=line68></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> pack[T] (a:<span class="library" title="unbounded sparse array">sarray</span>[T]) {
<span class="lineno" id=line69></span>      r := _repr_ a;
<span class="lineno" id=line70></span>      <span class="big_keyword" title="Define a mutable variable">var</span> e: JError_t;
<span class="lineno" id=line71></span>      <span class="big_keyword" title="Define a mutable variable">var</span> n: word;
<span class="lineno" id=line72></span>      JudyLCount (r*.j, word 0, word (-1ul), &amp;e, &amp;n);
<span class="lineno" id=line73></span>      <span class="big_keyword" title="Define a mutable variable">var</span> x = <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[T] n.<span class="library" title="binding of C size_t type">size</span>;
<span class="lineno" id=line74></span>      <span class="big_keyword" title="Define a mutable variable">var</span> index = word 0;      
<span class="lineno" id=line75></span>      <span class="big_keyword" title="Define a mutable variable">var</span> i = 0ul;         <span class="comment">// slot index for new array</span>
<span class="lineno" id=line76></span>      <span class="big_keyword" title="Define a mutable variable">var</span> slot : &amp;word;
<span class="lineno" id=line77></span>      JudyLFirst(r*.j, &amp;index, &amp;e, &amp;slot);
<span class="lineno" id=line78></span>      <span class="small_keyword" title="while loop">while</span> <span class="small_keyword" title="logical negation">not</span> isNULL slot <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line79></span>        push_back (x, r*.a.((*slot).<span class="library" title="binding of C size_t type">size</span>));
<span class="lineno" id=line80></span>        slot &lt;- i.word; ++i;
<span class="lineno" id=line81></span>        JudyLNext(r*.j, &amp;index, &amp;e, &amp;slot);
<span class="lineno" id=line82></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line83></span>      <span class="big_keyword" title="Define a mutable variable">var</span> m : word;
<span class="lineno" id=line84></span>      Judy1FreeArray(r*.free,&amp;e,&amp;m);
<span class="lineno" id=line85></span>      <span class="comment">//println$ m.ulong.str + " bytes freed --&gt; counted "+n.ulong.str;</span>
<span class="lineno" id=line86></span>      r.a &lt;- <span class="library" title="array with unbounded dynamically variable limit">darray</span> x;
<span class="lineno" id=line87></span>    }
<span class="lineno" id=line88></span>  }
<span class="lineno" id=line89></span>  
</pre></p></div><h1 id='Bsarray_h'><img src='/share/src/web/images/minus.gif' id='Bsarray' onclick='toggle(this,"Bsarray_d")' alt='+'/> 7 Bsarray</h1><div id='Bsarray_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/bsarray.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  
<span class="lineno" id=line3></span>  <span class="doccomment">Bounded sparse array.</span>
<span class="lineno" id=line4></span>  <span class="doccomment">Basically a sarray with a given bound.</span>
<span class="lineno" id=line5></span>  <span class="doccomment">The bound is ignored for get and set methods.</span>
<span class="lineno" id=line6></span>  <span class="doccomment">The bound is used for membership tests and iteration.</span>
<span class="lineno" id=line7></span>  <span class="big_keyword" title="Include a Felix file">include</span> <span class="fstring">"std/datatype/sarray"</span>;
<span class="lineno" id=line8></span>  <span class="big_keyword" title="Open a module or class">open</span> <span class="big_keyword" title="Define a type class">class</span> Bsarray
<span class="lineno" id=line9></span>  {
<span class="lineno" id=line10></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> <span class="big_keyword" title="Define a structure">struct</span> bsarray_ctl[T] { a: <span class="library" title="unbounded sparse array">sarray</span>[T]; n:<span class="library" title="binding of C size_t type">size</span>; };
<span class="lineno" id=line11></span>    <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> <span class="library" title="bounded sparse array">bsarray</span>[T] = new &amp;bsarray_ctl[T];
<span class="lineno" id=line12></span>  
<span class="lineno" id=line13></span>    <span class="doccomment">Contruct with default value and bound.</span>
<span class="lineno" id=line14></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span>[T,I <span class="small_keyword" title="membership operator, function mem">in</span> ints] <span class="library" title="bounded sparse array">bsarray</span>[T] (dflt:T, bound:I) =&gt;
<span class="lineno" id=line15></span>      _make_bsarray[T]$ new bsarray_ctl[T] (<span class="library" title="unbounded sparse array">sarray</span>[T](dflt), bound.<span class="library" title="binding of C size_t type">size</span>)
<span class="lineno" id=line16></span>    ;
<span class="lineno" id=line17></span>   
<span class="lineno" id=line18></span>    <span class="doccomment">Contrue as array value.</span>
<span class="lineno" id=line19></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[T] ArrayValue[<span class="library" title="bounded sparse array">bsarray</span>[T],T] {
<span class="lineno" id=line20></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="number of elements in data structure">len</span>(b:<span class="library" title="bounded sparse array">bsarray</span>[T])=&gt; (_repr_ b)*.n;
<span class="lineno" id=line21></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> unsafe_get(b:<span class="library" title="bounded sparse array">bsarray</span>[T], i:<span class="library" title="binding of C size_t type">size</span>)=&gt; get ((_repr_ b)*.a, i);
<span class="lineno" id=line22></span>    }
<span class="lineno" id=line23></span>  
<span class="lineno" id=line24></span>    <span class="doccomment">Contrue as array object.</span>
<span class="lineno" id=line25></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[T] ArrayObject[<span class="library" title="bounded sparse array">bsarray</span>[T],T] {
<span class="lineno" id=line26></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> unsafe_set(b:<span class="library" title="bounded sparse array">bsarray</span>[T], i:<span class="library" title="binding of C size_t type">size</span>, v:T)=&gt; set ((_repr_ b)*.a, i, v);
<span class="lineno" id=line27></span>    }
<span class="lineno" id=line28></span>  
<span class="lineno" id=line29></span>    <span class="doccomment">Contrue as set: membership test.</span>
<span class="lineno" id=line30></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[T <span class="small_keyword" title="type-class constraint">with</span> Eq[T]] Set[<span class="library" title="bounded sparse array">bsarray</span>[T],T] {
<span class="lineno" id=line31></span>     <span class="comment">// FIX ME: inefficient!</span>
<span class="lineno" id=line32></span>     <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="tex_symbol" title="\in">\(\in\)</span> (x:T, a:<span class="library" title="bounded sparse array">bsarray</span>[T]) : bool = {
<span class="lineno" id=line33></span>       <span class="small_keyword" title="conditional">if</span> <span class="library" title="number of elements in data structure">len</span> a &gt; 0uz
<span class="lineno" id=line34></span>         <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i <span class="small_keyword" title="membership operator, function mem">in</span> 0uz <span class="small_keyword" title="upwards counting for loop">upto</span> <span class="library" title="number of elements in data structure">len</span> a - 1uz
<span class="lineno" id=line35></span>           <span class="small_keyword" title="conditional">if</span> a.i == x <span class="small_keyword" title="return">return</span> <span class="library" title="truth value">true</span>
<span class="lineno" id=line36></span>       ; 
<span class="lineno" id=line37></span>       <span class="small_keyword" title="return">return</span> <span class="library" title="false value">false</span>;
<span class="lineno" id=line38></span>     } 
<span class="lineno" id=line39></span>    }
<span class="lineno" id=line40></span>  
<span class="lineno" id=line41></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[T <span class="small_keyword" title="type-class constraint">with</span> Show[T]] Str[Bsarray::<span class="library" title="bounded sparse array">bsarray</span>[T]] {
<span class="lineno" id=line42></span>      <span class="doccomment">Convert to string.</span>
<span class="lineno" id=line43></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="Convert a value to a string">str</span> (xs:<span class="library" title="bounded sparse array">bsarray</span>[T]) = {
<span class="lineno" id=line44></span>        <span class="big_keyword" title="Define a mutable variable">var</span> o = <span class="fstring">'bsarray('</span>;
<span class="lineno" id=line45></span>  
<span class="lineno" id=line46></span>        <span class="small_keyword" title="conditional">if</span> <span class="library" title="number of elements in data structure">len</span> xs &gt; 0uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line47></span>          o += repr xs.0;
<span class="lineno" id=line48></span>  
<span class="lineno" id=line49></span>          <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i <span class="small_keyword" title="membership operator, function mem">in</span> 1uz <span class="small_keyword" title="upwards counting for loop">upto</span> <span class="library" title="number of elements in data structure">len</span> xs - 1uz <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line50></span>            o += <span class="fstring">', '</span> + repr xs.i;
<span class="lineno" id=line51></span>          <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line52></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line53></span>  
<span class="lineno" id=line54></span>        <span class="small_keyword" title="return">return</span> o + <span class="fstring">')'</span>;
<span class="lineno" id=line55></span>      }
<span class="lineno" id=line56></span>    }
<span class="lineno" id=line57></span>  }
<span class="lineno" id=line58></span>  
<span class="lineno" id=line59></span>  
<span class="lineno" id=line60></span>  <span class="big_keyword" title="Open a module or class">open</span>[T] Show[Bsarray::<span class="library" title="bounded sparse array">bsarray</span>[T]];
<span class="lineno" id=line61></span>  <span class="big_keyword" title="Open a module or class">open</span>[T] Set[Bsarray::<span class="library" title="bounded sparse array">bsarray</span>[T],T];
<span class="lineno" id=line62></span>  <span class="big_keyword" title="Open a module or class">open</span>[T] ArrayValue[<span class="library" title="bounded sparse array">bsarray</span>[T], T];
<span class="lineno" id=line63></span>  <span class="big_keyword" title="Open a module or class">open</span>[T] ArrayObject[<span class="library" title="bounded sparse array">bsarray</span>[T], T];
<span class="lineno" id=line64></span>  <span class="big_keyword" title="Open a module or class">open</span>[T] ContiguousArrayObject[<span class="library" title="bounded sparse array">bsarray</span>[T], T];
<span class="lineno" id=line65></span>  
<span class="lineno" id=line66></span>  
</pre></p></div><!--Main Content Body End-->

          </div> <!-- rightpanel contents end -->
          <hr>
        </span> <!-- rightpanel end -->

        <span id="panemover" style="cursor:col-resize;"
         onmousedown="dragStart(event, 'left', 'right'); return false;"
         onmousemove="drag(event, 'left', 'right');"
         onmouseout="dragRelease();"
         onmouseup="dragRelease();"
        >
        </span> <!-- panemover end -->
      </div> <!-- bottom panel end -->
    </div> <!-- container end -->
</body></html>

