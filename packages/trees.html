<html><head>
<style type="text/css">
body {margin:3%; }
h1 {color:gray; font-size:120%;}
h2 {color:gray; font-size:105%;}
h3 {font-size:100%;}
h4 {font-size:95%;}
h5 {font-size:95%;}
span.fstring {color:darkblue; font-style:italic; }
span.comment {font-family:arial; color:blue; font-style:italic; }
span.doccomment {font-family:arial; color:green; font-style:italic; }
span.big_keyword {color:#FF1010; }
span.small_keyword {color:#802040; }
span.qualifier {color:#A02020; }
span.library {color:#A02000; }
span.ctor {color:#406020; }
span.hack {color:#66DD00; }
span.preproc {color:#005500; }
span.embedded_c{background-color:#DDDDDD; }
span.fpc_fieldname {color:#DD0000; }
span.lineno {color:#101010; background-color:#E0E0E0; font-size:80%; font-family:"courier",monospace; font-style:normal; }
pre.flxbg {background-color:#A0FFA0; color:black; padding:2px; box-shadow:5px 5px 2px #807080; }
pre.uncheckedflxbg {background-color:#D0D0D0; color:black; padding:2px; box-shadow:5px 5px 2px #807080; }
pre.cppbg {background-color:#80FF80; color:black; }
pre.prefmtbg {background-color:#D0D0D0; color:black; }
pre.expected {background-color:#E0FF80; color:black; }
pre.input {background-color:#E08080; color:black; }
pre.inclusion {background-color:#D070D0; color:black; }
code.inclusion {background-color:#D070D0; color:black; }
.obsolete { background-color:#FFEFEF; font-size: small; color:black; }
.future { background-color:#FF8080; font-size: small; color:black; }
.implementation_detail { background-color:#E0E0E0; font-size: small; color:black;  }
.bug { background-color:#FFE0E0; font-size: small; color:black; }
.fixed{ background-color:#FFE0E0; font-size: small; color:black; }
.done { background-color:#FFE0E0; font-size: small; color:black; }
.caveat { background-color:#FF8080; color:black; }
</style>

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
        skipTags: ["script","noscript","style","textarea"]
    }
  });
</script>
<title>Tree and graph data types</title></head><body>
<style>
body {margin:3%; font-family: sans-serif; }
h1 {color:black; font-size:120%; border-bottom: 2px solid #ddd; padding: 0 0 3px 0;}
h2 {color:#202020; font-size:105%;}
h3 {font-size:100%;}
h4 {font-size:95%;}
h5 {font-size:95%;}
span.fstring {color:darkblue; font-style:italic; }
span.comment {font-family:arial; color:blue; font-style:italic; }
span.doccomment {font-family:arial; color:green; font-style:italic; }
span.big_keyword {color:#FF1010; }
span.small_keyword {color:#802040; }
span.qualifier {color:#A02020; }
span.library {color:#A02000; }
span.ctor {color:#406020; }
span.hack {color:#66DD00; }
span.preproc {color:#005500; }
span.embedded_c{background-color:#DDDDDD; }
span.fpc_fieldname {color:#DD0000; }
span.lineno {color:#101010; background-color:#E0E0E0; font-size:80%; font-family:"courier",monospace; font-style:normal; }
pre { border: 1px solid #ccc; color: black; box-shadow:3px 3px 2px rgba(0,0,0,0.1); padding:2px; }
pre.flxbg {background-color:#C2FDC2; box-shadow:3px 3px 2px rgba(0,0,0,0.1) }
pre.uncheckedflxbg {background-color:#eee; box-shadow:3px 3px 2px rgba(0,0,0,0.1); }
pre.cppbg {background-color:#C2FDC2; }
pre.prefmtbg {background-color:#F1F1F1; }
pre.expected {background-color:hsla(74,94%,88%,1); }
pre.input {background-color:hsla(20,94%,88%,1); }
pre.inclusion {
    font-family: Arial;
    font-weight: normal;
    font-size: 0.9em;
    color: #555;
    border: none;
    box-shadow: none;
    text-align: right;
    margin: -7px 11px -12px 0;
    padding: 0;
    background-color:#fafafa;
}
code.inclusion {background-color:#D070D0; color:black; }
.obsolete { background-color:#FFEFEF; font-size: small; color:black; }
.future { background-color:#FF8080; font-size: small; color:black; }
.implementation_detail { background-color:#E0E0E0; font-size: small; color:black;  }
.bug { background-color:#FFE0E0; font-size: small; color:black; }
.fixed{ background-color:#FFE0E0; font-size: small; color:black; }
.done { background-color:#FFE0E0; font-size: small; color:black; }
.caveat { background-color:hsla(0,100%,91%,1); color:black; padding: 0.6em; }
.container {
  position: fixed;
  top:0px;
  left:0px;
  height : 100%;
  width: 100%;
  background-color: grey;
  margin: 0px;
  padding: 0px;
  border-width: 0px;
  color: #404040;
}
.maincontent {
  padding:4px;
  padding-left:8px;
  line-height:1.3em;
  color:#404040; background-color:#fafafa;
}
.maincontent h1 { margin-left:-8px; position: relative; font-family: georgia, serif; font-size: 1.8em; font-weight: normal; }
.maincontent h2 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent h3 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent h4 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent code { color:#902030; }
.toppanel {
  position:absolute; left:0px; top:0px; height:20px; right:0px;
  background-color: #e0e0e0;
}
.bottompanel {
  position:absolute; left:0px; top:22px; bottom:0px; right:0px;
  background-color: #fafafa;
  font-size:14px;
}
.leftpanel {
  position:absolute; left:0px; top:0px; bottom:0px; width: 150px;
  background-color: #eaeaea; overflow: auto;
}
.rightpanel {
  position:absolute; right: 0px; left:160px; top:0px; bottom: 0px;
  background-color: #fafafa; overflow: auto;
}
.divider {
  position:absolute; left: 150px; top:0px; bottom:0px;
  background-color: black; width:2px;
  box-shadow: 0 0 8px #000;
}

#panemover {
    position:absolute;
    left: 150px;
    width : 10px;
    top: 0px;
    bottom: 0px;
    opacity: 0.3;
    cursor:col-resize;
}

div.m {
    margin: 0px;
    padding:0px;
    border-width:2px;
    border-color: green;
}

div.m1 {
    background-color: #86E870;
    border-style:outset;
    border-color:#ccc;
    border-width:2px 0;
    font-size:90%;
    padding: 1px 0 2px 10px;
}

div.m2 {
    background-color: #70C070;
    padding-left:15px;
    padding-top:2px;
    border-style:outset;
    border-color:green;
    border-width:0 0 1px 0;
    font-size:80%;
}

div.m1:hover, div.m2:hover {
    background-color: white;
}

#leftmargintoc a {
    text-decoration: none;
    color: #404040;
}
</style>

<style>
div.m {
    margin: 0px;
    padding:0px;
    border-width:2px;
    border-color: green;
}

div.m1 {
    background-color: #86E870;
    border-style:outset;
    border-color:#ccc;
    border-width:2px 0;
    font-size:90%;
    padding: 1px 0 2px 10px;
}

div.m2 {
    background-color: #70C070;
    padding-left:15px;
    padding-top:2px;
    border-style:outset;
    border-color:green;
    border-width:0 0 1px 0;
    font-size:80%;
}

div.m1:hover, div.m2:hover {
    background-color: white;
}

#leftmargintoc a {
    text-decoration: none;
    color: #404040;
}


</style>

    <script async="true">
      function dragStart(e, left, right){
        document.getElementById("panemover").style.width="70%";
        document.getElementById("panemover").style.left="50px";
        mousedown = true;
        x = e.clientX
        dragOffsetLeft =
          document.getElementById(left).getBoundingClientRect().right -
          document.getElementById(left).getBoundingClientRect().left -
          x
        ;
        dragOffsetDivider= document.getElementById("divider").getBoundingClientRect().left - x;
        dragOffsetRight = document.getElementById(right).getBoundingClientRect().left - x;
      }
      function dragRelease(){
        document.getElementById('panemover').style.width = '10px';
        document.getElementById('panemover').style.left = document.getElementById('divider').offsetLeft + 'px';
        mousedown = false;
      }
      function drag(e, left, right){
        if(!mousedown){return}
        x = e.clientX
        tmpLeft = dragOffsetLeft + x
        tmpDivider= dragOffsetDivider + x
        tmpRight = dragOffsetRight + x
        document.getElementById(left).style.width= tmpLeft + 'px';
        document.getElementById("divider").style.left= tmpDivider + 'px';
        document.getElementById(right).style.left = tmpRight + 'px';
      };
    </script>

<script type="text/javascript">

  function mexpand(id)
  {
    var n = document.getElementById(id).style;
    n.display = "block";
  }

  function mcollapse(id)
  {
    var n = document.getElementById(id).style;
    n.display = "none";
  }

  var counter_max = 0;
  function mshow(id,loc)
  {
    var i;
    for(i=1; i<=counter_max; ++i)
      mcollapse("menu"+String(i));
    mexpand(id);
    window.location.replace(loc);
  }
</script>

<script type="text/javascript">

function expand(but,id)
{
  var n = document.getElementById(id).style;
  var button = document.getElementById(but);
  button.src = "/share/src/web/images/minus.gif";
  button.alt = "-";
  n.display = "block";
}
function collapse(but,id)
{
  var n = document.getElementById(id).style;
  var button = document.getElementById(but);
  button.src = "/share/src/web/images/plus.gif";
  button.alt = "+";
  n.display = "none";
}
function toggle(button,id)
{
  var n = document.getElementById(id).style;
  if (n.display == "none")
  {
    button.src = "/share/src/web/images/minus.gif";
    button.alt = "-";
    n.display = "block";
  }
  else
  {
    button.src = "/share/src/web/images/plus.gif";
    button.alt = "+";
    n.display = "none";
  }
}
var allbuttons = [
"Array backed Heap",
"AVL tree",
"Directed Graph",
"Partition with Union-Find",
"Binary Search Tree",
"Description.",
"Implementation.",
"Type.",
"Quick Checks.",
"String representation",
"Find.",
"min.",
"iter.",
"Fold.",
"Map.",
"Constructors.",
"Insert routine",
"Comprehension.",
"Iterator.",
"As a set.",
"As a container.",
"Delete by value.",
"Judy Arrays",
"String Dictionary."
];
function expand_all(dummy)
{
  for (i in allbuttons)
  {
    expand(allbuttons[i], allbuttons[i]+"_d");
  }
}
function collapse_all(dummy)
{
  for (i in allbuttons)
  {
    collapse(allbuttons[i], allbuttons[i]+"_d");
  }
}
</script>

<script>
function mouseover(id)
{
  var elt = document.getElementById(id);
  elt.style.display="none";
  var elt2 = document.getElementById(id+"_mo");
  elt2.style.display="inline";
}

function mouseout(id)
{
  var elt = document.getElementById(id+"_mo");
  elt.style.display="none";
  var elt2 = document.getElementById(id);
  elt2.style.display="inline";
}

</script>
<script> function nop(dummy) {} </script>
    <div class="container">
      <div class="toppanel">
    <!--Main Content top navbar-->
<span style="position:relative; bottom:6px"
  onmouseover="mouseover('expand')"
  onmouseout="mouseout('expand')"
  onclick="expand_all('expand')"
  ><span id="expand"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:blue;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Expand</text></svg></span><span id="expand_mo" style="display:none"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:red;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Expand</text></svg></span></span><span style="position:relative; bottom:6px"
  onmouseover="mouseover('collapse')"
  onmouseout="mouseout('collapse')"
  onclick="collapse_all('collapse')"
  ><span id="collapse"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:blue;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Collapse</text></svg></span><span id="collapse_mo" style="display:none"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:red;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Collapse</text></svg></span></span>    <!--Main Content top navbar End-->

      </div> <!-- toppanel end -->
      <div class="bottompanel">
        <span id="divider" class="divider"></span>

        <span id="left" class="leftpanel" >
          <div class="menucontent">
  <!--Left Margin Toc-->
  <div id="leftmargintoc">
    <!--Left Margin Toc Main Contents-->
      <div class=m1 onclick="mshow('menu1','#Array backed Heap_h')"> <a href="#Array_backed_Heap_h">Array backed Heap</a></div>
      <div class=sm id=menu1>
      </div>
      <div class=m1 onclick="mshow('menu2','#AVL tree_h')"> <a href="#AVL_tree_h">AVL tree</a></div>
      <div class=sm id=menu2>
      </div>
      <div class=m1 onclick="mshow('menu3','#Directed Graph_h')"> <a href="#Directed_Graph_h">Directed Graph</a></div>
      <div class=sm id=menu3>
      </div>
      <div class=m1 onclick="mshow('menu4','#Partition with Union-Find_h')"> <a href="#Partition_with_Union-Find_h">Partition with Union-Find</a></div>
      <div class=sm id=menu4>
      </div>
      <div class=m1 onclick="mshow('menu5','#Binary Search Tree_h')"> <a href="#Binary_Search_Tree_h">Binary Search Tree</a></div>
      <div class=sm id=menu5>
      </div>
      <div class=m1 onclick="mshow('menu6','#Description._h')"> <a href="#Description._h">Description.</a></div>
      <div class=sm id=menu6>
      <div class=m2><a href="#Implementation._h">Implementation.</a></div>
      <div class=m2><a href="#Type._h">Type.</a></div>
      <div class=m2><a href="#Quick_Checks._h">Quick Checks.</a></div>
      <div class=m2><a href="#String_representation_h">String representation</a></div>
      <div class=m2><a href="#Find._h">Find.</a></div>
      <div class=m2><a href="#min._h">min.</a></div>
      <div class=m2><a href="#iter._h">iter.</a></div>
      <div class=m2><a href="#Fold._h">Fold.</a></div>
      <div class=m2><a href="#Map._h">Map.</a></div>
      <div class=m2><a href="#Constructors._h">Constructors.</a></div>
      <div class=m2><a href="#Insert_routine_h">Insert routine</a></div>
      <div class=m2><a href="#Comprehension._h">Comprehension.</a></div>
      <div class=m2><a href="#Iterator._h">Iterator.</a></div>
      <div class=m2><a href="#As_a_set._h">As a set.</a></div>
      <div class=m2><a href="#As_a_container._h">As a container.</a></div>
      <div class=m2><a href="#Delete_by_value._h">Delete by value.</a></div>
      </div>
      <div class=m1 onclick="mshow('menu7','#Judy Arrays_h')"> <a href="#Judy_Arrays_h">Judy Arrays</a></div>
      <div class=sm id=menu7>
      </div>
      <div class=m1 onclick="mshow('menu8','#String Dictionary._h')"> <a href="#String_Dictionary._h">String Dictionary.</a></div>
      <div class=sm id=menu8>
      </div>
    <script>counter_max=8;</script>
  </div>
  <!--End Left Margin Toc-->

          </div> <!-- leftpanel contents end -->
        </span> <!-- leftpanel end -->

        <span id="right" class="rightpanel">
          <div class="maincontent">
<!--Main Content Body-->
<h1 id='Array_backed_Heap_h'><img src='/share/src/web/images/minus.gif' id='Array backed Heap' onclick='toggle(this,"Array_backed_Heap_d")' alt='+'/> 1 Array backed Heap</h1><div id='Array_backed_Heap_d' style='display:block'>
<p>We provide a min-heap using a <code>darray</code> for storage.
</p><pre class='inclusion'>
share/lib/std/datatype/heap.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Define a type class">class</span> MinHeap[T <span class="small_keyword" title="type-class constraint">with</span> Tord[T]] 
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> left_child (p:<span class="library" title="binding of C int type">int</span>)  =&gt; 2*p + 1;
<span class="lineno" id=line4></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> right_child (p:<span class="library" title="binding of C int type">int</span>) =&gt; 2*p + 2;
<span class="lineno" id=line5></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> parent (c:<span class="library" title="binding of C int type">int</span>) =&gt; <span class="small_keyword" title="conditional">if</span> c == 0 <span class="small_keyword" title="conditional">then</span> 0 <span class="small_keyword" title="conditional">else</span> (c - 1)/2;
<span class="lineno" id=line6></span>  
<span class="lineno" id=line7></span>    <span class="big_keyword" title="Specify core semantics">axiom</span> family (i:<span class="library" title="binding of C int type">int</span>): i == i.left_child.parent <span class="small_keyword" title="logical conjunction">and</span> i == i.right_child.parent;
<span class="lineno" id=line8></span>    <span class="big_keyword" title="Define an alias for a type expression">typedef</span> minheap_t = <span class="library" title="array with unbounded dynamically variable limit">darray</span>[T];
<span class="lineno" id=line9></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> minheap_t () =&gt; <span class="library" title="array with unbounded dynamically variable limit">darray</span>[T] ();
<span class="lineno" id=line10></span>    <span class="big_keyword" title="Specify core semantics">axiom</span> left_heap (m:minheap_t, i:<span class="library" title="binding of C int type">int</span>): 
<span class="lineno" id=line11></span>      i.left_child &lt; m.<span class="library" title="number of elements in data structure">len</span>.<span class="library" title="binding of C int type">int</span> <span class="small_keyword" title="logical disjunction">or</span> m.i &lt; m.(i.left_child)
<span class="lineno" id=line12></span>    ;
<span class="lineno" id=line13></span>  
<span class="lineno" id=line14></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> heap_swap (h:minheap_t,i:<span class="library" title="binding of C int type">int</span>,j:<span class="library" title="binding of C int type">int</span>) { 
<span class="lineno" id=line15></span>      <span class="big_keyword" title="Define a mutable variable">var</span> tmp = h.i; 
<span class="lineno" id=line16></span>      set(h,i,h.j); 
<span class="lineno" id=line17></span>      set(h,j,tmp); 
<span class="lineno" id=line18></span>    }
<span class="lineno" id=line19></span>  
<span class="lineno" id=line20></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> bubble_up(h:minheap_t, j:<span class="library" title="binding of C int type">int</span>)
<span class="lineno" id=line21></span>    {
<span class="lineno" id=line22></span>       <span class="big_keyword" title="Define a mutable variable">var</span> p = parent j; <span class="comment">// parent of root is itself</span>
<span class="lineno" id=line23></span>       <span class="small_keyword" title="conditional">if</span> h.p &gt; h.j <span class="small_keyword" title="imperative code begins">do</span> <span class="comment">// and so can't satisfy this condition</span>
<span class="lineno" id=line24></span>          heap_swap(h,p,j);
<span class="lineno" id=line25></span>          bubble_up(h,p);
<span class="lineno" id=line26></span>       <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line27></span>    }
<span class="lineno" id=line28></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> heap_insert (h:minheap_t) (elt:T) { 
<span class="lineno" id=line29></span>      push_back (h,elt);
<span class="lineno" id=line30></span>      bubble_up (h,h.<span class="library" title="number of elements in data structure">len</span>.<span class="library" title="binding of C int type">int</span> - 1);
<span class="lineno" id=line31></span>    }
<span class="lineno" id=line32></span>  
<span class="lineno" id=line33></span>    <span class="comment">// this procedure does nothing if the index p </span>
<span class="lineno" id=line34></span>    <span class="comment">// is greater than or equal to the limit - 2, </span>
<span class="lineno" id=line35></span>    <span class="comment">// since the last used slot is lim - 1, </span>
<span class="lineno" id=line36></span>    <span class="comment">// and that node cannot have any children.</span>
<span class="lineno" id=line37></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> bubble_down_lim (h:minheap_t, p:<span class="library" title="binding of C int type">int</span>, lim:<span class="library" title="binding of C int type">int</span>) {
<span class="lineno" id=line38></span>      <span class="big_keyword" title="Define a mutable variable">var</span> min_index = p;
<span class="lineno" id=line39></span>      <span class="big_keyword" title="Define a mutable variable">var</span> left = p.left_child;
<span class="lineno" id=line40></span>      <span class="small_keyword" title="conditional">if</span> left &lt; lim <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line41></span>        <span class="small_keyword" title="conditional">if</span> h.min_index &gt; h.left perform min_index = left;
<span class="lineno" id=line42></span>        <span class="big_keyword" title="Define a mutable variable">var</span> right = left + 1;
<span class="lineno" id=line43></span>        <span class="small_keyword" title="conditional">if</span> right &lt; lim
<span class="lineno" id=line44></span>          <span class="small_keyword" title="conditional">if</span> h.min_index &gt; h.right perform min_index = right; 
<span class="lineno" id=line45></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line46></span>      <span class="small_keyword" title="conditional">if</span> min_index != p <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line47></span>        heap_swap (h, p, min_index);
<span class="lineno" id=line48></span>        bubble_down_lim (h, min_index, lim);
<span class="lineno" id=line49></span>      <span class="small_keyword" title="end of body">done</span> 
<span class="lineno" id=line50></span>    }
<span class="lineno" id=line51></span>  
<span class="lineno" id=line52></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> bubble_down (h:minheap_t,p:<span class="library" title="binding of C int type">int</span>) =&gt;
<span class="lineno" id=line53></span>      bubble_down_lim (h, p, h.<span class="library" title="number of elements in data structure">len</span>.<span class="library" title="binding of C int type">int</span>)
<span class="lineno" id=line54></span>    ;
<span class="lineno" id=line55></span>  
<span class="lineno" id=line56></span>    <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> extract_min (h:minheap_t) : <span class="library" title="option type: Some x or None">opt</span>[T] =  {
<span class="lineno" id=line57></span>      <span class="small_keyword" title="conditional">if</span> h.<span class="library" title="number of elements in data structure">len</span>.<span class="library" title="binding of C int type">int</span> == 0 <span class="small_keyword" title="return">return</span> None[T];
<span class="lineno" id=line58></span>        <span class="big_keyword" title="Define a mutable variable">var</span> min = h.0;
<span class="lineno" id=line59></span>        set(h,0,h.(h.<span class="library" title="number of elements in data structure">len</span>.<span class="library" title="binding of C int type">int</span> - 1));
<span class="lineno" id=line60></span>        h.pop_back; 
<span class="lineno" id=line61></span>        bubble_down (h,0); 
<span class="lineno" id=line62></span>        <span class="small_keyword" title="return">return</span> Some min;
<span class="lineno" id=line63></span>    }
<span class="lineno" id=line64></span>  
<span class="lineno" id=line65></span>    <span class="comment">// sorts largest to smallest!!</span>
<span class="lineno" id=line66></span>    <span class="comment">// based on extract_min, except the minimum element</span>
<span class="lineno" id=line67></span>    <span class="comment">// is moved to the position at the end of the heap</span>
<span class="lineno" id=line68></span>    <span class="comment">// which would otherwise be deleted.</span>
<span class="lineno" id=line69></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> heap_sort (h:minheap_t) {
<span class="lineno" id=line70></span>      <span class="big_keyword" title="Define a mutable variable">var</span> tosort = h.<span class="library" title="number of elements in data structure">len</span>.<span class="library" title="binding of C int type">int</span>;
<span class="lineno" id=line71></span>      <span class="small_keyword" title="while loop">while</span> tosort &gt; 1 <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line72></span>        --tosort;
<span class="lineno" id=line73></span>        heap_swap(h,0,tosort);
<span class="lineno" id=line74></span>        bubble_down_lim (h,0, tosort); 
<span class="lineno" id=line75></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line76></span>    }
<span class="lineno" id=line77></span>  
<span class="lineno" id=line78></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> heapify (h:minheap_t) {
<span class="lineno" id=line79></span>      <span class="big_keyword" title="Define a mutable variable">var</span> index = h.<span class="library" title="number of elements in data structure">len</span>.<span class="library" title="binding of C int type">int</span> - 2;
<span class="lineno" id=line80></span>      <span class="small_keyword" title="while loop">while</span> index &gt;= 0 <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line81></span>        bubble_down (h, index); --index; 
<span class="lineno" id=line82></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line83></span>    }
<span class="lineno" id=line84></span>  
<span class="lineno" id=line85></span>  }
</pre></p></div><h1 id='AVL_tree_h'><img src='/share/src/web/images/minus.gif' id='AVL tree' onclick='toggle(this,"AVL_tree_d")' alt='+'/> 2 AVL tree</h1><div id='AVL_tree_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/avl.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Define a type class">class</span> Avl
<span class="lineno" id=line3></span>  {
<span class="lineno" id=line4></span>    variant avl[T] =
<span class="lineno" id=line5></span>      | Nil
<span class="lineno" id=line6></span>      | Tree of <span class="library" title="binding of C int type">int</span> * T * avl[T] * avl[T] <span class="comment">// (Height,Object,Left,Right)</span>
<span class="lineno" id=line7></span>    ;
<span class="lineno" id=line8></span>  
<span class="lineno" id=line9></span>    <span class="comment">//==============================</span>
<span class="lineno" id=line10></span>  
<span class="lineno" id=line11></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> _ctor_avl[T] () =&gt; Nil[T];
<span class="lineno" id=line12></span>  
<span class="lineno" id=line13></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> _ctor_avl[T] (x : T, left : avl[T], right : avl[T]) =&gt;
<span class="lineno" id=line14></span>      Tree (max(height(left), height(right)) + 1, x, left, right)
<span class="lineno" id=line15></span>    ;
<span class="lineno" id=line16></span>  
<span class="lineno" id=line17></span>    <span class="comment">//==============================</span>
<span class="lineno" id=line18></span>  
<span class="lineno" id=line19></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> height[T] : avl[T]-&gt;<span class="library" title="binding of C int type">int</span> =
<span class="lineno" id=line20></span>      | #Nil =&gt; 0
<span class="lineno" id=line21></span>      | Tree(h, _, _, _) =&gt; h
<span class="lineno" id=line22></span>    ;
<span class="lineno" id=line23></span>  
<span class="lineno" id=line24></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> slope[T] : avl[T]-&gt;<span class="library" title="binding of C int type">int</span> =
<span class="lineno" id=line25></span>      | #Nil =&gt; 0
<span class="lineno" id=line26></span>      | Tree(_, _, left, right) =&gt; height(left) - height(right)
<span class="lineno" id=line27></span>    ;
<span class="lineno" id=line28></span>  
<span class="lineno" id=line29></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> rot_l[T](tree : avl[T]) =&gt;
<span class="lineno" id=line30></span>      <span class="small_keyword" title="match statement or expression">match</span> tree <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line31></span>        | Tree(_, x, leftL, Tree(_, y, rightL, rightR)) =&gt;
<span class="lineno" id=line32></span>          avl(y, avl(x, leftL, rightL), rightR)
<span class="lineno" id=line33></span>        | x =&gt; x
<span class="lineno" id=line34></span>      <span class="small_keyword" title="end a match statement or expression">endmatch</span>
<span class="lineno" id=line35></span>    ;
<span class="lineno" id=line36></span>  
<span class="lineno" id=line37></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> shift_l[T](tree : avl[T]) =&gt;
<span class="lineno" id=line38></span>      <span class="small_keyword" title="match statement or expression">match</span> tree <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line39></span>        | Tree(_, x, left, right) =&gt;
<span class="lineno" id=line40></span>          <span class="small_keyword" title="conditional">if</span> (slope(right) == 1) <span class="small_keyword" title="conditional">then</span>
<span class="lineno" id=line41></span>            rot_l(avl(x, left, rot_r(right)))
<span class="lineno" id=line42></span>          <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line43></span>            rot_l(tree)
<span class="lineno" id=line44></span>          <span class="small_keyword" title="conditional">endif</span>
<span class="lineno" id=line45></span>        | x =&gt; x
<span class="lineno" id=line46></span>      <span class="small_keyword" title="end a match statement or expression">endmatch</span>
<span class="lineno" id=line47></span>    ;
<span class="lineno" id=line48></span>  
<span class="lineno" id=line49></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> rot_r[T](tree : avl[T]) =&gt;
<span class="lineno" id=line50></span>      <span class="small_keyword" title="match statement or expression">match</span> tree <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line51></span>        | Tree(_, x, Tree(_, y, leftL, leftR), rightR) =&gt;
<span class="lineno" id=line52></span>          avl(y, leftL, avl(x, leftR, rightR))
<span class="lineno" id=line53></span>        | x =&gt; x
<span class="lineno" id=line54></span>      <span class="small_keyword" title="end a match statement or expression">endmatch</span>
<span class="lineno" id=line55></span>    ;
<span class="lineno" id=line56></span>  
<span class="lineno" id=line57></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> shift_r[T](tree : avl[T]) =&gt;
<span class="lineno" id=line58></span>      <span class="small_keyword" title="match statement or expression">match</span> tree <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line59></span>        | Tree(_, x, left, right) =&gt;
<span class="lineno" id=line60></span>          <span class="small_keyword" title="conditional">if</span> (slope(right) == -1) <span class="small_keyword" title="conditional">then</span>
<span class="lineno" id=line61></span>            rot_r(avl(x, rot_r(left), right))
<span class="lineno" id=line62></span>          <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line63></span>            rot_r(tree)
<span class="lineno" id=line64></span>          <span class="small_keyword" title="conditional">endif</span>
<span class="lineno" id=line65></span>        | x =&gt; x
<span class="lineno" id=line66></span>      <span class="small_keyword" title="end a match statement or expression">endmatch</span>
<span class="lineno" id=line67></span>    ;
<span class="lineno" id=line68></span>  
<span class="lineno" id=line69></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> balance[T](tree : avl[T]) =&gt;
<span class="lineno" id=line70></span>      <span class="small_keyword" title="match statement or expression">match</span> slope(tree) <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line71></span>        | x <span class="small_keyword" title="predicative type constraint or precondition">when</span> x == -2 =&gt; shift_l(tree)
<span class="lineno" id=line72></span>        | 2 =&gt; shift_r(tree)
<span class="lineno" id=line73></span>        | _ =&gt; tree
<span class="lineno" id=line74></span>      <span class="small_keyword" title="end a match statement or expression">endmatch</span>
<span class="lineno" id=line75></span>    ;
<span class="lineno" id=line76></span>  
<span class="lineno" id=line77></span>    <span class="comment">//==============================</span>
<span class="lineno" id=line78></span>  
<span class="lineno" id=line79></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> insert[T] (tree : avl[T], y : T, cmp : T*T-&gt;<span class="library" title="binding of C int type">int</span>) =&gt;
<span class="lineno" id=line80></span>      <span class="small_keyword" title="match statement or expression">match</span> tree <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line81></span>        | #Nil =&gt;
<span class="lineno" id=line82></span>          Tree(1, y, Nil[T], Nil[T])
<span class="lineno" id=line83></span>        | Tree(h, x, left, right) =&gt;
<span class="lineno" id=line84></span>          <span class="small_keyword" title="conditional">if</span> cmp(x, y) &gt; 0 <span class="small_keyword" title="conditional">then</span>
<span class="lineno" id=line85></span>            balance(avl(x, (insert(left, y, cmp)), right))
<span class="lineno" id=line86></span>          <span class="small_keyword" title="conditional">elif</span> cmp(x, y) &lt; 0 <span class="small_keyword" title="conditional">then</span>
<span class="lineno" id=line87></span>            balance(avl(x, left, insert(right, y, cmp)))
<span class="lineno" id=line88></span>          <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line89></span>            Tree(h, x, left, right)
<span class="lineno" id=line90></span>          <span class="small_keyword" title="conditional">endif</span>
<span class="lineno" id=line91></span>      <span class="small_keyword" title="end a match statement or expression">endmatch</span>
<span class="lineno" id=line92></span>    ;
<span class="lineno" id=line93></span>  
<span class="lineno" id=line94></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> insert[T] (y : T, cmp : T*T-&gt;<span class="library" title="binding of C int type">int</span>) =&gt;
<span class="lineno" id=line95></span>      insert(Nil[T], y, cmp)
<span class="lineno" id=line96></span>    ;
<span class="lineno" id=line97></span>  
<span class="lineno" id=line98></span>    <span class="comment">//=================================</span>
<span class="lineno" id=line99></span>  
<span class="lineno" id=line100></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> find[T] (tree : avl[T], y : T, cmp : T*T-&gt;<span class="library" title="binding of C int type">int</span>) : <span class="library" title="option type: Some x or None">opt</span>[T] =&gt;
<span class="lineno" id=line101></span>        <span class="small_keyword" title="match statement or expression">match</span> tree <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line102></span>          | #Nil =&gt; None[T]
<span class="lineno" id=line103></span>          | Tree(_, x, left, right) =&gt;
<span class="lineno" id=line104></span>            <span class="small_keyword" title="conditional">if</span> cmp(x, y) &gt; 0 <span class="small_keyword" title="conditional">then</span>
<span class="lineno" id=line105></span>              find(left, y, cmp)
<span class="lineno" id=line106></span>            <span class="small_keyword" title="conditional">elif</span> cmp(x, y) &lt; 0 <span class="small_keyword" title="conditional">then</span>
<span class="lineno" id=line107></span>              find(right, y, cmp)
<span class="lineno" id=line108></span>            <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line109></span>              Some x
<span class="lineno" id=line110></span>            <span class="small_keyword" title="conditional">endif</span>
<span class="lineno" id=line111></span>        <span class="small_keyword" title="end a match statement or expression">endmatch</span>
<span class="lineno" id=line112></span>      ;
<span class="lineno" id=line113></span>  
<span class="lineno" id=line114></span>    <span class="comment">//=================================</span>
<span class="lineno" id=line115></span>  
<span class="lineno" id=line116></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> last[T] : avl[T]-&gt;T =
<span class="lineno" id=line117></span>      | Tree(_, x, _, #Nil) =&gt; x
<span class="lineno" id=line118></span>      | Tree(_, _, _, right) =&gt; last(right)
<span class="lineno" id=line119></span>    ;
<span class="lineno" id=line120></span>  
<span class="lineno" id=line121></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> all_but_last[T] : avl[T]-&gt;avl[T] =
<span class="lineno" id=line122></span>      | Tree(_, _, left, #Nil) =&gt; left
<span class="lineno" id=line123></span>      | Tree(_, x, left, right) =&gt; balance(avl(x, left, all_but_last(right)))
<span class="lineno" id=line124></span>    ;
<span class="lineno" id=line125></span>  
<span class="lineno" id=line126></span>    <span class="comment">//=================================</span>
<span class="lineno" id=line127></span>  
<span class="lineno" id=line128></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> first[T] : avl[T]-&gt;T =
<span class="lineno" id=line129></span>      | Tree(_, x, #Nil, _) =&gt; x
<span class="lineno" id=line130></span>      | Tree(_, _, left, _) =&gt; first(left)
<span class="lineno" id=line131></span>    ;
<span class="lineno" id=line132></span>  
<span class="lineno" id=line133></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> all_but_first[T] : avl[T]-&gt;avl[T] =
<span class="lineno" id=line134></span>      | Tree(_, _, #Nil, right) =&gt; right
<span class="lineno" id=line135></span>      | Tree(_, x, left, right) =&gt; balance(avl(x, all_but_first(left), right))
<span class="lineno" id=line136></span>    ;
<span class="lineno" id=line137></span>  
<span class="lineno" id=line138></span>    <span class="comment">//=================================</span>
<span class="lineno" id=line139></span>  
<span class="lineno" id=line140></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> join[T] (A : avl[T], B : avl[T]) =&gt;
<span class="lineno" id=line141></span>      <span class="small_keyword" title="match statement or expression">match</span> A <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line142></span>        | #Nil =&gt; B
<span class="lineno" id=line143></span>        | x =&gt; balance(avl(last(A), all_but_last(A), B))
<span class="lineno" id=line144></span>      <span class="small_keyword" title="end a match statement or expression">endmatch</span>
<span class="lineno" id=line145></span>    ;
<span class="lineno" id=line146></span>  
<span class="lineno" id=line147></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> remove[T] (tree : avl[T], y : T, cmp : T*T-&gt;<span class="library" title="binding of C int type">int</span>) =&gt;
<span class="lineno" id=line148></span>      <span class="small_keyword" title="match statement or expression">match</span> tree <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line149></span>        | #Nil =&gt; Nil[T]
<span class="lineno" id=line150></span>        | Tree(_, x, left, right) =&gt;
<span class="lineno" id=line151></span>          <span class="small_keyword" title="conditional">if</span> cmp(x, y) == 1 <span class="small_keyword" title="conditional">then</span>
<span class="lineno" id=line152></span>            balance(avl(x, remove(left, y, cmp), right))
<span class="lineno" id=line153></span>          <span class="small_keyword" title="conditional">elif</span> cmp(x, y) == -1 <span class="small_keyword" title="conditional">then</span>
<span class="lineno" id=line154></span>            balance(avl(x, left, remove(right, y, cmp)))
<span class="lineno" id=line155></span>          <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line156></span>            join(left, right)
<span class="lineno" id=line157></span>          <span class="small_keyword" title="conditional">endif</span>
<span class="lineno" id=line158></span>      <span class="small_keyword" title="end a match statement or expression">endmatch</span>
<span class="lineno" id=line159></span>    ;
<span class="lineno" id=line160></span>  
<span class="lineno" id=line161></span>    <span class="comment">//==============================</span>
<span class="lineno" id=line162></span>  
<span class="lineno" id=line163></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="accumulated values of data structure from left into initial value using function">fold_left</span>[T, U] (f:U-&gt;T-&gt;U) (accumulated:U) (tree:avl[T]):U =&gt;
<span class="lineno" id=line164></span>      <span class="small_keyword" title="match statement or expression">match</span> tree <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line165></span>        | #Nil =&gt; accumulated
<span class="lineno" id=line166></span>        | Tree (_, x, left, right) =&gt;
<span class="lineno" id=line167></span>          <span class="library" title="accumulated values of data structure from left into initial value using function">fold_left</span> f  (f (<span class="library" title="accumulated values of data structure from left into initial value using function">fold_left</span> f accumulated left)  x) right
<span class="lineno" id=line168></span>      <span class="small_keyword" title="end a match statement or expression">endmatch</span>
<span class="lineno" id=line169></span>    ;
<span class="lineno" id=line170></span>  
<span class="lineno" id=line171></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="accumulated values of data structure from right into initial value using function">fold_right</span>[T, U] (f:T-&gt;U-&gt;U) (tree:avl[T]) (accumulated:U) =&gt;
<span class="lineno" id=line172></span>      <span class="small_keyword" title="match statement or expression">match</span> tree <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line173></span>        | #Nil =&gt; accumulated
<span class="lineno" id=line174></span>        | Tree (_, x, left, right) =&gt;
<span class="lineno" id=line175></span>          <span class="library" title="accumulated values of data structure from right into initial value using function">fold_right</span> f left (f x (<span class="library" title="accumulated values of data structure from right into initial value using function">fold_right</span> f right accumulated))
<span class="lineno" id=line176></span>      <span class="small_keyword" title="end a match statement or expression">endmatch</span>
<span class="lineno" id=line177></span>    ;
<span class="lineno" id=line178></span>  
<span class="lineno" id=line179></span>    <span class="comment">//==============================</span>
<span class="lineno" id=line180></span>  
<span class="lineno" id=line181></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> <span class="library" title="call procedure on each element of data structure">iter</span>[T] (f:T-&gt;<span class="library" title="Type with no values, returning void indicates a procedure">void</span>, tree:avl[T])
<span class="lineno" id=line182></span>    {
<span class="lineno" id=line183></span>      <span class="small_keyword" title="match statement or expression">match</span> tree <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line184></span>        | #Nil =&gt; {}
<span class="lineno" id=line185></span>        | Tree (_, x, left, right) =&gt; {
<span class="lineno" id=line186></span>          <span class="library" title="call procedure on each element of data structure">iter</span>(f, left);
<span class="lineno" id=line187></span>          f(x);
<span class="lineno" id=line188></span>          <span class="library" title="call procedure on each element of data structure">iter</span>(f, right);
<span class="lineno" id=line189></span>        }
<span class="lineno" id=line190></span>      <span class="small_keyword" title="end a match statement or expression">endmatch</span>;
<span class="lineno" id=line191></span>    }
<span class="lineno" id=line192></span>  
<span class="lineno" id=line193></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> <span class="library" title="call procedure on each element of data structure">iter</span>[T] (f:<span class="library" title="binding of C int type">int</span>*T-&gt;<span class="library" title="Type with no values, returning void indicates a procedure">void</span>, tree:avl[T])
<span class="lineno" id=line194></span>    {
<span class="lineno" id=line195></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> aux (depth:<span class="library" title="binding of C int type">int</span>, f:<span class="library" title="binding of C int type">int</span>*T-&gt;<span class="library" title="Type with no values, returning void indicates a procedure">void</span>, tree:avl[T]) {
<span class="lineno" id=line196></span>        <span class="small_keyword" title="match statement or expression">match</span> tree <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line197></span>          | #Nil =&gt; {}
<span class="lineno" id=line198></span>          | Tree (_, x, left, right) =&gt; {
<span class="lineno" id=line199></span>            aux(depth + 1, f, left);
<span class="lineno" id=line200></span>            f(depth, x);
<span class="lineno" id=line201></span>            aux(depth + 1, f, right);
<span class="lineno" id=line202></span>          }
<span class="lineno" id=line203></span>        <span class="small_keyword" title="end a match statement or expression">endmatch</span>;
<span class="lineno" id=line204></span>      }
<span class="lineno" id=line205></span>      aux(0, f, tree);
<span class="lineno" id=line206></span>    }
<span class="lineno" id=line207></span>  }
<span class="lineno" id=line208></span>  
</pre></p></div><h1 id='Directed_Graph_h'><img src='/share/src/web/images/minus.gif' id='Directed Graph' onclick='toggle(this,"Directed_Graph_d")' alt='+'/> 3 Directed Graph</h1><div id='Directed_Graph_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/graph.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="comment">// Directed Cyclic graph</span>
<span class="lineno" id=line2></span>  
<span class="lineno" id=line3></span>  <span class="big_keyword" title="Include a Felix file">include</span> <span class="fstring">"std/datatype/dlist"</span>;
<span class="lineno" id=line4></span>  <span class="big_keyword" title="Include a Felix file">include</span> <span class="fstring">"std/datatype/partition"</span>;
<span class="lineno" id=line5></span>  
<span class="lineno" id=line6></span>  <span class="big_keyword" title="Define a type class">class</span> DiGraph[V,E <span class="small_keyword" title="type-class constraint">with</span> Str[V], Str[E]] <span class="comment">// V,E labels for graph parts</span>
<span class="lineno" id=line7></span>  {
<span class="lineno" id=line8></span>    <span class="comment">// vertices are stored in an array, so they're identified</span>
<span class="lineno" id=line9></span>    <span class="comment">// by their slot number 0 origin</span>
<span class="lineno" id=line10></span>    <span class="big_keyword" title="Define an alias for a type expression">typedef</span> digraph_t = (vertices: <span class="library" title="array with unbounded dynamically variable limit">darray</span>[vertex_t], nedges: <span class="library" title="binding of C int type">int</span>);
<span class="lineno" id=line11></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> digraph_t () =&gt; (vertices= #<span class="library" title="array with unbounded dynamically variable limit">darray</span>[vertex_t], nedges=0);
<span class="lineno" id=line12></span>  
<span class="lineno" id=line13></span>    <span class="comment">// x index implicit, the edge source</span>
<span class="lineno" id=line14></span>    <span class="comment">// y index is the edge destination</span>
<span class="lineno" id=line15></span>    <span class="big_keyword" title="Define an alias for a type expression">typedef</span> edge_t = (elabel:E, x:<span class="library" title="binding of C int type">int</span>,y:<span class="library" title="binding of C int type">int</span>, weight:<span class="library" title="binding of C double float type">double</span>); 
<span class="lineno" id=line16></span>    <span class="big_keyword" title="Define an alias for a type expression">typedef</span> vertex_t = (vlabel:V, outedges: <span class="library" title="functional, singly linked list">list</span>[edge_t]);
<span class="lineno" id=line17></span>  
<span class="lineno" id=line18></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="number of elements in data structure">len</span> (d:digraph_t) =&gt; d.vertices.<span class="library" title="number of elements in data structure">len</span>;
<span class="lineno" id=line19></span>   
<span class="lineno" id=line20></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> default_vlabel: 1 -&gt; V;
<span class="lineno" id=line21></span>    <span class="qualifier" title="Type of a function to be provided in type class instances">virtual</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> default_elabel: 1 -&gt; E;
<span class="lineno" id=line22></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> default_vertex () =&gt; (vlabel = #default_vlabel, outedges = Empty[edge_t]);
<span class="lineno" id=line23></span>  
<span class="lineno" id=line24></span>    <span class="comment">// Add an isolated vertex</span>
<span class="lineno" id=line25></span>    <span class="comment">// If the vertex is already in the graph,</span>
<span class="lineno" id=line26></span>    <span class="comment">// this routine just replaces the label</span>
<span class="lineno" id=line27></span>    <span class="comment">// this allows adding out of order vertices</span>
<span class="lineno" id=line28></span>    <span class="comment">// and adding vertices implicitly by adding edges</span>
<span class="lineno" id=line29></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> add_vertex (d:&amp;digraph_t, v:V, x:<span class="library" title="binding of C int type">int</span>) 
<span class="lineno" id=line30></span>    {
<span class="lineno" id=line31></span>      <span class="small_keyword" title="while loop">while</span> x &gt;= d*.vertices.<span class="library" title="number of elements in data structure">len</span>.<span class="library" title="binding of C int type">int</span> <span class="small_keyword" title="call a procedure">call</span> push_back (d*.vertices, #default_vertex); 
<span class="lineno" id=line32></span>      <span class="big_keyword" title="Define a mutable variable">var</span> pv: &amp;V = (d*.vertices,x.<span class="library" title="binding of C size_t type">size</span>).unsafe_get_ref.vlabel;
<span class="lineno" id=line33></span>      pv &lt;- v;
<span class="lineno" id=line34></span>    }
<span class="lineno" id=line35></span>  
<span class="lineno" id=line36></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> add_weighted_edge (d:&amp;digraph_t, x:<span class="library" title="binding of C int type">int</span>, y:<span class="library" title="binding of C int type">int</span>, elab:E, weight:<span class="library" title="binding of C double float type">double</span>)
<span class="lineno" id=line37></span>    {
<span class="lineno" id=line38></span>      <span class="small_keyword" title="while loop">while</span> x &gt;= d*.vertices.<span class="library" title="number of elements in data structure">len</span>.<span class="library" title="binding of C int type">int</span> <span class="small_keyword" title="call a procedure">call</span> add_vertex (d,#default_vlabel,d*.vertices.<span class="library" title="number of elements in data structure">len</span>.<span class="library" title="binding of C int type">int</span>); 
<span class="lineno" id=line39></span>      <span class="small_keyword" title="while loop">while</span> y &gt;= d*.vertices.<span class="library" title="number of elements in data structure">len</span>.<span class="library" title="binding of C int type">int</span> <span class="small_keyword" title="call a procedure">call</span> add_vertex (d,#default_vlabel,d*.vertices.<span class="library" title="number of elements in data structure">len</span>.<span class="library" title="binding of C int type">int</span>); 
<span class="lineno" id=line40></span>      <span class="big_keyword" title="Define a mutable variable">var</span> pedges : &amp;<span class="library" title="functional, singly linked list">list</span>[edge_t] = (d*.vertices,x.<span class="library" title="binding of C size_t type">size</span>).unsafe_get_ref.outedges;
<span class="lineno" id=line41></span>      pedges &lt;- (elabel=elab,x=x,y=y,weight=weight) ! *pedges;
<span class="lineno" id=line42></span>      d.nedges.pre_incr;
<span class="lineno" id=line43></span>    }
<span class="lineno" id=line44></span>  
<span class="lineno" id=line45></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> add_edge (d:&amp;digraph_t, x:<span class="library" title="binding of C int type">int</span>, y:<span class="library" title="binding of C int type">int</span>, elab:E) =&gt;
<span class="lineno" id=line46></span>      add_weighted_edge (d,x,y,elab,1.0)
<span class="lineno" id=line47></span>    ;
<span class="lineno" id=line48></span>   
<span class="lineno" id=line49></span>    <span class="comment">// add and edge and its reverse edge, distinct labels</span>
<span class="lineno" id=line50></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> add_weighted_edge_pair (d:&amp;digraph_t, x:<span class="library" title="binding of C int type">int</span>, y:<span class="library" title="binding of C int type">int</span>, felab:E, relab:E, weight:<span class="library" title="binding of C double float type">double</span>)
<span class="lineno" id=line51></span>    {
<span class="lineno" id=line52></span>      add_weighted_edge(d,x,y,felab, weight);
<span class="lineno" id=line53></span>      add_weighted_edge(d,y,x,relab, weight);
<span class="lineno" id=line54></span>    }
<span class="lineno" id=line55></span>  
<span class="lineno" id=line56></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> add_edge_pair (d:&amp;digraph_t, x:<span class="library" title="binding of C int type">int</span>, y:<span class="library" title="binding of C int type">int</span>, felab:E, relab:E) =&gt;
<span class="lineno" id=line57></span>      add_weighted_edge_pair (d,x,y,felab,relab,1.0)
<span class="lineno" id=line58></span>    ;
<span class="lineno" id=line59></span>  
<span class="lineno" id=line60></span>    <span class="comment">// add and edge and its reverse edge, same label</span>
<span class="lineno" id=line61></span>    <span class="comment">// use for undirected graph</span>
<span class="lineno" id=line62></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> add_edge_pair (d:&amp;digraph_t, x:<span class="library" title="binding of C int type">int</span>, y:<span class="library" title="binding of C int type">int</span>, elab:E)
<span class="lineno" id=line63></span>    {
<span class="lineno" id=line64></span>      add_edge(d,x,y,elab);
<span class="lineno" id=line65></span>      add_edge(d,y,x,elab);
<span class="lineno" id=line66></span>    }
<span class="lineno" id=line67></span>  
<span class="lineno" id=line68></span>   
<span class="lineno" id=line69></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> dump_digraph (d:digraph_t) : <span class="library" title="binding of C++ string type">string</span> = 
<span class="lineno" id=line70></span>    {
<span class="lineno" id=line71></span>      <span class="big_keyword" title="Define a mutable variable">var</span> out = <span class="fstring">""</span>;
<span class="lineno" id=line72></span>      reserve (&amp;out,10000);
<span class="lineno" id=line73></span>      <span class="big_keyword" title="Define a mutable variable">var</span> x = 0;
<span class="lineno" id=line74></span>      <span class="small_keyword" title="for loop">for</span> vertex <span class="small_keyword" title="membership operator, function mem">in</span> d.vertices <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line75></span>        out += x.<span class="library" title="Convert a value to a string">str</span> + <span class="fstring">" "</span> + vertex.vlabel.<span class="library" title="Convert a value to a string">str</span> + <span class="fstring">"\n"</span>;
<span class="lineno" id=line76></span>        <span class="small_keyword" title="for loop">for</span> edge <span class="small_keyword" title="membership operator, function mem">in</span> vertex.outedges <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line77></span>          out += <span class="fstring">"  "</span> + edge.x.<span class="library" title="Convert a value to a string">str</span> + <span class="fstring">"-&gt;"</span> + edge.y.<span class="library" title="Convert a value to a string">str</span> + <span class="fstring">" "</span> + 
<span class="lineno" id=line78></span>            edge.elabel.<span class="library" title="Convert a value to a string">str</span> + 
<span class="lineno" id=line79></span>            <span class="small_keyword" title="conditional">if</span> edge.weight != 1.0 <span class="small_keyword" title="conditional">then</span> <span class="fstring">" "</span>+edge.weight.<span class="library" title="Convert a value to a string">str</span> <span class="small_keyword" title="conditional">else</span> <span class="fstring">""</span> <span class="small_keyword" title="conditional">endif</span> +
<span class="lineno" id=line80></span>            <span class="fstring">"\n"</span>
<span class="lineno" id=line81></span>          ;
<span class="lineno" id=line82></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line83></span>      ++x;
<span class="lineno" id=line84></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line85></span>      <span class="small_keyword" title="return">return</span> out;
<span class="lineno" id=line86></span>    }
<span class="lineno" id=line87></span>  
<span class="lineno" id=line88></span>    variant Vstate = Undiscovered | Discovered | Processed;
<span class="lineno" id=line89></span>  
<span class="lineno" id=line90></span>    <span class="big_keyword" title="Define an alias for a type expression">typedef</span> digraph_visitor_processing_t = 
<span class="lineno" id=line91></span>    (
<span class="lineno" id=line92></span>      process_vertex_early: digraph_t -&gt; <span class="library" title="binding of C int type">int</span> -&gt; 0,
<span class="lineno" id=line93></span>      process_vertex_late: digraph_t -&gt; <span class="library" title="binding of C int type">int</span> -&gt; 0,
<span class="lineno" id=line94></span>      process_edge: digraph_t -&gt; <span class="library" title="binding of C int type">int</span> * <span class="library" title="binding of C int type">int</span> -&gt; 0
<span class="lineno" id=line95></span>    );
<span class="lineno" id=line96></span>  
<span class="lineno" id=line97></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> dflt_pve (g:digraph_t) (x:<span class="library" title="binding of C int type">int</span>) {};
<span class="lineno" id=line98></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> dflt_pvl (g:digraph_t) (x:<span class="library" title="binding of C int type">int</span>) {};
<span class="lineno" id=line99></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> dflt_pe (g:digraph_t) (x:<span class="library" title="binding of C int type">int</span>, y:<span class="library" title="binding of C int type">int</span>) {};
<span class="lineno" id=line100></span>  
<span class="lineno" id=line101></span>    <span class="comment">// default visitor does nothing</span>
<span class="lineno" id=line102></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> digraph_visitor_processing_t () =&gt; (
<span class="lineno" id=line103></span>      process_vertex_early= dflt_pve,
<span class="lineno" id=line104></span>      process_vertex_late= dflt_pvl,
<span class="lineno" id=line105></span>      process_edge= dflt_pe
<span class="lineno" id=line106></span>    );
<span class="lineno" id=line107></span>  
<span class="lineno" id=line108></span>    <span class="big_keyword" title="define an object interface">interface</span> mutable_collection_t[T] {
<span class="lineno" id=line109></span>       add: T -&gt; 0;
<span class="lineno" id=line110></span>       remove: 1 -&gt; <span class="library" title="option type: Some x or None">opt</span>[T];
<span class="lineno" id=line111></span>    }
<span class="lineno" id=line112></span>  
<span class="lineno" id=line113></span>    <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> iterator[T] (x:mutable_collection_t[T]) () : <span class="library" title="option type: Some x or None">opt</span>[T] =&gt; x.remove ();
<span class="lineno" id=line114></span>  
<span class="lineno" id=line115></span>    <span class="big_keyword" title="define an object factory">object</span> gstack_t[T] () <span class="small_keyword" title="specify what interfaces an object implements">implements</span> mutable_collection_t[T] = {
<span class="lineno" id=line116></span>      <span class="big_keyword" title="Open a module or class">open</span> DList[T];
<span class="lineno" id=line117></span>      <span class="big_keyword" title="Define a mutable variable">var</span> d = dlist_t();
<span class="lineno" id=line118></span>      <span class="qualifier" title="A function depending only on its parameters">method</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> add (x:T) =&gt; push_back (&amp;d,x);
<span class="lineno" id=line119></span>      <span class="qualifier" title="A function depending only on its parameters">method</span> <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> remove () =&gt; pop_back (&amp;d);
<span class="lineno" id=line120></span>    }
<span class="lineno" id=line121></span>  
<span class="lineno" id=line122></span>    <span class="big_keyword" title="define an object factory">object</span> gqueue_t[T] () <span class="small_keyword" title="specify what interfaces an object implements">implements</span> mutable_collection_t[T] = {
<span class="lineno" id=line123></span>      <span class="big_keyword" title="Open a module or class">open</span> DList[T];
<span class="lineno" id=line124></span>      <span class="big_keyword" title="Define a mutable variable">var</span> d = dlist_t();
<span class="lineno" id=line125></span>      <span class="qualifier" title="A function depending only on its parameters">method</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> add (x:T) =&gt; push_back (&amp;d,x);
<span class="lineno" id=line126></span>      <span class="qualifier" title="A function depending only on its parameters">method</span> <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> remove () =&gt; pop_front (&amp;d);
<span class="lineno" id=line127></span>    }
<span class="lineno" id=line128></span>  
<span class="lineno" id=line129></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> <span class="library" title="call procedure on each element of data structure">iter</span> 
<span class="lineno" id=line130></span>      (<span class="big_keyword" title="Define a mutable variable">var</span> pending:mutable_collection_t[<span class="library" title="binding of C int type">int</span>]) 
<span class="lineno" id=line131></span>      (d:digraph_t) (startv:<span class="library" title="binding of C int type">int</span>) 
<span class="lineno" id=line132></span>      (p:digraph_visitor_processing_t)
<span class="lineno" id=line133></span>    {
<span class="lineno" id=line134></span>      <span class="big_keyword" title="Define a mutable variable">var</span> state = <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[Vstate] (bound=d.<span class="library" title="number of elements in data structure">len</span>,default=Undiscovered);
<span class="lineno" id=line135></span>      pending.add startv;
<span class="lineno" id=line136></span>      set (state,startv,Discovered);
<span class="lineno" id=line137></span>      <span class="comment">//var parent = -1;</span>
<span class="lineno" id=line138></span>      <span class="small_keyword" title="for loop">for</span> v <span class="small_keyword" title="membership operator, function mem">in</span> pending <span class="small_keyword" title="imperative code begins">do</span> <span class="comment">// all vertex indices in queue</span>
<span class="lineno" id=line139></span>        p.process_vertex_early d v;
<span class="lineno" id=line140></span>        set (state,v,Processed);
<span class="lineno" id=line141></span>        <span class="small_keyword" title="for loop">for</span> edge <span class="small_keyword" title="membership operator, function mem">in</span> d.vertices.v.outedges <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line142></span>          <span class="big_keyword" title="Define a mutable variable">var</span> y = edge.y;
<span class="lineno" id=line143></span>          p.process_edge d (v, y);
<span class="lineno" id=line144></span>          <span class="small_keyword" title="match statement or expression">match</span> state.y <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line145></span>          | #Undiscovered =&gt; 
<span class="lineno" id=line146></span>            pending.add y; 
<span class="lineno" id=line147></span>            set (state,y,Discovered); 
<span class="lineno" id=line148></span>            <span class="comment">//parent = v;</span>
<span class="lineno" id=line149></span>          | _ =&gt; ;
<span class="lineno" id=line150></span>          <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line151></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line152></span>        p.process_vertex_late d v;
<span class="lineno" id=line153></span>      <span class="small_keyword" title="end of body">done</span> <span class="comment">// vertices</span>
<span class="lineno" id=line154></span>    }
<span class="lineno" id=line155></span>  
<span class="lineno" id=line156></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> breadth_first_iter (d:digraph_t) (startv:<span class="library" title="binding of C int type">int</span>) (p:digraph_visitor_processing_t) =&gt;
<span class="lineno" id=line157></span>      <span class="library" title="call procedure on each element of data structure">iter</span> #gqueue_t[<span class="library" title="binding of C int type">int</span>] d startv p
<span class="lineno" id=line158></span>    ;
<span class="lineno" id=line159></span>  
<span class="lineno" id=line160></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> depth_first_iter (d:digraph_t) (startv:<span class="library" title="binding of C int type">int</span>) (p:digraph_visitor_processing_t) =&gt;
<span class="lineno" id=line161></span>      <span class="library" title="call procedure on each element of data structure">iter</span> #gstack_t[<span class="library" title="binding of C int type">int</span>] d startv p
<span class="lineno" id=line162></span>    ;
<span class="lineno" id=line163></span>  
<span class="lineno" id=line164></span>    <span class="comment">// This routine returns a list of vertices from startv to fin, inclusive ..</span>
<span class="lineno" id=line165></span>    <span class="comment">// not a list of edges.</span>
<span class="lineno" id=line166></span>    <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> find_shortest_unweighted_path (d:digraph_t) (startv:<span class="library" title="binding of C int type">int</span>, fin:<span class="library" title="binding of C int type">int</span>) : <span class="library" title="option type: Some x or None">opt</span>[<span class="library" title="functional, singly linked list">list</span>[<span class="library" title="binding of C int type">int</span>]] = 
<span class="lineno" id=line167></span>    {
<span class="lineno" id=line168></span>      <span class="small_keyword" title="conditional">if</span> startv == fin <span class="small_keyword" title="return">return</span> Some (<span class="library" title="functional, singly linked list">list</span>(startv));
<span class="lineno" id=line169></span>  
<span class="lineno" id=line170></span>      <span class="big_keyword" title="Open a module or class">open</span> DList[<span class="library" title="binding of C int type">int</span>];
<span class="lineno" id=line171></span>      <span class="big_keyword" title="Define a mutable variable">var</span> state = <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[Vstate] (bound=d.<span class="library" title="number of elements in data structure">len</span>,default=Undiscovered);
<span class="lineno" id=line172></span>      <span class="big_keyword" title="Define a mutable variable">var</span> parents = <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[<span class="library" title="binding of C int type">int</span>] (bound=d.<span class="library" title="number of elements in data structure">len</span>,default= -1);
<span class="lineno" id=line173></span>      <span class="big_keyword" title="Define a mutable variable">var</span> q = queue_t();
<span class="lineno" id=line174></span>      enqueue &amp;q startv;
<span class="lineno" id=line175></span>      set (state,startv,Discovered);
<span class="lineno" id=line176></span>      set(parents,startv,-1);
<span class="lineno" id=line177></span>      <span class="small_keyword" title="for loop">for</span> v <span class="small_keyword" title="membership operator, function mem">in</span> &amp;q <span class="comment">// all vertex indices in queue</span>
<span class="lineno" id=line178></span>        <span class="small_keyword" title="for loop">for</span> edge <span class="small_keyword" title="membership operator, function mem">in</span> d.vertices.v.outedges <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line179></span>          <span class="big_keyword" title="Define a mutable variable">var</span> y = edge.y;
<span class="lineno" id=line180></span>          <span class="small_keyword" title="conditional">if</span> y == fin <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line181></span>            <span class="big_keyword" title="Define a mutable variable">var</span> path = Empty[<span class="library" title="binding of C int type">int</span>];
<span class="lineno" id=line182></span>            set(parents,y,v);
<span class="lineno" id=line183></span>            <span class="small_keyword" title="while loop">while</span> y != startv <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line184></span>              path = Cons (y,path);
<span class="lineno" id=line185></span>              y = parents.y;
<span class="lineno" id=line186></span>            <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line187></span>            path = Cons (y,path);
<span class="lineno" id=line188></span>            <span class="small_keyword" title="return">return</span> Some path;
<span class="lineno" id=line189></span>          <span class="small_keyword" title="conditional">else</span> 
<span class="lineno" id=line190></span>            <span class="small_keyword" title="match statement or expression">match</span> state.y <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line191></span>            | #Undiscovered =&gt; 
<span class="lineno" id=line192></span>              enqueue &amp;q y; 
<span class="lineno" id=line193></span>              set (state,y,Discovered); 
<span class="lineno" id=line194></span>              set(parents,y,v);
<span class="lineno" id=line195></span>            | _ =&gt; ;
<span class="lineno" id=line196></span>            <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line197></span>          <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line198></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line199></span>      <span class="small_keyword" title="return">return</span> None[<span class="library" title="functional, singly linked list">list</span>[<span class="library" title="binding of C int type">int</span>]];
<span class="lineno" id=line200></span>    }
<span class="lineno" id=line201></span>  
<span class="lineno" id=line202></span>    <span class="comment">// find minimum spanning tree</span>
<span class="lineno" id=line203></span>    <span class="comment">// Prim's algorithm, enhanced as in Skiena</span>
<span class="lineno" id=line204></span>    <span class="comment">// only returns list of vertices from starting point</span>
<span class="lineno" id=line205></span>    <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> prim (d:digraph_t) (startv:<span class="library" title="binding of C int type">int</span>) : <span class="library" title="functional, singly linked list">list</span>[<span class="library" title="binding of C int type">int</span> * <span class="library" title="binding of C int type">int</span>] = 
<span class="lineno" id=line206></span>    {
<span class="lineno" id=line207></span>      <span class="big_keyword" title="Define a mutable variable">var</span> INF=DINFINITY;
<span class="lineno" id=line208></span>      <span class="big_keyword" title="Define a mutable variable">var</span> intree = <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[bool] (bound=d.<span class="library" title="number of elements in data structure">len</span>, default=<span class="library" title="false value">false</span>);
<span class="lineno" id=line209></span>      <span class="big_keyword" title="Define a mutable variable">var</span> distance = <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[<span class="library" title="binding of C double float type">double</span>] (bound=d.<span class="library" title="number of elements in data structure">len</span>, default=INF);
<span class="lineno" id=line210></span>      <span class="big_keyword" title="Define a mutable variable">var</span> fromv = <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[<span class="library" title="binding of C int type">int</span>] (bound=d.<span class="library" title="number of elements in data structure">len</span>, default= -1);
<span class="lineno" id=line211></span>      <span class="big_keyword" title="Define a mutable variable">var</span> span = Empty[<span class="library" title="binding of C int type">int</span> * <span class="library" title="binding of C int type">int</span>];
<span class="lineno" id=line212></span>      <span class="big_keyword" title="Define a mutable variable">var</span> src = -1;
<span class="lineno" id=line213></span>      <span class="big_keyword" title="Define a mutable variable">var</span> v = startv;
<span class="lineno" id=line214></span>      <span class="small_keyword" title="while loop">while</span> <span class="small_keyword" title="logical negation">not</span> intree.v <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line215></span>        set(intree,v,<span class="library" title="truth value">true</span>);
<span class="lineno" id=line216></span>        <span class="small_keyword" title="for loop">for</span> edge <span class="small_keyword" title="membership operator, function mem">in</span> d.vertices.v.outedges <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line217></span>          <span class="big_keyword" title="Define a mutable variable">var</span> w = edge.y;
<span class="lineno" id=line218></span>          <span class="big_keyword" title="Define a mutable variable">var</span> weight = edge.weight;
<span class="lineno" id=line219></span>          <span class="small_keyword" title="conditional">if</span> distance.w &gt; weight <span class="small_keyword" title="logical conjunction">and</span> <span class="small_keyword" title="logical negation">not</span> intree.w <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line220></span>            set(distance,w,weight);
<span class="lineno" id=line221></span>            set(fromv,w,v);
<span class="lineno" id=line222></span>          <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line223></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line224></span>  
<span class="lineno" id=line225></span>        <span class="comment">// find closest out of tree vertex</span>
<span class="lineno" id=line226></span>        <span class="big_keyword" title="Define a mutable variable">var</span> dist = INF;
<span class="lineno" id=line227></span>        src = -1;
<span class="lineno" id=line228></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i <span class="small_keyword" title="membership operator, function mem">in</span> 0 <span class="small_keyword" title="upwards counting for loop">upto</span> intree.<span class="library" title="number of elements in data structure">len</span>.<span class="library" title="binding of C int type">int</span> - 1 <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line229></span>          <span class="small_keyword" title="conditional">if</span> <span class="small_keyword" title="logical negation">not</span> intree.i <span class="small_keyword" title="logical conjunction">and</span> dist &gt; distance.i <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line230></span>            dist = distance.i;
<span class="lineno" id=line231></span>            v = i;
<span class="lineno" id=line232></span>            src = fromv.i;
<span class="lineno" id=line233></span>          <span class="small_keyword" title="end of body">done</span> <span class="comment">// not in tree</span>
<span class="lineno" id=line234></span>        <span class="small_keyword" title="end of body">done</span> <span class="comment">// each vertex i</span>
<span class="lineno" id=line235></span>        <span class="comment">// v is set to closest out of tree vertex and </span>
<span class="lineno" id=line236></span>        <span class="comment">// src to the vertex it comes from</span>
<span class="lineno" id=line237></span>        <span class="comment">// if there is one, otherwise v is unchanged and so remains in tree</span>
<span class="lineno" id=line238></span>        <span class="comment">// and src stays at -1</span>
<span class="lineno" id=line239></span>        <span class="small_keyword" title="conditional">if</span> src != -1 <span class="small_keyword" title="imperative code begins">do</span> span = Cons ( (src,v), span); <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line240></span>      <span class="small_keyword" title="end of body">done</span> <span class="comment">// each v not in tree</span>
<span class="lineno" id=line241></span>      <span class="small_keyword" title="return">return</span> <span class="library" title="return data structure with elements reversed">rev</span> span;
<span class="lineno" id=line242></span>    }
<span class="lineno" id=line243></span>  
<span class="lineno" id=line244></span>  }
<span class="lineno" id=line245></span>  
<span class="lineno" id=line246></span>  <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> DiGraph[<span class="library" title="binding of C++ string type">string</span>, <span class="library" title="binding of C++ string type">string</span>] 
<span class="lineno" id=line247></span>  {
<span class="lineno" id=line248></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> default_vlabel () =&gt; <span class="fstring">"Unlabelled Vertex"</span>;
<span class="lineno" id=line249></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> default_elabel () =&gt; <span class="fstring">"Unlabelled Edge"</span>;
<span class="lineno" id=line250></span>  }
<span class="lineno" id=line251></span>  
<span class="lineno" id=line252></span>  
<span class="lineno" id=line253></span>  
</pre></p></div><h1 id='Partition_with_Union-Find_h'><img src='/share/src/web/images/minus.gif' id='Partition with Union-Find' onclick='toggle(this,"Partition_with_Union-Find_d")' alt='+'/> 4 Partition with Union-Find</h1><div id='Partition_with_Union-Find_d' style='display:block'>
<p>Partition range of integers 0 through n-1.
Features classic union-find data structure.
</p><pre class='inclusion'>
share/lib/std/datatype/partition.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Define a type class">class</span> Partition
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>    <span class="comment">// internal array based union find </span>
<span class="lineno" id=line4></span>    <span class="big_keyword" title="Define an alias for a type expression">typedef</span> partition_t = (
<span class="lineno" id=line5></span>      parents: <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[<span class="library" title="binding of C int type">int</span>],
<span class="lineno" id=line6></span>      sizes : <span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[<span class="library" title="binding of C int type">int</span>],
<span class="lineno" id=line7></span>      n: <span class="library" title="binding of C int type">int</span>
<span class="lineno" id=line8></span>    );
<span class="lineno" id=line9></span>  
<span class="lineno" id=line10></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> partition_t (nelts:<span class="library" title="binding of C int type">int</span>) =&gt; (
<span class="lineno" id=line11></span>      n=nelts, 
<span class="lineno" id=line12></span>      parents=<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[<span class="library" title="binding of C int type">int</span>] (bound=nelts.<span class="library" title="binding of C size_t type">size</span>,used=nelts.<span class="library" title="binding of C size_t type">size</span>,f=(<span class="big_keyword" title="Define a function with no side-effects">fun</span> (i:<span class="library" title="binding of C size_t type">size</span>)=&gt;i.<span class="library" title="binding of C int type">int</span>)),
<span class="lineno" id=line13></span>      sizes=<span class="library" title="array with dynamically variable limit up to a fixed bound">varray</span>[<span class="library" title="binding of C int type">int</span>] (bound=nelts.<span class="library" title="binding of C size_t type">size</span>,default=1)
<span class="lineno" id=line14></span>    );
<span class="lineno" id=line15></span>  
<span class="lineno" id=line16></span>    <span class="comment">// find canonical representative of partition containing element</span>
<span class="lineno" id=line17></span>    <span class="comment">// can't fail, returns -1 if the input i is out of range of the partition</span>
<span class="lineno" id=line18></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> find (s:&amp;partition_t, i:<span class="library" title="binding of C int type">int</span>) =&gt; 
<span class="lineno" id=line19></span>      <span class="small_keyword" title="conditional">if</span> i &lt; 0 <span class="small_keyword" title="logical disjunction">or</span> i&gt;= s*.n <span class="small_keyword" title="conditional">then</span> -1 <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line20></span>        <span class="small_keyword" title="let binder">let</span> <span class="big_keyword" title="Define an immutable value">val</span> p = s*.parents.i <span class="small_keyword" title="membership operator, function mem">in</span> 
<span class="lineno" id=line21></span>        <span class="small_keyword" title="conditional">if</span> p == i <span class="small_keyword" title="conditional">then</span> i 
<span class="lineno" id=line22></span>        <span class="small_keyword" title="conditional">else</span> find (s,p) 
<span class="lineno" id=line23></span>        <span class="small_keyword" title="conditional">endif</span>
<span class="lineno" id=line24></span>      <span class="small_keyword" title="conditional">endif</span>
<span class="lineno" id=line25></span>    ;
<span class="lineno" id=line26></span>  
<span class="lineno" id=line27></span>    <span class="comment">// merge classes , keeping tree balanced</span>
<span class="lineno" id=line28></span>    <span class="comment">// can't fail, does nothing if either s1 or s2 is out of range of the partition</span>
<span class="lineno" id=line29></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> merge (s: &amp;partition_t, s1:<span class="library" title="binding of C int type">int</span>, s2:<span class="library" title="binding of C int type">int</span>) {
<span class="lineno" id=line30></span>      <span class="big_keyword" title="Define a mutable variable">var</span> r1 = find (s,s1);
<span class="lineno" id=line31></span>      <span class="small_keyword" title="conditional">if</span> r1 == -1 <span class="small_keyword" title="return">return</span>;
<span class="lineno" id=line32></span>      <span class="big_keyword" title="Define a mutable variable">var</span> r2 = find (s,s2);
<span class="lineno" id=line33></span>      <span class="small_keyword" title="conditional">if</span> r2 == -1 <span class="small_keyword" title="return">return</span>;
<span class="lineno" id=line34></span>      <span class="small_keyword" title="conditional">if</span> r1 != r2 <span class="small_keyword" title="imperative code begins">do</span> 
<span class="lineno" id=line35></span>        <span class="big_keyword" title="Define a mutable variable">var</span> m = s*.sizes.r1 + s*.sizes.r2;
<span class="lineno" id=line36></span>        <span class="small_keyword" title="conditional">if</span> s*.sizes.r1 &gt;= s*.sizes.r2 <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line37></span>          set (s*.sizes,r1,m);
<span class="lineno" id=line38></span>          set (s*.parents,r2,r1);
<span class="lineno" id=line39></span>        <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line40></span>          set (s*.sizes,r2,m);
<span class="lineno" id=line41></span>          set (s*.parents,r1,r2);
<span class="lineno" id=line42></span>        <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line43></span>      <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line44></span>    }
<span class="lineno" id=line45></span>  
<span class="lineno" id=line46></span>    <span class="comment">// partition 0:n-1 with equivalence relation</span>
<span class="lineno" id=line47></span>    <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> partition (n:<span class="library" title="binding of C int type">int</span>, equiv:<span class="library" title="binding of C int type">int</span> * <span class="library" title="binding of C int type">int</span> -&gt; bool) =
<span class="lineno" id=line48></span>    {
<span class="lineno" id=line49></span>      <span class="big_keyword" title="Define a mutable variable">var</span> p = partition_t n;
<span class="lineno" id=line50></span>      <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> i <span class="small_keyword" title="membership operator, function mem">in</span> 0 <span class="small_keyword" title="upwards counting for loop">upto</span>  n - 1 
<span class="lineno" id=line51></span>        <span class="small_keyword" title="for loop">for</span> <span class="big_keyword" title="Define a mutable variable">var</span> j <span class="small_keyword" title="membership operator, function mem">in</span> i + 1 <span class="small_keyword" title="upwards counting for loop">upto</span> n - 1 
<span class="lineno" id=line52></span>          <span class="small_keyword" title="conditional">if</span> equiv (i,j) <span class="small_keyword" title="call a procedure">call</span> merge (&amp;p,i,j)
<span class="lineno" id=line53></span>      ;
<span class="lineno" id=line54></span>      <span class="small_keyword" title="return">return</span> p;
<span class="lineno" id=line55></span>    } 
<span class="lineno" id=line56></span>  
<span class="lineno" id=line57></span>    <span class="comment">// return an equivalence relation from a partition</span>
<span class="lineno" id=line58></span>    <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> equiv (s:&amp;partition_t) : <span class="library" title="binding of C int type">int</span> * <span class="library" title="binding of C int type">int</span> -&gt; bool =&gt; 
<span class="lineno" id=line59></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> (x:<span class="library" title="binding of C int type">int</span>, y:<span class="library" title="binding of C int type">int</span>) =&gt; find (s,x) == find (s,y)
<span class="lineno" id=line60></span>    ;
<span class="lineno" id=line61></span>  
<span class="lineno" id=line62></span>    <span class="comment">// create a partition from an equivalence relation</span>
<span class="lineno" id=line63></span>    <span class="comment">// constructor syntax </span>
<span class="lineno" id=line64></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> partition_t (n:<span class="library" title="binding of C int type">int</span>, equiv: <span class="library" title="binding of C int type">int</span> * <span class="library" title="binding of C int type">int</span> -&gt; bool) =&gt; partition (n,equiv);
<span class="lineno" id=line65></span>  
<span class="lineno" id=line66></span>    <span class="comment">// create an equivalence relation from a property</span>
<span class="lineno" id=line67></span>    <span class="comment">// assuming the property return type has equality</span>
<span class="lineno" id=line68></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> mk_equiv[T <span class="small_keyword" title="type-class constraint">with</span> Eq[T]] (f:<span class="library" title="binding of C int type">int</span> -&gt; T) =&gt; 
<span class="lineno" id=line69></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> (x:<span class="library" title="binding of C int type">int</span>, y:<span class="library" title="binding of C int type">int</span>) =&gt; f x == f y
<span class="lineno" id=line70></span>    ;  
<span class="lineno" id=line71></span>  }
<span class="lineno" id=line72></span>  
</pre></p></div><h1 id='Binary_Search_Tree_h'><img src='/share/src/web/images/minus.gif' id='Binary Search Tree' onclick='toggle(this,"Binary_Search_Tree_d")' alt='+'/> 5 Binary Search Tree</h1><div id='Binary_Search_Tree_d' style='display:block'>
</div><h1 id='Description._h'><img src='/share/src/web/images/minus.gif' id='Description.' onclick='toggle(this,"Description._d")' alt='+'/> 6 Description.</h1><div id='Description._d' style='display:block'>
<p>A mutable binary tree with a label and parent uplink
satisfying the property that for any node, all elements
in the left subtree are less than the node label,
and all elements in the right subtree are greater than
or equal to the node label.
</p><h2 id='Implementation._h'><img src='/share/src/web/images/minus.gif' id='Implementation.' onclick='toggle(this,"Implementation._d")' alt='+'/> 6.1 Implementation.</h2><div id='Implementation._d' style='display:block'>
<p>This version requires and uses the default total order
on the label.
</p><pre class='inclusion'>
share/lib/std/datatype/binary_search_tree.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Define a type class">class</span> BinarySearchTree[T <span class="small_keyword" title="type-class constraint">with</span> Tord[T]]
<span class="lineno" id=line2></span>  {
</pre></p></div><h2 id='Type._h'><img src='/share/src/web/images/minus.gif' id='Type.' onclick='toggle(this,"Type._d")' alt='+'/> 6.2 Type.</h2><div id='Type._d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/binary_search_tree.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="big_keyword" title="Define an alias for a type expression">typedef</span> bstree_node_t =
<span class="lineno" id=line2></span>      (
<span class="lineno" id=line3></span>        elt: T,
<span class="lineno" id=line4></span>        parent:bstree_t, 
<span class="lineno" id=line5></span>        left:bstree_t, 
<span class="lineno" id=line6></span>        right:bstree_t
<span class="lineno" id=line7></span>      )
<span class="lineno" id=line8></span>    ;
<span class="lineno" id=line9></span>    variant bstree_t = 
<span class="lineno" id=line10></span>      | #Empty 
<span class="lineno" id=line11></span>      | Node of &amp;bstree_node_t 
<span class="lineno" id=line12></span>    ;
<span class="lineno" id=line13></span>  
</pre></p></div><h2 id='Quick_Checks._h'><img src='/share/src/web/images/minus.gif' id='Quick Checks.' onclick='toggle(this,"Quick_Checks._d")' alt='+'/> 6.3 Quick Checks.</h2><div id='Quick_Checks._d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/binary_search_tree.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> leaf: bstree_t -&gt; bool =
<span class="lineno" id=line3></span>      | #Empty =&gt; <span class="library" title="false value">false</span>
<span class="lineno" id=line4></span>      | Node p =&gt; 
<span class="lineno" id=line5></span>        <span class="small_keyword" title="match statement or expression">match</span> p*.left, p*.right <span class="small_keyword" title="type-class constraint">with</span> 
<span class="lineno" id=line6></span>        | #Empty, Empty =&gt; <span class="library" title="truth value">true</span> 
<span class="lineno" id=line7></span>        | _ =&gt; <span class="library" title="false value">false</span>
<span class="lineno" id=line8></span>    ;
<span class="lineno" id=line9></span>  
<span class="lineno" id=line10></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> leaf_or_empty : bstree_t -&gt; bool =
<span class="lineno" id=line11></span>      | #Empty =&gt; <span class="library" title="truth value">true</span>
<span class="lineno" id=line12></span>      | x =&gt; leaf x
<span class="lineno" id=line13></span>    ;
<span class="lineno" id=line14></span>  
</pre></p></div><h2 id='String_representation_h'><img src='/share/src/web/images/minus.gif' id='String representation' onclick='toggle(this,"String_representation_d")' alt='+'/> 6.4 String representation</h2><div id='String_representation_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/binary_search_tree.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> Str[bstree_t] {
<span class="lineno" id=line2></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="Convert a value to a string">str</span> : bstree_t -&gt; <span class="library" title="binding of C++ string type">string</span> =
<span class="lineno" id=line3></span>        | #Empty =&gt; <span class="fstring">"()"</span>
<span class="lineno" id=line4></span>        | Node p =&gt;
<span class="lineno" id=line5></span>          p*.elt.<span class="library" title="Convert a value to a string">str</span> + <span class="fstring">"("</span> + p*.left.<span class="library" title="Convert a value to a string">str</span> + <span class="fstring">") ("</span> + p*.right.<span class="library" title="Convert a value to a string">str</span> + <span class="fstring">")"</span>
<span class="lineno" id=line6></span>      ;
<span class="lineno" id=line7></span>    }
<span class="lineno" id=line8></span>  
</pre></p></div><h2 id='Find._h'><img src='/share/src/web/images/minus.gif' id='Find.' onclick='toggle(this,"Find._d")' alt='+'/> 6.5 Find.</h2><div id='Find._d' style='display:block'>
<p>Find the subtree with top node equal to the given
value, or Empty if not found.
</p><pre class='inclusion'>
share/lib/std/datatype/binary_search_tree.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="comment">// Skiena p78</span>
<span class="lineno" id=line2></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> find (tree:bstree_t) (elt:T) : bstree_t =&gt;
<span class="lineno" id=line3></span>      <span class="comment">// saves passing invariant elt</span>
<span class="lineno" id=line4></span>      <span class="small_keyword" title="let binder">let</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> aux (tree:bstree_t) : bstree_t =&gt;
<span class="lineno" id=line5></span>        <span class="small_keyword" title="match statement or expression">match</span> tree <span class="small_keyword" title="type-class constraint">with</span> 
<span class="lineno" id=line6></span>        | #Empty =&gt; tree
<span class="lineno" id=line7></span>        | Node p =&gt; 
<span class="lineno" id=line8></span>           <span class="small_keyword" title="conditional">if</span> p*.elt == elt <span class="small_keyword" title="conditional">then</span> tree
<span class="lineno" id=line9></span>           <span class="small_keyword" title="conditional">elif</span> elt &lt; p*.elt <span class="small_keyword" title="conditional">then</span> aux p*.left
<span class="lineno" id=line10></span>           <span class="small_keyword" title="conditional">else</span> aux p*.right
<span class="lineno" id=line11></span>        <span class="small_keyword" title="end a match statement or expression">endmatch</span>
<span class="lineno" id=line12></span>      <span class="small_keyword" title="membership operator, function mem">in</span> aux tree
<span class="lineno" id=line13></span>    ;
<span class="lineno" id=line14></span>  
</pre></p></div><h2 id='min._h'><img src='/share/src/web/images/minus.gif' id='min.' onclick='toggle(this,"min._d")' alt='+'/> 6.6 min.</h2><div id='min._d' style='display:block'>
<p>Find the minimum subtree in the tree which is the left
most bottom leaf.
</p><pre class='inclusion'>
share/lib/std/datatype/binary_search_tree.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> min (x:bstree_t) =&gt;
<span class="lineno" id=line2></span>      <span class="small_keyword" title="match statement or expression">match</span> x <span class="small_keyword" title="type-class constraint">with</span> 
<span class="lineno" id=line3></span>      | #Empty =&gt; x
<span class="lineno" id=line4></span>      | Node p =&gt;
<span class="lineno" id=line5></span>        <span class="small_keyword" title="let binder">let</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> aux (p:&amp;bstree_node_t) =&gt;
<span class="lineno" id=line6></span>          <span class="small_keyword" title="match statement or expression">match</span> *p.left <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line7></span>          | #Empty =&gt; Node p 
<span class="lineno" id=line8></span>          | Node p =&gt; aux p
<span class="lineno" id=line9></span>        <span class="small_keyword" title="membership operator, function mem">in</span> aux p
<span class="lineno" id=line10></span>     ; 
</pre></p></div><h2 id='iter._h'><img src='/share/src/web/images/minus.gif' id='iter.' onclick='toggle(this,"iter._d")' alt='+'/> 6.7 iter.</h2><div id='iter._d' style='display:block'>
<p>Procedural preorder iteration visits values
in ascending order.
</p><pre class='inclusion'>
share/lib/std/datatype/binary_search_tree.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>     <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> <span class="library" title="call procedure on each element of data structure">iter</span> (f: T -&gt; 0) (x:bstree_t) =
<span class="lineno" id=line2></span>     {
<span class="lineno" id=line3></span>        <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> aux (x:bstree_t) = {
<span class="lineno" id=line4></span>          <span class="small_keyword" title="match statement or expression">match</span> x <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line5></span>          | #Empty =&gt; ;
<span class="lineno" id=line6></span>          | Node p =&gt;
<span class="lineno" id=line7></span>            aux p*.left;
<span class="lineno" id=line8></span>            f p*.elt;
<span class="lineno" id=line9></span>            aux p*.right;
<span class="lineno" id=line10></span>          <span class="small_keyword" title="end a match statement or expression">endmatch</span>;
<span class="lineno" id=line11></span>        }
<span class="lineno" id=line12></span>       aux x;
<span class="lineno" id=line13></span>     }
<span class="lineno" id=line14></span>  
</pre></p></div><h2 id='Fold._h'><img src='/share/src/web/images/minus.gif' id='Fold.' onclick='toggle(this,"Fold._d")' alt='+'/> 6.8 Fold.</h2><div id='Fold._d' style='display:block'>
<p>Easily defined given iter, this should be generalised elsewhere!
</p><pre class='inclusion'>
share/lib/std/datatype/binary_search_tree.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="accumulated values of data structure from left into initial value using function">fold_left</span>[U] (_f:U-&gt;T-&gt;U) (init:U) (x:bstree_t): U = {
<span class="lineno" id=line2></span>      <span class="big_keyword" title="Define a mutable variable">var</span> sum = init;
<span class="lineno" id=line3></span>      <span class="library" title="call procedure on each element of data structure">iter</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> (elt:T) { sum = _f sum elt; } x;
<span class="lineno" id=line4></span>      <span class="small_keyword" title="return">return</span> sum;
<span class="lineno" id=line5></span>    }
<span class="lineno" id=line6></span>  
</pre></p></div><h2 id='Map._h'><img src='/share/src/web/images/minus.gif' id='Map.' onclick='toggle(this,"Map._d")' alt='+'/> 6.9 Map.</h2><div id='Map._d' style='display:block'>
<p>Easily defined given iter. Note the tree structure is NOT preserved.
</p><pre class='inclusion'>
share/lib/std/datatype/binary_search_tree.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="return data structure with function applied to each value">map</span>[U] (_f:T-&gt;U) (x:bstree_t): BinarySearchTree[U]::bstree_t = {
<span class="lineno" id=line2></span>      <span class="big_keyword" title="Define a mutable variable">var</span> res = BinarySearchTree::Empty[U];
<span class="lineno" id=line3></span>      <span class="library" title="call procedure on each element of data structure">iter</span> <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> (elt:T) { BinarySearchTree[U]::insert &amp;res elt._f; } x;
<span class="lineno" id=line4></span>      <span class="small_keyword" title="return">return</span> res;
<span class="lineno" id=line5></span>    }
<span class="lineno" id=line6></span>  
</pre></p></div><h2 id='Constructors._h'><img src='/share/src/web/images/minus.gif' id='Constructors.' onclick='toggle(this,"Constructors._d")' alt='+'/> 6.10 Constructors.</h2><div id='Constructors._d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/binary_search_tree.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> bstree_t () =&gt; Empty;
<span class="lineno" id=line2></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> bstree_node_t (x:T) =&gt; (parent=Empty,elt=x,left=Empty,right=Empty);
<span class="lineno" id=line3></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> bstree_node_t (x:T, p:bstree_t) =&gt; (parent=p,elt=x,left=Empty,right=Empty);
<span class="lineno" id=line4></span>  
<span class="lineno" id=line5></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> bstree_t (x:T) =&gt; Node (new (bstree_node_t x));
<span class="lineno" id=line6></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> bstree_t (x:T, p:bstree_t) =&gt; Node (new (bstree_node_t (x,p)));
<span class="lineno" id=line7></span>  
</pre></p></div><h2 id='Insert_routine_h'><img src='/share/src/web/images/minus.gif' id='Insert routine' onclick='toggle(this,"Insert_routine_d")' alt='+'/> 6.11 Insert routine</h2><div id='Insert_routine_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/binary_search_tree.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="comment">// Note: this routine disallows duplicates.</span>
<span class="lineno" id=line2></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> insert_with_parent (p:&amp;bstree_t) (parent:bstree_t) (elt:T)
<span class="lineno" id=line3></span>    {
<span class="lineno" id=line4></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> aux (p:&amp;bstree_t) (parent:bstree_t) {
<span class="lineno" id=line5></span>        <span class="small_keyword" title="match statement or expression">match</span> *p <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line6></span>        | #Empty =&gt; p &lt;- bstree_t (elt,parent);
<span class="lineno" id=line7></span>        | Node q =&gt;
<span class="lineno" id=line8></span>          <span class="small_keyword" title="conditional">if</span> elt &lt; q*.elt <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line9></span>            aux q.left (*p);
<span class="lineno" id=line10></span>          <span class="small_keyword" title="conditional">elif</span> elt &gt; q*.elt <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line11></span>            aux q.right (*p);
<span class="lineno" id=line12></span>          <span class="small_keyword" title="end of body">done</span> <span class="comment">//otherwise it's already in there</span>
<span class="lineno" id=line13></span>        <span class="small_keyword" title="end a match statement or expression">endmatch</span>;
<span class="lineno" id=line14></span>      }
<span class="lineno" id=line15></span>      aux p parent;
<span class="lineno" id=line16></span>    }
<span class="lineno" id=line17></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> insert (p:&amp;bstree_t) (elt:T) =&gt; insert_with_parent p Empty elt;
<span class="lineno" id=line18></span>  
</pre></p></div><h2 id='Comprehension._h'><img src='/share/src/web/images/minus.gif' id='Comprehension.' onclick='toggle(this,"Comprehension._d")' alt='+'/> 6.12 Comprehension.</h2><div id='Comprehension._d' style='display:block'>
<p>Make a tree from an option stream.
</p><pre class='inclusion'>
share/lib/std/datatype/binary_search_tree.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> bstree_t  (f:1-&gt;<span class="library" title="option type: Some x or None">opt</span>[T]) = {
<span class="lineno" id=line2></span>      <span class="big_keyword" title="Define a mutable variable">var</span> x = Empty;
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Define a mutable variable">var</span> ff = f;
<span class="lineno" id=line4></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> aux () {
<span class="lineno" id=line5></span>        <span class="small_keyword" title="match statement or expression">match</span> #ff <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line6></span>        | Some y =&gt; insert &amp;x y; aux();
<span class="lineno" id=line7></span>        | #None =&gt; ;
<span class="lineno" id=line8></span>        <span class="small_keyword" title="end a match statement or expression">endmatch</span>;
<span class="lineno" id=line9></span>      }
<span class="lineno" id=line10></span>      aux();
<span class="lineno" id=line11></span>      <span class="small_keyword" title="return">return</span> x;
<span class="lineno" id=line12></span>    }
<span class="lineno" id=line13></span>  
</pre></p></div><h2 id='Iterator._h'><img src='/share/src/web/images/minus.gif' id='Iterator.' onclick='toggle(this,"Iterator._d")' alt='+'/> 6.13 Iterator.</h2><div id='Iterator._d' style='display:block'>
<p>Ab interesting routine, related to <code>iter</code>.
</p><pre class='inclusion'>
share/lib/std/datatype/binary_search_tree.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> iterator (x:bstree_t) () : <span class="library" title="option type: Some x or None">opt</span>[T] =
<span class="lineno" id=line2></span>    {
<span class="lineno" id=line3></span>      <span class="small_keyword" title="match statement or expression">match</span> x <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line4></span>      | #Empty =&gt; <span class="small_keyword" title="return">return</span> None[T];
<span class="lineno" id=line5></span>      | Node p =&gt;
<span class="lineno" id=line6></span>        <span class="big_keyword" title="Define a mutable variable">var</span> ff = iterator p*.left; <span class="comment">// closure for generator</span>
<span class="lineno" id=line7></span>      left:&gt;
<span class="lineno" id=line8></span>        <span class="big_keyword" title="Define a mutable variable">var</span> elt_opt = #ff;
<span class="lineno" id=line9></span>        <span class="small_keyword" title="match statement or expression">match</span> elt_opt <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line10></span>        | #None =&gt; ;
<span class="lineno" id=line11></span>        | Some v =&gt; 
<span class="lineno" id=line12></span>          <span class="small_keyword" title="return a value saving the current location for future resumption">yield</span> elt_opt;
<span class="lineno" id=line13></span>          <span class="small_keyword" title="jump to label">goto</span> left;
<span class="lineno" id=line14></span>        <span class="small_keyword" title="end a match statement or expression">endmatch</span>;
<span class="lineno" id=line15></span>  
<span class="lineno" id=line16></span>        <span class="small_keyword" title="return a value saving the current location for future resumption">yield</span> Some (p*.elt);
<span class="lineno" id=line17></span>  
<span class="lineno" id=line18></span>        ff = iterator p*.right;
<span class="lineno" id=line19></span>      right:&gt;
<span class="lineno" id=line20></span>        elt_opt = #ff;
<span class="lineno" id=line21></span>        <span class="small_keyword" title="match statement or expression">match</span> elt_opt <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line22></span>        | #None =&gt; <span class="small_keyword" title="return">return</span> None[T];
<span class="lineno" id=line23></span>        | Some _ =&gt; 
<span class="lineno" id=line24></span>          <span class="small_keyword" title="return a value saving the current location for future resumption">yield</span> elt_opt;
<span class="lineno" id=line25></span>          <span class="small_keyword" title="jump to label">goto</span> right;
<span class="lineno" id=line26></span>        <span class="small_keyword" title="end a match statement or expression">endmatch</span>;
<span class="lineno" id=line27></span>      <span class="small_keyword" title="end a match statement or expression">endmatch</span>;
<span class="lineno" id=line28></span>    }
</pre></p></div><h2 id='As_a_set._h'><img src='/share/src/web/images/minus.gif' id='As a set.' onclick='toggle(this,"As_a_set._d")' alt='+'/> 6.14 As a set.</h2><div id='As_a_set._d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/binary_search_tree.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> Set[bstree_t,T] {
<span class="lineno" id=line2></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="tex_symbol" title="\in">\(\in\)</span> (elt:T, container:bstree_t) =&gt;
<span class="lineno" id=line3></span>        <span class="small_keyword" title="match statement or expression">match</span> find container elt <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line4></span>        | #Empty =&gt; <span class="library" title="false value">false</span>
<span class="lineno" id=line5></span>        | _ =&gt; <span class="library" title="truth value">true</span>
<span class="lineno" id=line6></span>        <span class="small_keyword" title="end a match statement or expression">endmatch</span>
<span class="lineno" id=line7></span>      ;
<span class="lineno" id=line8></span>    }
<span class="lineno" id=line9></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> Set[bstree_t,T];
<span class="lineno" id=line10></span>  
</pre></p></div><h2 id='As_a_container._h'><img src='/share/src/web/images/minus.gif' id='As a container.' onclick='toggle(this,"As_a_container._d")' alt='+'/> 6.15 As a container.</h2><div id='As_a_container._d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/binary_search_tree.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> Container[bstree_t, T] {
<span class="lineno" id=line2></span>      <span class="comment">// not tail rec</span>
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="number of elements in data structure">len</span> (x:bstree_t) =&gt;
<span class="lineno" id=line4></span>        <span class="small_keyword" title="let binder">let</span> <span class="big_keyword" title="Define a function with no side-effects">fun</span> aux (x:bstree_t) (sum:<span class="library" title="binding of C size_t type">size</span>) =&gt;
<span class="lineno" id=line5></span>          <span class="small_keyword" title="match statement or expression">match</span> x <span class="small_keyword" title="type-class constraint">with</span> 
<span class="lineno" id=line6></span>          | #Empty =&gt; sum
<span class="lineno" id=line7></span>          | Node p =&gt;
<span class="lineno" id=line8></span>            aux p*.left (aux p*.right (sum+1uz)) 
<span class="lineno" id=line9></span>          <span class="small_keyword" title="end a match statement or expression">endmatch</span>
<span class="lineno" id=line10></span>        <span class="small_keyword" title="membership operator, function mem">in</span> aux x 0uz
<span class="lineno" id=line11></span>      ;
<span class="lineno" id=line12></span>  
<span class="lineno" id=line13></span>      <span class="comment">// faster than counting then comparing to 0</span>
<span class="lineno" id=line14></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> empty: bstree_t -&gt; bool =
<span class="lineno" id=line15></span>        | #Empty =&gt; <span class="library" title="truth value">true</span>
<span class="lineno" id=line16></span>        | _ =&gt; <span class="library" title="false value">false</span>
<span class="lineno" id=line17></span>      ;
<span class="lineno" id=line18></span>     
<span class="lineno" id=line19></span>    }
<span class="lineno" id=line20></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> Container[bstree_t,T];
<span class="lineno" id=line21></span>  
</pre></p></div><h2 id='Delete_by_value._h'><img src='/share/src/web/images/minus.gif' id='Delete by value.' onclick='toggle(this,"Delete_by_value._d")' alt='+'/> 6.16 Delete by value.</h2><div id='Delete_by_value._d' style='display:block'>
<p>Ensures the tree doesn't contain the specified value.
</p><pre class='inclusion'>
share/lib/std/datatype/binary_search_tree.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>    <span class="comment">// deletes the first copy of the element found</span>
<span class="lineno" id=line2></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> delete_element (p:&amp;bstree_t) (elt:T)
<span class="lineno" id=line3></span>    {
<span class="lineno" id=line4></span>      <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> aux (p:&amp;bstree_t) {
<span class="lineno" id=line5></span>        <span class="small_keyword" title="match statement or expression">match</span> *p <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line6></span>        | #Empty =&gt; ; <span class="comment">// not found, nothing to do</span>
<span class="lineno" id=line7></span>        | Node q =&gt;
<span class="lineno" id=line8></span>          <span class="small_keyword" title="conditional">if</span> elt == q*.elt <span class="small_keyword" title="imperative code begins">do</span> <span class="comment">// found it</span>
<span class="lineno" id=line9></span>            <span class="big_keyword" title="Define a mutable variable">var</span> par = q*.parent;
<span class="lineno" id=line10></span>            <span class="small_keyword" title="match statement or expression">match</span> q*.left, q*.right <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line11></span>            <span class="comment">// no kids</span>
<span class="lineno" id=line12></span>            | #Empty, Empty =&gt; p &lt;- Empty;
<span class="lineno" id=line13></span>  
<span class="lineno" id=line14></span>            <span class="comment">// right kid only</span>
<span class="lineno" id=line15></span>            | #Empty, Node child =&gt; 
<span class="lineno" id=line16></span>              p &lt;- q*.right;
<span class="lineno" id=line17></span>              child.parent &lt;-par;
<span class="lineno" id=line18></span>  
<span class="lineno" id=line19></span>            <span class="comment">// left kid only</span>
<span class="lineno" id=line20></span>            | Node (child) , Empty =&gt; 
<span class="lineno" id=line21></span>              p &lt;- q*.left;
<span class="lineno" id=line22></span>              child.parent &lt;- par;
<span class="lineno" id=line23></span>  
<span class="lineno" id=line24></span>            <span class="comment">// two kids</span>
<span class="lineno" id=line25></span>            <span class="comment">// overwrite elt with min elt of right kid</span>
<span class="lineno" id=line26></span>            <span class="comment">// then delete that elt's original node</span>
<span class="lineno" id=line27></span>            <span class="comment">// which is the leftmost descendant of the right kid</span>
<span class="lineno" id=line28></span>  
<span class="lineno" id=line29></span>            | _, Node child =&gt;
<span class="lineno" id=line30></span>              <span class="small_keyword" title="match statement or expression">match</span> min q*.right <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line31></span>              | #Empty =&gt; <span class="big_keyword" title="Run time assertion">assert</span> <span class="library" title="false value">false</span>;
<span class="lineno" id=line32></span>              | Node k =&gt; 
<span class="lineno" id=line33></span>                <span class="big_keyword" title="Define a mutable variable">var</span> m = k*.elt;
<span class="lineno" id=line34></span>                q.elt &lt;- m;
<span class="lineno" id=line35></span>                delete_element q.right m; 
<span class="lineno" id=line36></span>                  <span class="comment">// this looks nasty and is poor syle but</span>
<span class="lineno" id=line37></span>                  <span class="comment">// it's not recursive because the element </span>
<span class="lineno" id=line38></span>                  <span class="comment">// is a leaf and has no children</span>
<span class="lineno" id=line39></span>              <span class="small_keyword" title="end a match statement or expression">endmatch</span>;
<span class="lineno" id=line40></span>            <span class="small_keyword" title="end a match statement or expression">endmatch</span>;
<span class="lineno" id=line41></span>          <span class="small_keyword" title="conditional">elif</span> elt &lt; q*.elt <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line42></span>            aux q.left;
<span class="lineno" id=line43></span>          <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line44></span>            aux q.right;
<span class="lineno" id=line45></span>          <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line46></span>        <span class="small_keyword" title="end a match statement or expression">endmatch</span>;
<span class="lineno" id=line47></span>      }
<span class="lineno" id=line48></span>      aux p;
<span class="lineno" id=line49></span>    }
<span class="lineno" id=line50></span>  
<span class="lineno" id=line51></span>  } <span class="comment">// class</span>
<span class="lineno" id=line52></span>  
</pre></p></div></div><h1 id='Judy_Arrays_h'><img src='/share/src/web/images/minus.gif' id='Judy Arrays' onclick='toggle(this,"Judy_Arrays_d")' alt='+'/> 7 Judy Arrays</h1><div id='Judy_Arrays_d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/judy.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="comment">// NOTES: The Felix type 'address' is the correct type for Judy Word</span>
<span class="lineno" id=line3></span>  <span class="comment">// However it is also an unsigned integer type (int or long depending</span>
<span class="lineno" id=line4></span>  <span class="comment">// on platform)</span>
<span class="lineno" id=line5></span>  <span class="comment">//</span>
<span class="lineno" id=line6></span>  <span class="comment">// But Felix doesn't support automatic int/address conversions</span>
<span class="lineno" id=line7></span>  <span class="comment">//</span>
<span class="lineno" id=line8></span>  <span class="comment">// So we will (later) use a typeset to fix this!</span>
<span class="lineno" id=line9></span>  <span class="big_keyword" title="Define a type class">class</span> Judy
<span class="lineno" id=line10></span>  {
<span class="lineno" id=line11></span>    <span class="big_keyword" title="specify requirements">requires</span> <span class="small_keyword" title="specifies an abstract package name">package</span> <span class="fstring">"judy"</span>;
<span class="lineno" id=line12></span>    <span class="big_keyword" title="specify requirements">requires</span> <span class="big_keyword" title="Specify C code to be inserted into header file">header</span> "<span class="embedded_c">#<span class="preproc">include</span> <span class="fstring">&lt;Judy.h&gt;</span></span>";
<span class="lineno" id=line13></span>    <span class="big_keyword" title="Open a module or class">open</span> <span class="hack">C_hack</span>;
<span class="lineno" id=line14></span>  
<span class="lineno" id=line15></span>    <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> word = <span class="fstring">"Word_t"</span>;
<span class="lineno" id=line16></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> word: !ints = <span class="fstring">"(Word_t)$1"</span>;
<span class="lineno" id=line17></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> word: <span class="library" title="special binding of C void* type">address</span> = <span class="fstring">"(Word_t)$1"</span>;
<span class="lineno" id=line18></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> <span class="library" title="binding of C int type">int</span>: word = <span class="fstring">"(int)$1"</span>;
<span class="lineno" id=line19></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> <span class="library" title="binding of C unsigned int type">uint</span>: word = <span class="fstring">"(int)$1"</span>;
<span class="lineno" id=line20></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> <span class="library" title="binding of C unsigned long type">ulong</span>: word = <span class="fstring">"(unsigned long)$1"</span>;
<span class="lineno" id=line21></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> <span class="library" title="binding of C size_t type">size</span>: word = <span class="fstring">"(size_t)$1"</span>;
<span class="lineno" id=line22></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> <span class="library" title="special binding of C void* type">address</span>: word = <span class="fstring">"(void*)$1"</span>;
<span class="lineno" id=line23></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> isNULL: word -&gt; bool = <span class="fstring">"$1==0"</span>;
<span class="lineno" id=line24></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> isNULL: &amp;word -&gt; bool = <span class="fstring">"$1==0"</span>;
<span class="lineno" id=line25></span>  
<span class="lineno" id=line26></span>    <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> JError_t = <span class="fstring">"JError_t"</span>;
<span class="lineno" id=line27></span>  
<span class="lineno" id=line28></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> <span class="big_keyword" title="Specify C code to be inserted into implementation file">body</span> mkjudy =
<span class="lineno" id=line29></span>      """<span class="embedded_c">
<span class="lineno" id=line30></span>        <span class="qualifier">static</span> <span class="qualifier">void</span> **_mkjudy(thread_frame_t *ptf, ::flx::gc::generic::gc_shape_t *jptr_map){
<span class="lineno" id=line31></span>          <span class="big_keyword">typedef</span> <span class="qualifier">void</span> *voidp; <span class="comment">// syntax
<span class="lineno" id=line32></span>  </span>        <span class="qualifier">void</span> **m = new (*ptf-&gt;gcp, *jptr_map, false) voidp; 
<span class="lineno" id=line33></span>          *m=0;
<span class="lineno" id=line34></span>          <span class="small_keyword">return</span> m;
<span class="lineno" id=line35></span>        }
<span class="lineno" id=line36></span>      </span>"""
<span class="lineno" id=line37></span>    ;
<span class="lineno" id=line38></span>  
<span class="lineno" id=line39></span>    <span class="comment">// the "value" of a judy array is just a void*</span>
<span class="lineno" id=line40></span>    <span class="comment">// to mutate it though, we need it to be on the heap</span>
<span class="lineno" id=line41></span>    <span class="comment">// and use the pointer to that object as the array,</span>
<span class="lineno" id=line42></span>    <span class="comment">// so that it can be copied about</span>
<span class="lineno" id=line43></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> <span class="big_keyword" title="Specify C code to be inserted into implementation file">body</span> j1free =
<span class="lineno" id=line44></span>      """<span class="embedded_c">
<span class="lineno" id=line45></span>        <span class="qualifier">static</span> <span class="qualifier">void</span> _j1free(::flx::gc::generic::collector_t*,<span class="qualifier">void</span> *p) {
<span class="lineno" id=line46></span>          <span class="comment">//printf("Free J1Array %p\\n",p);
<span class="lineno" id=line47></span>  </span>        JError_t je;
<span class="lineno" id=line48></span>          Judy1FreeArray((<span class="qualifier">void</span>**)p, &amp;je); 
<span class="lineno" id=line49></span>        }
<span class="lineno" id=line50></span>      </span>"""
<span class="lineno" id=line51></span>    ;
<span class="lineno" id=line52></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> J1Array_ = <span class="fstring">"void*"</span>
<span class="lineno" id=line53></span>      <span class="big_keyword" title="specify requirements">requires</span> 
<span class="lineno" id=line54></span>        <span class="qualifier" title="names C routine which scans a data structure for pointers">scanner</span> <span class="fstring">"::flx::gc::generic::Judy1_scanner"</span>,
<span class="lineno" id=line55></span>        <span class="big_keyword" title="Specify C code to be inserted into header file">header</span> '<span class="embedded_c">#<span class="preproc">include</span> <span class="fstring">"flx_judy_scanner.hpp"</span></span>',
<span class="lineno" id=line56></span>        <span class="qualifier" title="names C routine which finalises an object">finaliser</span> '<span class="embedded_c">_j1free</span>',
<span class="lineno" id=line57></span>        j1free
<span class="lineno" id=line58></span>    ;
<span class="lineno" id=line59></span>    _gc_pointer _gc_type J1Array_ <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> J1Array = <span class="fstring">"void**"</span> <span class="big_keyword" title="specify requirements">requires</span> property <span class="fstring">"needs_gc"</span>; 
<span class="lineno" id=line60></span>  
<span class="lineno" id=line61></span>    <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> _ctor_J1Array: 1 -&gt; J1Array = <span class="fstring">"_mkjudy(FLX_POINTER_TO_THREAD_FRAME, &amp;@0)"</span> 
<span class="lineno" id=line62></span>      <span class="big_keyword" title="specify requirements">requires</span> 
<span class="lineno" id=line63></span>        mkjudy,
<span class="lineno" id=line64></span>        property <span class="fstring">"needs_gc"</span>
<span class="lineno" id=line65></span>    ;
<span class="lineno" id=line66></span>  
<span class="lineno" id=line67></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> free: J1Array = <span class="fstring">"_j1free(NULL,$1);"</span> <span class="big_keyword" title="specify requirements">requires</span> j1free;
<span class="lineno" id=line68></span>  
<span class="lineno" id=line69></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> Judy1Set: J1Array * word * &amp;JError_t * &amp;<span class="library" title="binding of C int type">int</span> =
<span class="lineno" id=line70></span>      <span class="fstring">"*$4=Judy1Set($1,$2,$3);"</span>;
<span class="lineno" id=line71></span>  
<span class="lineno" id=line72></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> Judy1Unset: J1Array * word * &amp;JError_t * &amp;<span class="library" title="binding of C int type">int</span> =
<span class="lineno" id=line73></span>      <span class="fstring">"*$4=Judy1Unset($1,$2,$3);"</span>;
<span class="lineno" id=line74></span>  
<span class="lineno" id=line75></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> Judy1Test: J1Array * word * &amp;JError_t * &amp;<span class="library" title="binding of C int type">int</span> =
<span class="lineno" id=line76></span>      <span class="fstring">"*$4=Judy1Test(*$1,$2,$3);"</span>;
<span class="lineno" id=line77></span>  
<span class="lineno" id=line78></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> Set[J1Array,word] {
<span class="lineno" id=line79></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="tex_symbol" title="\in">\(\in\)</span> (x:word, a:J1Array) : bool = {
<span class="lineno" id=line80></span>        <span class="big_keyword" title="Define a mutable variable">var</span> e:JError_t;
<span class="lineno" id=line81></span>        <span class="big_keyword" title="Define a mutable variable">var</span> r:<span class="library" title="binding of C int type">int</span>;
<span class="lineno" id=line82></span>        Judy1Test(a,x,&amp;e,&amp;r);
<span class="lineno" id=line83></span>        <span class="small_keyword" title="return">return</span> r == 1;
<span class="lineno" id=line84></span>      }
<span class="lineno" id=line85></span>    }
<span class="lineno" id=line86></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> Judy1Count: J1Array * word * word* &amp;JError_t * &amp;word =
<span class="lineno" id=line87></span>      <span class="fstring">"*$5=Judy1Count(*$1,$2,$3,$4);"</span>;
<span class="lineno" id=line88></span>  
<span class="lineno" id=line89></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> Judy1ByCount: J1Array * word * &amp;word * &amp;JError_t * &amp;word =
<span class="lineno" id=line90></span>      <span class="fstring">"*$5=Judy1ByCount(*$1,$2,$3,$4);"</span>;
<span class="lineno" id=line91></span>  
<span class="lineno" id=line92></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> Judy1FreeArray: J1Array * &amp;JError_t * &amp;word =
<span class="lineno" id=line93></span>      <span class="fstring">"*$3=Judy1FreeArray($1,$2);"</span>;
<span class="lineno" id=line94></span>  
<span class="lineno" id=line95></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> Judy1MemUsed: J1Array * &amp;word = <span class="fstring">"*$2=Judy1MemUsed(*$1);"</span>;
<span class="lineno" id=line96></span>  
<span class="lineno" id=line97></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> Judy1First: J1Array * &amp;word * &amp;JError_t * &amp;<span class="library" title="binding of C int type">int</span> =
<span class="lineno" id=line98></span>      <span class="fstring">"*$4=Judy1First(*$1,$2,$3);"</span>;
<span class="lineno" id=line99></span>  
<span class="lineno" id=line100></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> Judy1Next: J1Array * &amp;word * &amp;JError_t * &amp;<span class="library" title="binding of C int type">int</span> =
<span class="lineno" id=line101></span>      <span class="fstring">"*$4=Judy1Next(*$1,$2,$3);"</span>;
<span class="lineno" id=line102></span>  
<span class="lineno" id=line103></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> Judy1Last: J1Array * &amp;word * &amp;JError_t * &amp;<span class="library" title="binding of C int type">int</span> =
<span class="lineno" id=line104></span>      <span class="fstring">"*$4=Judy1Last(*$1,$2,$3);"</span>;
<span class="lineno" id=line105></span>  
<span class="lineno" id=line106></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> Judy1Prev: J1Array * &amp;word * &amp;JError_t * &amp;<span class="library" title="binding of C int type">int</span> =
<span class="lineno" id=line107></span>      <span class="fstring">"*$4=Judy1Prev(*$1,$2,$3);"</span>;
<span class="lineno" id=line108></span>  
<span class="lineno" id=line109></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> Judy1FirstEmpty: J1Array * &amp;word * &amp;JError_t * &amp;<span class="library" title="binding of C int type">int</span> =
<span class="lineno" id=line110></span>      <span class="fstring">"*$4=Judy1FirstEmpty(*$1,$2,$3);"</span>;
<span class="lineno" id=line111></span>  
<span class="lineno" id=line112></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> Judy1NextEmpty: J1Array * &amp;word * &amp;JError_t * &amp;<span class="library" title="binding of C int type">int</span> =
<span class="lineno" id=line113></span>      <span class="fstring">"*$4=Judy1NextEmpty(*$1,$2,$3);"</span>;
<span class="lineno" id=line114></span>  
<span class="lineno" id=line115></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> Judy1LastEmpty: J1Array * &amp;word * &amp;JError_t * &amp;<span class="library" title="binding of C int type">int</span> =
<span class="lineno" id=line116></span>      <span class="fstring">"*$4=Judy1LastEmpty(*$1,$2,$3);"</span>;
<span class="lineno" id=line117></span>  
<span class="lineno" id=line118></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> Judy1PrevEmpty: J1Array * &amp;word * &amp;JError_t * &amp;<span class="library" title="binding of C int type">int</span> =
<span class="lineno" id=line119></span>      <span class="fstring">"*$4=Judy1PrevEmpty(*$1,$2,$3);"</span>;
<span class="lineno" id=line120></span>  
<span class="lineno" id=line121></span>  <span class="comment">///////////////////////////////////////</span>
<span class="lineno" id=line122></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> <span class="big_keyword" title="Specify C code to be inserted into implementation file">body</span> jLfree =
<span class="lineno" id=line123></span>      """<span class="embedded_c">
<span class="lineno" id=line124></span>        <span class="qualifier">static</span> <span class="qualifier">void</span> _jLfree(::flx::gc::generic::collector_t*,<span class="qualifier">void</span> *p) {
<span class="lineno" id=line125></span>          <span class="comment">//printf("Free JLArray %p\\n",p);
<span class="lineno" id=line126></span>  </span>        JError_t je;
<span class="lineno" id=line127></span>          JudyLFreeArray((<span class="qualifier">void</span>**)p, &amp;je); 
<span class="lineno" id=line128></span>        }
<span class="lineno" id=line129></span>      </span>"""
<span class="lineno" id=line130></span>    ;
<span class="lineno" id=line131></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> JLArray_ = <span class="fstring">"void*"</span>
<span class="lineno" id=line132></span>      <span class="big_keyword" title="specify requirements">requires</span> 
<span class="lineno" id=line133></span>        <span class="qualifier" title="names C routine which scans a data structure for pointers">scanner</span> <span class="fstring">"::flx::gc::generic::JudyL_scanner"</span>,
<span class="lineno" id=line134></span>        <span class="big_keyword" title="Specify C code to be inserted into header file">header</span> '<span class="embedded_c">#<span class="preproc">include</span> <span class="fstring">"flx_judy_scanner.hpp"</span></span>',
<span class="lineno" id=line135></span>        <span class="qualifier" title="names C routine which finalises an object">finaliser</span> '<span class="embedded_c">_jLfree</span>',
<span class="lineno" id=line136></span>        jLfree
<span class="lineno" id=line137></span>    ;
<span class="lineno" id=line138></span>    _gc_pointer _gc_type JLArray_ <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> JLArray = <span class="fstring">"void**"</span> <span class="big_keyword" title="specify requirements">requires</span> property <span class="fstring">"needs_gc"</span>; 
<span class="lineno" id=line139></span>  
<span class="lineno" id=line140></span>    <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> _ctor_JLArray: 1 -&gt; JLArray = <span class="fstring">"_mkjudy(FLX_POINTER_TO_THREAD_FRAME, &amp;@0)"</span> 
<span class="lineno" id=line141></span>      <span class="big_keyword" title="specify requirements">requires</span> 
<span class="lineno" id=line142></span>        mkjudy,
<span class="lineno" id=line143></span>        property <span class="fstring">"needs_gc"</span>
<span class="lineno" id=line144></span>    ;
<span class="lineno" id=line145></span>  
<span class="lineno" id=line146></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> free: JLArray = <span class="fstring">"_jLfree(NULL,$1);"</span> <span class="big_keyword" title="specify requirements">requires</span> jLfree;
<span class="lineno" id=line147></span>  
<span class="lineno" id=line148></span>  
<span class="lineno" id=line149></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudyLIns: JLArray * word * &amp;JError_t * &amp;&amp;word =
<span class="lineno" id=line150></span>      <span class="fstring">"*(Word_t**)$4=(Word_t*)JudyLIns($1,$2,$3);"</span>;
<span class="lineno" id=line151></span>  
<span class="lineno" id=line152></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudyLDel: JLArray * word * &amp;JError_t * &amp;<span class="library" title="binding of C int type">int</span> =
<span class="lineno" id=line153></span>      <span class="fstring">"*$4=JudyLDel($1,$2,$3);"</span>;
<span class="lineno" id=line154></span>  
<span class="lineno" id=line155></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudyLGet: JLArray * word * &amp;JError_t * &amp;&amp;word =
<span class="lineno" id=line156></span>      <span class="fstring">"*$4=(Word_t*)JudyLGet(*$1,$2,$3);"</span>;
<span class="lineno" id=line157></span>  
<span class="lineno" id=line158></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudyLCount: JLArray * word * word * &amp;JError_t * &amp;word =
<span class="lineno" id=line159></span>      <span class="fstring">"*$5=JudyLCount(*$1,$2,$3,$4);"</span>;
<span class="lineno" id=line160></span>  
<span class="lineno" id=line161></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudyLByCount: JLArray * word * &amp;word * &amp;JError_t * &amp;&amp;word =
<span class="lineno" id=line162></span>      <span class="fstring">"*$5=JudyLCount(*$1,$2,$3,$4);"</span>;
<span class="lineno" id=line163></span>  
<span class="lineno" id=line164></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudyLFreeArray: JLArray * &amp;JError_t * &amp;word =
<span class="lineno" id=line165></span>      <span class="fstring">"*$3=JudyLFree($1,$2);"</span>;
<span class="lineno" id=line166></span>  
<span class="lineno" id=line167></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudyLMemUsed: JLArray * &amp;word =
<span class="lineno" id=line168></span>      <span class="fstring">"*$2=JudyLMemUsed(*$1);"</span>;
<span class="lineno" id=line169></span>  
<span class="lineno" id=line170></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudyLFirst: JLArray * &amp;word * &amp;JError_t * &amp;&amp;word =
<span class="lineno" id=line171></span>      <span class="fstring">"*(Word_t**)$4=(Word_t*)JudyLFirst(*$1,$2,$3);"</span>;
<span class="lineno" id=line172></span>  
<span class="lineno" id=line173></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudyLNext: JLArray * &amp;word * &amp;JError_t * &amp;&amp;word =
<span class="lineno" id=line174></span>      <span class="fstring">"*(Word_t**)$4=(Word_t*)JudyLNext(*$1,$2,$3);"</span>;
<span class="lineno" id=line175></span>  
<span class="lineno" id=line176></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudyLLast: JLArray * &amp;word * &amp;JError_t * &amp;&amp;word =
<span class="lineno" id=line177></span>      <span class="fstring">"*(Word_t**)$4=(Word_t*)JudyLLast(*$1,$2,$3);"</span>;
<span class="lineno" id=line178></span>  
<span class="lineno" id=line179></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudyLPrev: JLArray * &amp;word * &amp;JError_t * &amp;&amp;word =
<span class="lineno" id=line180></span>      <span class="fstring">"*(Word_t**)$4=(Word_t*)JudyLPrev(*$1,$2,$3);"</span>;
<span class="lineno" id=line181></span>  
<span class="lineno" id=line182></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudyLFirstEmpty: JLArray * &amp;word * &amp;JError_t * &amp;word =
<span class="lineno" id=line183></span>      <span class="fstring">"*$4=JudyLFirstEmpty(*$1,$2,$3);"</span>;
<span class="lineno" id=line184></span>  
<span class="lineno" id=line185></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudyLNextEmpty: JLArray * &amp;word * &amp;JError_t * &amp;word =
<span class="lineno" id=line186></span>      <span class="fstring">"*$4=JudyLNextEmpty(*$1,$2,$3);"</span>;
<span class="lineno" id=line187></span>  
<span class="lineno" id=line188></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudyLLastEmpty: JLArray * &amp;word * &amp;JError_t * &amp;word =
<span class="lineno" id=line189></span>      <span class="fstring">"*$4=JudyLLastEmpty(*$1,$2,$3);"</span>;
<span class="lineno" id=line190></span>  
<span class="lineno" id=line191></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudyLPrevEmpty: JLArray * &amp;word * &amp;JError_t * &amp;word =
<span class="lineno" id=line192></span>      <span class="fstring">"*$4=JudyLPrevEmpty(*$1,$2,$3);"</span>;
<span class="lineno" id=line193></span>  
<span class="lineno" id=line194></span>  <span class="comment">///////////////////////////////////////</span>
<span class="lineno" id=line195></span>  <span class="comment">// We should improve the safety here, unbounded string</span>
<span class="lineno" id=line196></span>  <span class="comment">// lengths .. yuck. char *buffer for results .. overruns possible!</span>
<span class="lineno" id=line197></span>  
<span class="lineno" id=line198></span>    <span class="big_keyword" title="Specify C code to be inserted into implementation file">body</span> JudySL_maxlen = "<span class="embedded_c">#<span class="preproc">define</span> JUDY_SL_MAXLEN 10000</span>";
<span class="lineno" id=line199></span>    <span class="big_keyword" title="Specify C code to be inserted into implementation file">body</span> jSLfree =
<span class="lineno" id=line200></span>      """<span class="embedded_c">
<span class="lineno" id=line201></span>        <span class="qualifier">static</span> <span class="qualifier">void</span> _jSLfree(::flx::gc::generic::collector_t*,<span class="qualifier">void</span> *p) {
<span class="lineno" id=line202></span>          <span class="comment">//printf("Free JSLArray %p\\n",p);
<span class="lineno" id=line203></span>  </span>        JError_t je;
<span class="lineno" id=line204></span>          JudySLFreeArray((<span class="qualifier">void</span>**)p, &amp;je); 
<span class="lineno" id=line205></span>        }
<span class="lineno" id=line206></span>      </span>"""
<span class="lineno" id=line207></span>    ;
<span class="lineno" id=line208></span>    <span class="qualifier" title="Symbol visible only in enclosing module or typeclass namespace">private</span> <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> JSLArray_ = <span class="fstring">"void*"</span>
<span class="lineno" id=line209></span>      <span class="big_keyword" title="specify requirements">requires</span> 
<span class="lineno" id=line210></span>        <span class="qualifier" title="names C routine which scans a data structure for pointers">scanner</span> <span class="fstring">"::flx::gc::generic::JudySL_scanner"</span>,
<span class="lineno" id=line211></span>        <span class="big_keyword" title="Specify C code to be inserted into header file">header</span> '<span class="embedded_c">#<span class="preproc">include</span> <span class="fstring">"flx_judy_scanner.hpp"</span></span>',
<span class="lineno" id=line212></span>        <span class="qualifier" title="names C routine which finalises an object">finaliser</span> '<span class="embedded_c">_jSLfree</span>',
<span class="lineno" id=line213></span>        jSLfree, JudySL_maxlen
<span class="lineno" id=line214></span>    ;
<span class="lineno" id=line215></span>    _gc_pointer _gc_type JSLArray_ <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> JSLArray = <span class="fstring">"void**"</span> <span class="big_keyword" title="specify requirements">requires</span> property <span class="fstring">"needs_gc"</span>; 
<span class="lineno" id=line216></span>  
<span class="lineno" id=line217></span>    <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> _ctor_JSLArray: 1 -&gt; JSLArray = <span class="fstring">"_mkjudy(FLX_POINTER_TO_THREAD_FRAME, &amp;@0)"</span> 
<span class="lineno" id=line218></span>      <span class="big_keyword" title="specify requirements">requires</span> 
<span class="lineno" id=line219></span>        mkjudy ,
<span class="lineno" id=line220></span>        property <span class="fstring">"needs_gc"</span>
<span class="lineno" id=line221></span>    ;
<span class="lineno" id=line222></span>  
<span class="lineno" id=line223></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> free: JSLArray = <span class="fstring">"_jSLfree(NULL,$1);"</span> <span class="big_keyword" title="specify requirements">requires</span> jSLfree;
<span class="lineno" id=line224></span>  
<span class="lineno" id=line225></span>    <span class="big_keyword" title="Bind a Felix symbol to a C expression">const</span> JUDY_SL_MAXLEN : <span class="library" title="binding of C int type">int</span> = <span class="fstring">"JUDY_SL_MAXLEN"</span>;
<span class="lineno" id=line226></span>  
<span class="lineno" id=line227></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudySLIns: JSLArray * +<span class="library" title="binding of C char type">char</span> * &amp;JError_t * &amp;&amp;word =
<span class="lineno" id=line228></span>      <span class="fstring">"""
<span class="lineno" id=line229></span>        if (::std::strlen($2) &gt;= JUDY_SL_MAXLEN) throw "JudySLIns strlen&gt;10000";
<span class="lineno" id=line230></span>        *(Word_t**)$4=(Word_t*)JudySLIns($1,(unsigned char*)$2,$3);
<span class="lineno" id=line231></span>      """</span> <span class="big_keyword" title="specify requirements">requires</span> Cxx_headers::cstring;
<span class="lineno" id=line232></span>  
<span class="lineno" id=line233></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudySLDel: JSLArray * +<span class="library" title="binding of C char type">char</span> * &amp;JError_t * &amp;<span class="library" title="binding of C int type">int</span> =
<span class="lineno" id=line234></span>      <span class="fstring">"*$4=JudySLDel($1,(unsigned char*)$2,$3);"</span>;
<span class="lineno" id=line235></span>  
<span class="lineno" id=line236></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudySLGet: JSLArray * +<span class="library" title="binding of C char type">char</span> * &amp;JError_t * &amp;&amp;word =
<span class="lineno" id=line237></span>      <span class="fstring">"*$4=(Word_t*)JudySLGet(*$1,(unsigned char*)$2,$3);"</span>;
<span class="lineno" id=line238></span>  
<span class="lineno" id=line239></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudySLFirst: JSLArray * +<span class="library" title="binding of C char type">char</span> * &amp;JError_t * &amp;&amp;word =
<span class="lineno" id=line240></span>      <span class="fstring">"*(Word_t**)$4=(Word_t*)JudySLFirst(*$1,(unsigned char*)$2,$3);"</span>;
<span class="lineno" id=line241></span>  
<span class="lineno" id=line242></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudySLNext: JSLArray * +<span class="library" title="binding of C char type">char</span> * &amp;JError_t * &amp;&amp;word =
<span class="lineno" id=line243></span>      <span class="fstring">"*(Word_t**)$4=(Word_t*)JudySLNext(*$1,(unsigned char*)$2,$3);"</span>;
<span class="lineno" id=line244></span>  
<span class="lineno" id=line245></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudySLLast: JSLArray * +<span class="library" title="binding of C char type">char</span> * &amp;JError_t * &amp;&amp;word =
<span class="lineno" id=line246></span>      <span class="fstring">"*$4=JudySLLast(*$1,(unsigned char*)$2,$3);"</span>;
<span class="lineno" id=line247></span>  
<span class="lineno" id=line248></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> JudySLPrev: JSLArray * +<span class="library" title="binding of C char type">char</span> * &amp;JError_t * &amp;&amp;word =
<span class="lineno" id=line249></span>      <span class="fstring">"*$4=JudySLPrev(*$1,(unsigned char*)$2,$3);"</span>;
<span class="lineno" id=line250></span>  
<span class="lineno" id=line251></span>  <span class="comment">///////////////////////////////////////</span>
<span class="lineno" id=line252></span>  
<span class="lineno" id=line253></span>  <span class="comment">/* JUDYHS is not supported because there's no way to iterate 
<span class="lineno" id=line254></span>     which is required for the GC to work
<span class="lineno" id=line255></span>  
<span class="lineno" id=line256></span>    type JHSArray = "void**";
<span class="lineno" id=line257></span>    gen _ctor_JHSArray: 1 -&gt; JHSArray = "_mkjudy()" requires mkjudy;
<span class="lineno" id=line258></span>  
<span class="lineno" id=line259></span>    proc free: JHSArray = "_jHSfree($1);" requires body
<span class="lineno" id=line260></span>      """
<span class="lineno" id=line261></span>        void _jHSfree(void **p) { JudyHSFreeArray(p); free(p); }
<span class="lineno" id=line262></span>      """;
<span class="lineno" id=line263></span>  
<span class="lineno" id=line264></span>    proc JudyHSIns: JHSArray * address * word * &amp;JError_t * &amp;&amp;word =
<span class="lineno" id=line265></span>      "*$5=(Word_t*)JudyHSIns($1,$2,$3,$4);";
<span class="lineno" id=line266></span>  
<span class="lineno" id=line267></span>    proc JudyHSDel: JHSArray * address * word * &amp;JError_t * &amp;int =
<span class="lineno" id=line268></span>      "*$5=JudyHSDel($1,$2,$3,$4);";
<span class="lineno" id=line269></span>  
<span class="lineno" id=line270></span>    proc JudyHSGet: JHSArray * address * word * &amp;JError_t * &amp;&amp;word =
<span class="lineno" id=line271></span>      "*$5=(Word_t*)JudyHSGet(*$1,$2,$3);";
<span class="lineno" id=line272></span>  */</span>
<span class="lineno" id=line273></span>  
<span class="lineno" id=line274></span>  }
<span class="lineno" id=line275></span>  
<span class="lineno" id=line276></span>  <span class="big_keyword" title="Open a module or class">open</span> Set[Judy::J1Array,Judy::word];
<span class="lineno" id=line277></span>  
</pre></p></div><h1 id='String_Dictionary._h'><img src='/share/src/web/images/minus.gif' id='String Dictionary.' onclick='toggle(this,"String_Dictionary._d")' alt='+'/> 8 String Dictionary.</h1><div id='String_Dictionary._d' style='display:block'>
<pre class='inclusion'>
share/lib/std/datatype/strdict.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  
<span class="lineno" id=line2></span>  <span class="doccomment">A strdict is dictionary keyed by strings.</span>
<span class="lineno" id=line3></span>  <span class="doccomment">The strings must not contain nul bytes.</span>
<span class="lineno" id=line4></span>  <span class="doccomment">//$ This is an ultra high performance data structure</span>
<span class="lineno" id=line5></span>  <span class="doccomment">implemented using a JudySLArray.</span>
<span class="lineno" id=line6></span>  <span class="doccomment">Typically about the same speed as a hashtable on exact key retrieval,</span>
<span class="lineno" id=line7></span>  <span class="doccomment">but with the ability to perform linear key seeking as well.</span>
<span class="lineno" id=line8></span>  <span class="doccomment">Linear seeking means searching for a key satisfying one of the total</span>
<span class="lineno" id=line9></span>  <span class="doccomment">ordering relations to a given key, including ordered iteration.</span>
<span class="lineno" id=line10></span>  <span class="doccomment">//$ Scales to terabytes.</span>
<span class="lineno" id=line11></span>  <span class="doccomment">No other data structure can do this.</span>
<span class="lineno" id=line12></span>  
<span class="lineno" id=line13></span>  <span class="big_keyword" title="Define a type class">class</span> StrDict[T] {
<span class="lineno" id=line14></span>     <span class="big_keyword" title="Open a module or class">open</span> Judy;
<span class="lineno" id=line15></span>  
<span class="lineno" id=line16></span>     <span class="doccomment">Type of a strdict.</span>
<span class="lineno" id=line17></span>     <span class="big_keyword" title="Define a primitive type by binding to a C type">type</span> strdict = new JSLArray;
<span class="lineno" id=line18></span>  
<span class="lineno" id=line19></span>     <span class="doccomment">Construct and empty dictionary.</span>
<span class="lineno" id=line20></span>     <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> strdict() =&gt; _make_strdict$ JSLArray ();
<span class="lineno" id=line21></span>  
<span class="lineno" id=line22></span>     <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> add (x:strdict) (<span class="big_keyword" title="Define a mutable variable">var</span> key:<span class="library" title="binding of C++ string type">string</span>) (value: T) { 
<span class="lineno" id=line23></span>       <span class="big_keyword" title="Define a mutable variable">var</span> err: JError_t;
<span class="lineno" id=line24></span>       <span class="big_keyword" title="Define a mutable variable">var</span> slot : &amp;&amp; T; 
<span class="lineno" id=line25></span>       JudySLIns (_repr_ x, &amp;key.stl_begin, &amp;err, <span class="hack">C_hack</span>::cast[&amp;&amp;word] (&amp;slot));
<span class="lineno" id=line26></span>       slot &lt;- unbox (new value);
<span class="lineno" id=line27></span>     }
<span class="lineno" id=line28></span>  
<span class="lineno" id=line29></span>     <span class="doccomment">Construct a dictionary from a list of pairs.</span>
<span class="lineno" id=line30></span>     <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> strdict ( kv: <span class="library" title="functional, singly linked list">list</span>[<span class="library" title="binding of C++ string type">string</span> * T] ) = {
<span class="lineno" id=line31></span>       <span class="big_keyword" title="Define a mutable variable">var</span> x = strdict ();
<span class="lineno" id=line32></span>       <span class="small_keyword" title="match statement or expression">match</span> k,v <span class="small_keyword" title="membership operator, function mem">in</span> kv <span class="small_keyword" title="imperative code begins">do</span> add x k v; <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line33></span>       <span class="small_keyword" title="return">return</span> x;
<span class="lineno" id=line34></span>     }
<span class="lineno" id=line35></span>  
<span class="lineno" id=line36></span>     
<span class="lineno" id=line37></span>     <span class="doccomment">Fetch a value optionally using the given key.</span>
<span class="lineno" id=line38></span>     <span class="big_keyword" title="Define a function with no side-effects">fun</span> get (x:strdict) (<span class="big_keyword" title="Define a mutable variable">var</span> key: <span class="library" title="binding of C++ string type">string</span>) : <span class="library" title="option type: Some x or None">opt</span>[T] = {
<span class="lineno" id=line39></span>       <span class="big_keyword" title="Define a mutable variable">var</span> err: JError_t;
<span class="lineno" id=line40></span>       <span class="big_keyword" title="Define a mutable variable">var</span> slot : &amp;&amp; T; 
<span class="lineno" id=line41></span>       JudySLGet (_repr_ x, &amp;key.stl_begin, &amp;err, <span class="hack">C_hack</span>::cast[&amp;&amp;word] (&amp;slot));
<span class="lineno" id=line42></span>       <span class="small_keyword" title="return">return</span> <span class="small_keyword" title="conditional">if</span> <span class="hack">C_hack</span>::isNULL slot <span class="small_keyword" title="conditional">then</span> None[T] <span class="small_keyword" title="conditional">else</span> Some (**slot);
<span class="lineno" id=line43></span>     }
<span class="lineno" id=line44></span>  
<span class="lineno" id=line45></span>     <span class="doccomment">Check if value is in the dictionary.</span>
<span class="lineno" id=line46></span>     <span class="big_keyword" title="Define a function with no side-effects">fun</span> haskey (x:strdict) (<span class="big_keyword" title="Define a mutable variable">var</span> key: <span class="library" title="binding of C++ string type">string</span>) : bool = 
<span class="lineno" id=line47></span>     {
<span class="lineno" id=line48></span>       <span class="big_keyword" title="Define a mutable variable">var</span> err: JError_t;
<span class="lineno" id=line49></span>       <span class="big_keyword" title="Define a mutable variable">var</span> slot : &amp;&amp; T; 
<span class="lineno" id=line50></span>       JudySLGet (_repr_ x, &amp;key.stl_begin, &amp;err, <span class="hack">C_hack</span>::cast[&amp;&amp;word] (&amp;slot));
<span class="lineno" id=line51></span>       <span class="small_keyword" title="return">return</span> slot.<span class="hack">C_hack</span>::isNULL.lnot;
<span class="lineno" id=line52></span>     }
<span class="lineno" id=line53></span>  
<span class="lineno" id=line54></span>  
<span class="lineno" id=line55></span>     <span class="doccomment">Fetch a value using the given key.</span>
<span class="lineno" id=line56></span>     <span class="doccomment">If there is no value in the dictionary with that key,</span>
<span class="lineno" id=line57></span>     <span class="doccomment">then return a default value.</span>
<span class="lineno" id=line58></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> get_dflt (x:strdict) (key:<span class="library" title="binding of C++ string type">string</span>, dflt:T) =&gt; 
<span class="lineno" id=line59></span>      <span class="small_keyword" title="match statement or expression">match</span> get x key <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line60></span>      | Some v =&gt; v
<span class="lineno" id=line61></span>      | #None =&gt; dflt
<span class="lineno" id=line62></span>      <span class="small_keyword" title="end a match statement or expression">endmatch</span>
<span class="lineno" id=line63></span>    ;
<span class="lineno" id=line64></span>  
<span class="lineno" id=line65></span>    <span class="doccomment">Remove a key/value pair from the dictionary if it exists.</span>
<span class="lineno" id=line66></span>    <span class="doccomment">Return a boolean value signalling if it existed. </span>
<span class="lineno" id=line67></span>    <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> del (x:strdict) (key: <span class="library" title="binding of C++ string type">string</span>) : bool = {
<span class="lineno" id=line68></span>       <span class="big_keyword" title="Define a mutable variable">var</span> err: JError_t;
<span class="lineno" id=line69></span>       <span class="big_keyword" title="Define a mutable variable">var</span> found : <span class="library" title="binding of C int type">int</span>;
<span class="lineno" id=line70></span>       JudySLDel (_repr_ x, key.cstr, &amp;err, &amp;found);
<span class="lineno" id=line71></span>       <span class="small_keyword" title="return">return</span> found == 1; 
<span class="lineno" id=line72></span>     }
<span class="lineno" id=line73></span>  
<span class="lineno" id=line74></span>     <span class="doccomment">Get an optional value with key greater than or equal to</span>
<span class="lineno" id=line75></span>     <span class="doccomment">the supplied NTBS (unsafe!)</span>
<span class="lineno" id=line76></span>     <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> charp_get_ge (x:strdict) (<span class="big_keyword" title="Define a mutable variable">var</span> key: +<span class="library" title="binding of C char type">char</span>) : <span class="library" title="option type: Some x or None">opt</span>[T]= {
<span class="lineno" id=line77></span>       <span class="big_keyword" title="Define a mutable variable">var</span> err: JError_t;
<span class="lineno" id=line78></span>       <span class="big_keyword" title="Define a mutable variable">var</span> slot : &amp;&amp; T; 
<span class="lineno" id=line79></span>       JudySLFirst (_repr_ x, key, &amp;err, <span class="hack">C_hack</span>::cast[&amp;&amp;word] (&amp;slot));
<span class="lineno" id=line80></span>       <span class="small_keyword" title="conditional">if</span> <span class="hack">C_hack</span>::isNULL slot <span class="small_keyword" title="imperative code begins">do</span> 
<span class="lineno" id=line81></span>         <span class="small_keyword" title="return">return</span> None[T];
<span class="lineno" id=line82></span>       <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line83></span>         <span class="small_keyword" title="return">return</span> Some (**slot);
<span class="lineno" id=line84></span>       <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line85></span>     }
<span class="lineno" id=line86></span>  
<span class="lineno" id=line87></span>     <span class="doccomment">Get an optional value with key greater than or equal to</span>
<span class="lineno" id=line88></span>     <span class="doccomment">the supplied string. Safer than the NTBS version but slower. </span>
<span class="lineno" id=line89></span>     <span class="doccomment">Fails if the string contains a nul byte.</span>
<span class="lineno" id=line90></span>     <span class="big_keyword" title="Define a function with no side-effects">fun</span> get_ge (x:strdict) (<span class="big_keyword" title="Define a mutable variable">var</span> key: <span class="library" title="binding of C++ string type">string</span>)= {
<span class="lineno" id=line91></span>       <span class="big_keyword" title="Define a mutable variable">var</span> err: JError_t;
<span class="lineno" id=line92></span>       <span class="big_keyword" title="Define a mutable variable">var</span> slot : &amp;&amp; T; 
<span class="lineno" id=line93></span>       <span class="big_keyword" title="Define a mutable variable">var</span> k = array_alloc[<span class="library" title="binding of C char type">char</span>]$ JUDY_SL_MAXLEN+1; 
<span class="lineno" id=line94></span>       CString::strncpy (k,key.cstr, JUDY_SL_MAXLEN);
<span class="lineno" id=line95></span>       <span class="big_keyword" title="Define a mutable variable">var</span> <span class="small_keyword" title="value of function return used in post condition">result</span> = charp_get_ge x k;
<span class="lineno" id=line96></span>       <span class="small_keyword" title="match statement or expression">match</span> <span class="small_keyword" title="value of function return used in post condition">result</span> <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line97></span>       | Some v =&gt;
<span class="lineno" id=line98></span>         key = k.<span class="library" title="binding of C++ string type">string</span>;
<span class="lineno" id=line99></span>         free k; 
<span class="lineno" id=line100></span>         <span class="small_keyword" title="return">return</span> Some (key,v);
<span class="lineno" id=line101></span>       | #None=&gt;
<span class="lineno" id=line102></span>         free k;
<span class="lineno" id=line103></span>         <span class="small_keyword" title="return">return</span> None[<span class="library" title="binding of C++ string type">string</span> * T];
<span class="lineno" id=line104></span>       <span class="small_keyword" title="end a match statement or expression">endmatch</span> ;
<span class="lineno" id=line105></span>     }
<span class="lineno" id=line106></span>  
<span class="lineno" id=line107></span>       <span class="doccomment">Get an optional value with key greater than  (&gt;)</span>
<span class="lineno" id=line108></span>       <span class="doccomment">the supplied NTBS (unsafe!)</span>
<span class="lineno" id=line109></span>       <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> charp_get_gt (x:strdict) (<span class="big_keyword" title="Define a mutable variable">var</span> key: +<span class="library" title="binding of C char type">char</span>)= {
<span class="lineno" id=line110></span>       <span class="big_keyword" title="Define a mutable variable">var</span> err: JError_t;
<span class="lineno" id=line111></span>       <span class="big_keyword" title="Define a mutable variable">var</span> slot : &amp;&amp; T; 
<span class="lineno" id=line112></span>       JudySLNext(_repr_ x, key, &amp;err, <span class="hack">C_hack</span>::cast[&amp;&amp;word] (&amp;slot));
<span class="lineno" id=line113></span>       <span class="small_keyword" title="conditional">if</span> <span class="hack">C_hack</span>::isNULL slot <span class="small_keyword" title="imperative code begins">do</span> 
<span class="lineno" id=line114></span>         <span class="small_keyword" title="return">return</span> None[T];
<span class="lineno" id=line115></span>       <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line116></span>         <span class="small_keyword" title="return">return</span> Some (**slot);
<span class="lineno" id=line117></span>       <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line118></span>     }
<span class="lineno" id=line119></span>  
<span class="lineno" id=line120></span>     <span class="doccomment">Get an optional value with key greater than (&gt;) </span>
<span class="lineno" id=line121></span>     <span class="doccomment">the supplied string. Safer than the NTBS version but slower. </span>
<span class="lineno" id=line122></span>     <span class="doccomment">Fails if the string contains a nul byte.</span>
<span class="lineno" id=line123></span>     <span class="big_keyword" title="Define a function with no side-effects">fun</span> get_gt (x:strdict) (<span class="big_keyword" title="Define a mutable variable">var</span> key: <span class="library" title="binding of C++ string type">string</span>)= {
<span class="lineno" id=line124></span>       <span class="big_keyword" title="Define a mutable variable">var</span> err: JError_t;
<span class="lineno" id=line125></span>       <span class="big_keyword" title="Define a mutable variable">var</span> slot : &amp;&amp; T; 
<span class="lineno" id=line126></span>       <span class="big_keyword" title="Define a mutable variable">var</span> k = array_alloc[<span class="library" title="binding of C char type">char</span>]$ JUDY_SL_MAXLEN+1; 
<span class="lineno" id=line127></span>       CString::strncpy (k,key.cstr, JUDY_SL_MAXLEN);
<span class="lineno" id=line128></span>       <span class="big_keyword" title="Define a mutable variable">var</span> <span class="small_keyword" title="value of function return used in post condition">result</span> = charp_get_gt x k;
<span class="lineno" id=line129></span>       <span class="small_keyword" title="match statement or expression">match</span> <span class="small_keyword" title="value of function return used in post condition">result</span> <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line130></span>       | Some v =&gt;
<span class="lineno" id=line131></span>         key = k.<span class="library" title="binding of C++ string type">string</span>;
<span class="lineno" id=line132></span>         free k; 
<span class="lineno" id=line133></span>         <span class="small_keyword" title="return">return</span> Some (key,v);
<span class="lineno" id=line134></span>       | #None=&gt;
<span class="lineno" id=line135></span>         free k;
<span class="lineno" id=line136></span>         <span class="small_keyword" title="return">return</span> None[<span class="library" title="binding of C++ string type">string</span> * T];
<span class="lineno" id=line137></span>       <span class="small_keyword" title="end a match statement or expression">endmatch</span> ;
<span class="lineno" id=line138></span>     }
<span class="lineno" id=line139></span>  
<span class="lineno" id=line140></span>     <span class="doccomment">Get an optional value with key less than or equal to (&lt;=)</span>
<span class="lineno" id=line141></span>     <span class="doccomment">the supplied NTBS (unsafe!)</span>
<span class="lineno" id=line142></span>     <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> charp_get_le (x:strdict) (<span class="big_keyword" title="Define a mutable variable">var</span> key: +<span class="library" title="binding of C char type">char</span>)= {
<span class="lineno" id=line143></span>       <span class="big_keyword" title="Define a mutable variable">var</span> err: JError_t;
<span class="lineno" id=line144></span>       <span class="big_keyword" title="Define a mutable variable">var</span> slot : &amp;&amp; T; 
<span class="lineno" id=line145></span>       JudySLLast(_repr_ x, key, &amp;err, <span class="hack">C_hack</span>::cast[&amp;&amp;word] (&amp;slot));
<span class="lineno" id=line146></span>       <span class="small_keyword" title="conditional">if</span> <span class="hack">C_hack</span>::isNULL slot <span class="small_keyword" title="imperative code begins">do</span> 
<span class="lineno" id=line147></span>         <span class="small_keyword" title="return">return</span> None[T];
<span class="lineno" id=line148></span>       <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line149></span>         <span class="small_keyword" title="return">return</span> Some (**slot);
<span class="lineno" id=line150></span>       <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line151></span>     }
<span class="lineno" id=line152></span>  
<span class="lineno" id=line153></span>     <span class="doccomment">Get an optional value with key less than or equal to (&lt;=)</span>
<span class="lineno" id=line154></span>     <span class="doccomment">the supplied string. Safer than the NTBS version but slower. </span>
<span class="lineno" id=line155></span>     <span class="doccomment">Fails if the string contains a nul byte.</span>
<span class="lineno" id=line156></span>     <span class="big_keyword" title="Define a function with no side-effects">fun</span> get_le (x:strdict) (<span class="big_keyword" title="Define a mutable variable">var</span> key: <span class="library" title="binding of C++ string type">string</span>)= {
<span class="lineno" id=line157></span>       <span class="big_keyword" title="Define a mutable variable">var</span> err: JError_t;
<span class="lineno" id=line158></span>       <span class="big_keyword" title="Define a mutable variable">var</span> slot : &amp;&amp; T; 
<span class="lineno" id=line159></span>       <span class="big_keyword" title="Define a mutable variable">var</span> k = array_alloc[<span class="library" title="binding of C char type">char</span>]$ JUDY_SL_MAXLEN+1; 
<span class="lineno" id=line160></span>       CString::strncpy (k,key.cstr, JUDY_SL_MAXLEN);
<span class="lineno" id=line161></span>       <span class="big_keyword" title="Define a mutable variable">var</span> <span class="small_keyword" title="value of function return used in post condition">result</span> = charp_get_le x k;
<span class="lineno" id=line162></span>       <span class="small_keyword" title="match statement or expression">match</span> <span class="small_keyword" title="value of function return used in post condition">result</span> <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line163></span>       | Some v =&gt;
<span class="lineno" id=line164></span>         key = k.<span class="library" title="binding of C++ string type">string</span>;
<span class="lineno" id=line165></span>         free k; 
<span class="lineno" id=line166></span>         <span class="small_keyword" title="return">return</span> Some (key,v);
<span class="lineno" id=line167></span>       | #None=&gt;
<span class="lineno" id=line168></span>         free k;
<span class="lineno" id=line169></span>         <span class="small_keyword" title="return">return</span> None[<span class="library" title="binding of C++ string type">string</span> * T];
<span class="lineno" id=line170></span>       <span class="small_keyword" title="end a match statement or expression">endmatch</span> ;
<span class="lineno" id=line171></span>     }
<span class="lineno" id=line172></span>  
<span class="lineno" id=line173></span>     <span class="doccomment">Get an optional value with key less than (&lt;)</span>
<span class="lineno" id=line174></span>     <span class="doccomment">the supplied NTBS (unsafe!)</span>
<span class="lineno" id=line175></span>     <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> charp_get_lt (x:strdict) (<span class="big_keyword" title="Define a mutable variable">var</span> key: +<span class="library" title="binding of C char type">char</span>)= {
<span class="lineno" id=line176></span>       <span class="big_keyword" title="Define a mutable variable">var</span> err: JError_t;
<span class="lineno" id=line177></span>       <span class="big_keyword" title="Define a mutable variable">var</span> slot : &amp;&amp; T; 
<span class="lineno" id=line178></span>       JudySLPrev (_repr_ x, key, &amp;err, <span class="hack">C_hack</span>::cast[&amp;&amp;word] (&amp;slot));
<span class="lineno" id=line179></span>       <span class="small_keyword" title="conditional">if</span> <span class="hack">C_hack</span>::isNULL slot <span class="small_keyword" title="imperative code begins">do</span> 
<span class="lineno" id=line180></span>         <span class="small_keyword" title="return">return</span> None[T];
<span class="lineno" id=line181></span>       <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line182></span>         <span class="small_keyword" title="return">return</span> Some (**slot);
<span class="lineno" id=line183></span>       <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line184></span>     }
<span class="lineno" id=line185></span>  
<span class="lineno" id=line186></span>     <span class="doccomment">Get an optional value with key less than (&lt;)</span>
<span class="lineno" id=line187></span>     <span class="doccomment">the supplied string. Safer than the NTBS version but slower. </span>
<span class="lineno" id=line188></span>     <span class="doccomment">Fails if the string contains a nul byte.</span>
<span class="lineno" id=line189></span>     <span class="big_keyword" title="Define a function with no side-effects">fun</span> get_lt (x:strdict) (<span class="big_keyword" title="Define a mutable variable">var</span> key: <span class="library" title="binding of C++ string type">string</span>)= {
<span class="lineno" id=line190></span>       <span class="big_keyword" title="Define a mutable variable">var</span> err: JError_t;
<span class="lineno" id=line191></span>       <span class="big_keyword" title="Define a mutable variable">var</span> slot : &amp;&amp; T; 
<span class="lineno" id=line192></span>       <span class="big_keyword" title="Define a mutable variable">var</span> k = array_alloc[<span class="library" title="binding of C char type">char</span>]$ JUDY_SL_MAXLEN+1; 
<span class="lineno" id=line193></span>       CString::strncpy (k,key.cstr, JUDY_SL_MAXLEN);
<span class="lineno" id=line194></span>       <span class="big_keyword" title="Define a mutable variable">var</span> <span class="small_keyword" title="value of function return used in post condition">result</span> = charp_get_lt x k;
<span class="lineno" id=line195></span>       <span class="small_keyword" title="match statement or expression">match</span> <span class="small_keyword" title="value of function return used in post condition">result</span> <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line196></span>       | Some v =&gt;
<span class="lineno" id=line197></span>         key = k.<span class="library" title="binding of C++ string type">string</span>;
<span class="lineno" id=line198></span>         free k; 
<span class="lineno" id=line199></span>         <span class="small_keyword" title="return">return</span> Some (key,v);
<span class="lineno" id=line200></span>       | #None=&gt;
<span class="lineno" id=line201></span>         free k;
<span class="lineno" id=line202></span>         <span class="small_keyword" title="return">return</span> None[<span class="library" title="binding of C++ string type">string</span> * T];
<span class="lineno" id=line203></span>       <span class="small_keyword" title="end a match statement or expression">endmatch</span> ;
<span class="lineno" id=line204></span>     }
<span class="lineno" id=line205></span>  
<span class="lineno" id=line206></span>     <span class="doccomment">Get the optional first key in the dictionary into</span>
<span class="lineno" id=line207></span>     <span class="doccomment">the supplied NTBS (unsafe!)</span>
<span class="lineno" id=line208></span>     <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> charp_first (x:strdict) (buffer:+<span class="library" title="binding of C char type">char</span>) = {
<span class="lineno" id=line209></span>       set(buffer,0,<span class="library" title="binding of C char type">char</span> <span class="fstring">""</span>);
<span class="lineno" id=line210></span>       <span class="small_keyword" title="return">return</span> x.charp_get_ge buffer;
<span class="lineno" id=line211></span>     }
<span class="lineno" id=line212></span>  
<span class="lineno" id=line213></span>     <span class="doccomment">Get the optional first key in the dictionary.</span>
<span class="lineno" id=line214></span>     <span class="big_keyword" title="Define a function with no side-effects">fun</span> first (x:strdict) : <span class="library" title="option type: Some x or None">opt</span>[<span class="library" title="binding of C++ string type">string</span> * T] =&gt; x.get_ge(<span class="fstring">""</span>);
<span class="lineno" id=line215></span>  
<span class="lineno" id=line216></span>     <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> Iterable[strdict, <span class="library" title="binding of C++ string type">string</span> * T] {
<span class="lineno" id=line217></span>       <span class="doccomment">Stream iterator scanning through all key value pairs</span>
<span class="lineno" id=line218></span>       <span class="doccomment">in the dictionary, in key order.</span>
<span class="lineno" id=line219></span>       <span class="big_keyword" title="Define a generator, a function with side-effects returning a value">gen</span> iterator (x:strdict) () : <span class="library" title="option type: Some x or None">opt</span>[<span class="library" title="binding of C++ string type">string</span> * T]  = {
<span class="lineno" id=line220></span>         <span class="big_keyword" title="Define a mutable variable">var</span> buffer : +<span class="library" title="binding of C char type">char</span> = array_alloc[<span class="library" title="binding of C char type">char</span>](JUDY_SL_MAXLEN+1);
<span class="lineno" id=line221></span>         <span class="big_keyword" title="Define a mutable variable">var</span> v = charp_first x buffer;
<span class="lineno" id=line222></span>         <span class="small_keyword" title="while loop">while</span> <span class="library" title="truth value">true</span> <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line223></span>           <span class="small_keyword" title="match statement or expression">match</span> v <span class="small_keyword" title="type-class constraint">with</span> 
<span class="lineno" id=line224></span>           | Some vv =&gt; <span class="small_keyword" title="return a value saving the current location for future resumption">yield</span> Some (<span class="library" title="binding of C++ string type">string</span> buffer, vv);
<span class="lineno" id=line225></span>           | #None =&gt; free buffer; <span class="small_keyword" title="return">return</span> None[<span class="library" title="binding of C++ string type">string</span> * T];
<span class="lineno" id=line226></span>           <span class="small_keyword" title="end a match statement or expression">endmatch</span>;
<span class="lineno" id=line227></span>           v = charp_get_gt x buffer;
<span class="lineno" id=line228></span>         <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line229></span>       }
<span class="lineno" id=line230></span>    }
<span class="lineno" id=line231></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> Streamable[strdict, <span class="library" title="binding of C++ string type">string</span> * T];
<span class="lineno" id=line232></span>  
<span class="lineno" id=line233></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span>[<span class="small_keyword" title="type-class constraint">with</span> Str[T]] Str[strdict]
<span class="lineno" id=line234></span>    {
<span class="lineno" id=line235></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="library" title="Convert a value to a string">str</span>(<span class="big_keyword" title="Define a mutable variable">var</span> x:strdict) : <span class="library" title="binding of C++ string type">string</span> = 
<span class="lineno" id=line236></span>      {
<span class="lineno" id=line237></span>        <span class="big_keyword" title="Define a mutable variable">var</span> s = <span class="fstring">"{"</span>;
<span class="lineno" id=line238></span>        <span class="small_keyword" title="match statement or expression">match</span> key,value <span class="small_keyword" title="membership operator, function mem">in</span> x.iterator <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line239></span>          <span class="big_keyword" title="Define a mutable variable">var</span> entry = key +<span class="fstring">"="</span> + <span class="library" title="Convert a value to a string">str</span> value;
<span class="lineno" id=line240></span>          <span class="small_keyword" title="conditional">if</span> s == <span class="fstring">"{"</span> <span class="small_keyword" title="imperative code begins">do</span> s+= entry; <span class="small_keyword" title="conditional">else</span> s+= <span class="fstring">", "</span>+ entry; <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line241></span>        <span class="small_keyword" title="end of body">done</span> 
<span class="lineno" id=line242></span>        s+=<span class="fstring">"}"</span>;
<span class="lineno" id=line243></span>        <span class="small_keyword" title="return">return</span> s;
<span class="lineno" id=line244></span>      }
<span class="lineno" id=line245></span>    }
<span class="lineno" id=line246></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> Str[strdict];
<span class="lineno" id=line247></span>  
<span class="lineno" id=line248></span>    <span class="big_keyword" title="Provide an instance of a typeclass">instance</span> Set[strdict,<span class="library" title="binding of C++ string type">string</span>] {
<span class="lineno" id=line249></span>      <span class="big_keyword" title="Define a function with no side-effects">fun</span> <span class="tex_symbol" title="\in">\(\in\)</span> (key:<span class="library" title="binding of C++ string type">string</span>, dict:strdict) =&gt; haskey dict key;
<span class="lineno" id=line250></span>    }
<span class="lineno" id=line251></span>    <span class="big_keyword" title="Inherit symbols into a module or typeclass">inherit</span> Set[strdict,<span class="library" title="binding of C++ string type">string</span>];
<span class="lineno" id=line252></span>  
<span class="lineno" id=line253></span>  }
<span class="lineno" id=line254></span>  
<span class="lineno" id=line255></span>  <span class="big_keyword" title="Open a module or class">open</span>[T] StrDict[T];
<span class="lineno" id=line256></span>  
<span class="lineno" id=line257></span>  <span class="comment">// map from string to list of strings</span>
<span class="lineno" id=line258></span>  <span class="big_keyword" title="Open a module or class">open</span> <span class="big_keyword" title="Define a type class">class</span> Str2StrList
<span class="lineno" id=line259></span>  {
<span class="lineno" id=line260></span>    <span class="big_keyword" title="Define an alias for a type expression">typedef</span> str2strlist = strdict[<span class="library" title="functional, singly linked list">list</span>[<span class="library" title="binding of C++ string type">string</span>]];
<span class="lineno" id=line261></span>    <span class="big_keyword" title="Define a value constructor or conversion operator for a type">ctor</span> str2strlist () =&gt; strdict[<span class="library" title="functional, singly linked list">list</span>[<span class="library" title="binding of C++ string type">string</span>]] ();
<span class="lineno" id=line262></span>  
<span class="lineno" id=line263></span>    <span class="comment">// transitive closure of a list of dependencies</span>
<span class="lineno" id=line264></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> trcls (x:str2strlist) (inp: <span class="library" title="functional, singly linked list">list</span>[<span class="library" title="binding of C++ string type">string</span>]) (out:<span class="library" title="functional, singly linked list">list</span>[<span class="library" title="binding of C++ string type">string</span>]) =&gt;
<span class="lineno" id=line265></span>      <span class="small_keyword" title="match statement or expression">match</span> inp <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line266></span>      | Empty =&gt; out
<span class="lineno" id=line267></span>      | head ! tail =&gt; 
<span class="lineno" id=line268></span>        <span class="small_keyword" title="conditional">if</span> <span class="small_keyword" title="logical negation">not</span> (head <span class="small_keyword" title="membership operator, function mem">in</span> out) <span class="small_keyword" title="conditional">then</span>
<span class="lineno" id=line269></span>          trcls x (tail + x.get_dflt (head, Empty[<span class="library" title="binding of C++ string type">string</span>])) (head ! out)
<span class="lineno" id=line270></span>        <span class="small_keyword" title="conditional">else</span>
<span class="lineno" id=line271></span>          trcls x tail out
<span class="lineno" id=line272></span>        <span class="small_keyword" title="conditional">endif</span>
<span class="lineno" id=line273></span>      <span class="small_keyword" title="end a match statement or expression">endmatch</span>
<span class="lineno" id=line274></span>    ;
<span class="lineno" id=line275></span>  
<span class="lineno" id=line276></span>    <span class="comment">// mutates the dictionary so each key maps to</span>
<span class="lineno" id=line277></span>    <span class="comment">// the transitive closure of its original value set</span>
<span class="lineno" id=line278></span>    <span class="comment">// the resulting value lists are unique lists even if</span>
<span class="lineno" id=line279></span>    <span class="comment">// the original list contained duplicates</span>
<span class="lineno" id=line280></span>    <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> transitive_closure (x:str2strlist) = {
<span class="lineno" id=line281></span>      <span class="small_keyword" title="match statement or expression">match</span> file,deps <span class="small_keyword" title="membership operator, function mem">in</span> x.iterator <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line282></span>        x.add file (trcls x deps Empty[<span class="library" title="binding of C++ string type">string</span>]);
<span class="lineno" id=line283></span>      <span class="small_keyword" title="end of body">done</span> 
<span class="lineno" id=line284></span>    }
<span class="lineno" id=line285></span>  
<span class="lineno" id=line286></span>  }
<span class="lineno" id=line287></span>  
<span class="lineno" id=line288></span>  
</pre></p></div><!--Main Content Body End-->

          </div> <!-- rightpanel contents end -->
          <hr>
        </span> <!-- rightpanel end -->

        <span id="panemover" style="cursor:col-resize;"
         onmousedown="dragStart(event, 'left', 'right'); return false;"
         onmousemove="drag(event, 'left', 'right');"
         onmouseout="dragRelease();"
         onmouseup="dragRelease();"
        >
        </span> <!-- panemover end -->
      </div> <!-- bottom panel end -->
    </div> <!-- container end -->
</body></html>

