<html><head>
<style type="text/css">
body {margin:3%; }
h1 {color:gray; font-size:120%;}
h2 {color:gray; font-size:105%;}
h3 {font-size:100%;}
h4 {font-size:95%;}
h5 {font-size:95%;}
span.fstring {color:darkblue; font-style:italic; }
span.comment {font-family:arial; color:blue; font-style:italic; }
span.doccomment {font-family:arial; color:green; font-style:italic; }
span.big_keyword {color:#FF1010; }
span.small_keyword {color:#802040; }
span.qualifier {color:#A02020; }
span.library {color:#A02000; }
span.ctor {color:#406020; }
span.hack {color:#66DD00; }
span.preproc {color:#005500; }
span.embedded_c{background-color:#DDDDDD; }
span.fpc_fieldname {color:#DD0000; }
span.lineno {color:#101010; background-color:#E0E0E0; font-size:80%; font-family:"courier",monospace; font-style:normal; }
pre.flxbg {background-color:#A0FFA0; color:black; padding:2px; box-shadow:5px 5px 2px #807080; }
pre.uncheckedflxbg {background-color:#D0D0D0; color:black; padding:2px; box-shadow:5px 5px 2px #807080; }
pre.cppbg {background-color:#80FF80; color:black; }
pre.prefmtbg {background-color:#D0D0D0; color:black; }
pre.expected {background-color:#E0FF80; color:black; }
pre.input {background-color:#E08080; color:black; }
pre.inclusion {background-color:#D070D0; color:black; }
code.inclusion {background-color:#D070D0; color:black; }
.obsolete { background-color:#FFEFEF; font-size: small; color:black; }
.future { background-color:#FF8080; font-size: small; color:black; }
.implementation_detail { background-color:#E0E0E0; font-size: small; color:black;  }
.bug { background-color:#FFE0E0; font-size: small; color:black; }
.fixed{ background-color:#FFE0E0; font-size: small; color:black; }
.done { background-color:#FFE0E0; font-size: small; color:black; }
.caveat { background-color:#FF8080; color:black; }
</style>
<title>Driver Embedding Technology</title></head><body>
<style>
body {margin:3%; font-family: sans-serif; }
h1 {color:black; font-size:120%; border-bottom: 2px solid #ddd; padding: 0 0 3px 0;}
h2 {color:#202020; font-size:105%;}
h3 {font-size:100%;}
h4 {font-size:95%;}
h5 {font-size:95%;}
span.fstring {color:darkblue; font-style:italic; }
span.comment {font-family:arial; color:blue; font-style:italic; }
span.doccomment {font-family:arial; color:green; font-style:italic; }
span.big_keyword {color:#FF1010; }
span.small_keyword {color:#802040; }
span.qualifier {color:#A02020; }
span.library {color:#A02000; }
span.ctor {color:#406020; }
span.hack {color:#66DD00; }
span.preproc {color:#005500; }
span.embedded_c{background-color:#DDDDDD; }
span.fpc_fieldname {color:#DD0000; }
span.lineno {color:#101010; background-color:#E0E0E0; font-size:80%; font-family:"courier",monospace; font-style:normal; }
pre { border: 1px solid #ccc; color: black; box-shadow:3px 3px 2px rgba(0,0,0,0.1); padding:2px; }
pre.flxbg {background-color:#C2FDC2; box-shadow:3px 3px 2px rgba(0,0,0,0.1) }
pre.uncheckedflxbg {background-color:#eee; box-shadow:3px 3px 2px rgba(0,0,0,0.1); }
pre.cppbg {background-color:#C2FDC2; }
pre.prefmtbg {background-color:#F1F1F1; }
pre.expected {background-color:hsla(74,94%,88%,1); }
pre.input {background-color:hsla(20,94%,88%,1); }
pre.inclusion {
    font-family: Arial;
    font-weight: normal;
    font-size: 0.9em;
    color: #555;
    border: none;
    box-shadow: none;
    text-align: right;
    margin: -7px 11px -12px 0;
    padding: 0;
    background-color:#fafafa;
}
code.inclusion {background-color:#D070D0; color:black; }
.obsolete { background-color:#FFEFEF; font-size: small; color:black; }
.future { background-color:#FF8080; font-size: small; color:black; }
.implementation_detail { background-color:#E0E0E0; font-size: small; color:black;  }
.bug { background-color:#FFE0E0; font-size: small; color:black; }
.fixed{ background-color:#FFE0E0; font-size: small; color:black; }
.done { background-color:#FFE0E0; font-size: small; color:black; }
.caveat { background-color:hsla(0,100%,91%,1); color:black; padding: 0.6em; }
.container {
  position: fixed;
  top:0px;
  left:0px;
  height : 100%;
  width: 100%;
  background-color: grey;
  margin: 0px;
  padding: 0px;
  border-width: 0px;
  color: #404040;
}
.maincontent {
  padding:4px;
  padding-left:8px;
  line-height:1.3em;
  color:#404040; background-color:#fafafa;
}
.maincontent h1 { margin-left:-8px; position: relative; font-family: georgia, serif; font-size: 1.8em; font-weight: normal; }
.maincontent h2 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent h3 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent h4 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent code { color:#902030; }
.toppanel {
  position:absolute; left:0px; top:0px; height:20px; right:0px;
  background-color: #e0e0e0;
}
.bottompanel {
  position:absolute; left:0px; top:22px; bottom:0px; right:0px;
  background-color: #fafafa;
  font-size:14px;
}
.leftpanel {
  position:absolute; left:0px; top:0px; bottom:0px; width: 150px;
  background-color: #eaeaea; overflow: auto;
}
.rightpanel {
  position:absolute; right: 0px; left:160px; top:0px; bottom: 0px;
  background-color: #fafafa; overflow: auto;
}
.divider {
  position:absolute; left: 150px; top:0px; bottom:0px;
  background-color: black; width:2px;
  box-shadow: 0 0 8px #000;
}

#panemover {
    position:absolute;
    left: 150px;
    width : 10px;
    top: 0px;
    bottom: 0px;
    opacity: 0.3;
    cursor:col-resize;
}

div.m {
    margin: 0px;
    padding:0px;
    border-width:2px;
    border-color: green;
}

div.m1 {
    background-color: #86E870;
    border-style:outset;
    border-color:#ccc;
    border-width:2px 0;
    font-size:90%;
    padding: 1px 0 2px 10px;
}

div.m2 {
    background-color: #70C070;
    padding-left:15px;
    padding-top:2px;
    border-style:outset;
    border-color:green;
    border-width:0 0 1px 0;
    font-size:80%;
}

div.m1:hover, div.m2:hover {
    background-color: white;
}

#leftmargintoc a {
    text-decoration: none;
    color: #404040;
}
</style>

<style>
div.m {
    margin: 0px;
    padding:0px;
    border-width:2px;
    border-color: green;
}

div.m1 {
    background-color: #86E870;
    border-style:outset;
    border-color:#ccc;
    border-width:2px 0;
    font-size:90%;
    padding: 1px 0 2px 10px;
}

div.m2 {
    background-color: #70C070;
    padding-left:15px;
    padding-top:2px;
    border-style:outset;
    border-color:green;
    border-width:0 0 1px 0;
    font-size:80%;
}

div.m1:hover, div.m2:hover {
    background-color: white;
}

#leftmargintoc a {
    text-decoration: none;
    color: #404040;
}


</style>

    <script async="true">
      function dragStart(e, left, right){
        document.getElementById("panemover").style.width="70%";
        document.getElementById("panemover").style.left="50px";
        mousedown = true;
        x = e.clientX
        dragOffsetLeft =
          document.getElementById(left).getBoundingClientRect().right -
          document.getElementById(left).getBoundingClientRect().left -
          x
        ;
        dragOffsetDivider= document.getElementById("divider").getBoundingClientRect().left - x;
        dragOffsetRight = document.getElementById(right).getBoundingClientRect().left - x;
      }
      function dragRelease(){
        document.getElementById('panemover').style.width = '10px';
        document.getElementById('panemover').style.left = document.getElementById('divider').offsetLeft + 'px';
        mousedown = false;
      }
      function drag(e, left, right){
        if(!mousedown){return}
        x = e.clientX
        tmpLeft = dragOffsetLeft + x
        tmpDivider= dragOffsetDivider + x
        tmpRight = dragOffsetRight + x
        document.getElementById(left).style.width= tmpLeft + 'px';
        document.getElementById("divider").style.left= tmpDivider + 'px';
        document.getElementById(right).style.left = tmpRight + 'px';
      };
    </script>

<script type="text/javascript">

  function mexpand(id)
  {
    var n = document.getElementById(id).style;
    n.display = "block";
  }

  function mcollapse(id)
  {
    var n = document.getElementById(id).style;
    n.display = "none";
  }

  var counter_max = 0;
  function mshow(id,loc)
  {
    var i;
    for(i=1; i<=counter_max; ++i)
      mcollapse("menu"+String(i));
    mexpand(id);
    window.location.replace(loc);
  }
</script>

<script type="text/javascript">

function expand(but,id)
{
  var n = document.getElementById(id).style;
  var button = document.getElementById(but);
  button.src = "/share/src/web/images/minus.gif";
  button.alt = "-";
  n.display = "block";
}
function collapse(but,id)
{
  var n = document.getElementById(id).style;
  var button = document.getElementById(but);
  button.src = "/share/src/web/images/plus.gif";
  button.alt = "+";
  n.display = "none";
}
function toggle(button,id)
{
  var n = document.getElementById(id).style;
  if (n.display == "none")
  {
    button.src = "/share/src/web/images/minus.gif";
    button.alt = "-";
    n.display = "block";
  }
  else
  {
    button.src = "/share/src/web/images/plus.gif";
    button.alt = "+";
    n.display = "none";
  }
}
var allbuttons = [
"Embedding",
"The <code>flx_config</code> class.",
"The <code>flx_world</code> class."
];
function expand_all(dummy)
{
  for (i in allbuttons)
  {
    expand(allbuttons[i], allbuttons[i]+"_d");
  }
}
function collapse_all(dummy)
{
  for (i in allbuttons)
  {
    collapse(allbuttons[i], allbuttons[i]+"_d");
  }
}
</script>

<script>
function mouseover(id)
{
  var elt = document.getElementById(id);
  elt.style.display="none";
  var elt2 = document.getElementById(id+"_mo");
  elt2.style.display="inline";
}

function mouseout(id)
{
  var elt = document.getElementById(id+"_mo");
  elt.style.display="none";
  var elt2 = document.getElementById(id);
  elt2.style.display="inline";
}

</script>
<script> function nop(dummy) {} </script>
    <div class="container">
      <div class="toppanel">
    <!--Main Content top navbar-->
<span style="position:relative; bottom:6px"
  onmouseover="mouseover('expand')"
  onmouseout="mouseout('expand')"
  onclick="expand_all('expand')"
  ><span id="expand"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:blue;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Expand</text></svg></span><span id="expand_mo" style="display:none"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:red;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Expand</text></svg></span></span><span style="position:relative; bottom:6px"
  onmouseover="mouseover('collapse')"
  onmouseout="mouseout('collapse')"
  onclick="collapse_all('collapse')"
  ><span id="collapse"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:blue;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Collapse</text></svg></span><span id="collapse_mo" style="display:none"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:red;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Collapse</text></svg></span></span>    <!--Main Content top navbar End-->

      </div> <!-- toppanel end -->
      <div class="bottompanel">
        <span id="divider" class="divider"></span>

        <span id="left" class="leftpanel" >
          <div class="menucontent">
  <!--Left Margin Toc-->
  <div id="leftmargintoc">
    <!--Left Margin Toc Main Contents-->
      <div class=m1 onclick="mshow('menu1','#Embedding_h')"> <a href="#Embedding_h">Embedding</a></div>
      <div class=sm id=menu1>
      <div class=m2><a href="#The_<code>flx_config</code>_class._h">The <code>flx_config</code> class.</a></div>
      <div class=m2><a href="#The_<code>flx_world</code>_class._h">The <code>flx_world</code> class.</a></div>
      </div>
    <script>counter_max=1;</script>
  </div>
  <!--End Left Margin Toc-->

          </div> <!-- leftpanel contents end -->
        </span> <!-- leftpanel end -->

        <span id="right" class="rightpanel">
          <div class="maincontent">
<!--Main Content Body-->
<h1 id='Embedding_h'><img src='/share/src/web/images/minus.gif' id='Embedding' onclick='toggle(this,"Embedding_d")' alt='+'/> 1 Embedding</h1><div id='Embedding_d' style='display:block'>
<p>This technology is designed to allow Felix to be embedded in any
C or C++ program or library.
</p><p>The embedding library code is used by the core drivers.
</p><h2 id='The_<code>flx_config</code>_class._h'><img src='/share/src/web/images/minus.gif' id='The <code>flx_config</code> class.' onclick='toggle(this,"The_<code>flx_config</code>_class._d")' alt='+'/> 1.1 The <code>flx_config</code> class.</h2><div id='The_<code>flx_config</code>_class._d' style='display:block'>
<p>The <code>flx_config</code> class is used to store configuration
data used by subsequent initialisation steps
used to initiate a Felix world.
</p><pre class='inclusion'>
share/lib/rtl/flx_world_config.hpp</pre>
<p><pre class='cppbg'>
#<span class="preproc">ifndef</span> __flx_world_config_H_
#<span class="preproc">define</span> __flx_world_config_H_

#<span class="preproc">include</span> <span class="fstring">"flx_rtl_config.hpp"</span>
#<span class="preproc">include</span> <span class="fstring">"flx_gc.hpp"</span>
#<span class="preproc">include</span> <span class="fstring">"flx_collector.hpp"</span>
#<span class="preproc">include</span> <span class="fstring">"flx_dynlink.hpp"</span>

<span class="comment">// for async_sched
</span>#<span class="preproc">include</span> <span class="fstring">&lt;list&gt;</span>
#<span class="preproc">include</span> <span class="fstring">"flx_async.hpp"</span>
#<span class="preproc">include</span> <span class="fstring">"flx_sync.hpp"</span>

<span class="big_keyword">namespace</span> flx { <span class="big_keyword">namespace</span> run {
<span class="big_keyword">class</span> RTL_EXTERN flx_config {
<span class="qualifier">public</span>:
  bool  debug;

  bool debug_threads;
  bool debug_allocations;
  bool debug_collections;
  bool report_collections;
  bool report_gcstats;

  bool debug_driver;
  bool finalise;

  size_t gc_freq;
  size_t min_mem;
  size_t max_mem;
  <span class="qualifier">int</span> gcthreads;

  <span class="qualifier">double</span> free_factor;

  bool allow_collection_anywhere;

  bool <span class="qualifier">static</span>_link;
  <span class="qualifier">char</span> *filename; <span class="comment">// expected to live forever
</span>  <span class="qualifier">char</span> **flx_argv;
  <span class="qualifier">int</span> flx_argc;

  <span class="comment">// TODO: fn up in macro area
</span>  <span class="qualifier">int</span> init(<span class="qualifier">int</span> argc, <span class="qualifier">char</span> **argv);

<span class="comment">// interface for drivers. there's more, create_frame, etc
</span>  create_async_hooker_t *ptr_create_async_hooker=nullptr;

  <span class="big_keyword">typedef</span> ::flx::dynlink::flx_dynlink_t *(*link_library_t)(flx_config *c, ::flx::gc::generic::gc_profile_t*);
  <span class="big_keyword">typedef</span> <span class="qualifier">void</span> (*init_ptr_create_async_hooker_t)(flx_config *, bool debug_driver);
  <span class="big_keyword">typedef</span> <span class="qualifier">int</span> (*get_flx_args_config_t)(<span class="qualifier">int</span> argc, <span class="qualifier">char</span> **argv, flx_config* c);

  link_library_t link_library;
  init_ptr_create_async_hooker_t init_ptr_create_async_hooker;
  get_flx_args_config_t get_flx_args_config;

  flx_config (link_library_t, init_ptr_create_async_hooker_t, get_flx_args_config_t); 


};
}} <span class="comment">// namespaces
</span>#<span class="preproc">endif</span>
</pre></p><pre class='inclusion'>
share/src/rtl/flx_world_config.cpp</pre>
<p><pre class='cppbg'>
#<span class="preproc">include</span> <span class="fstring">"flx_world_config.hpp"</span>
#<span class="preproc">include</span> <span class="fstring">&lt;cstdlib&gt;</span>

<span class="qualifier">static</span> <span class="qualifier">double</span> egetv(<span class="qualifier">char</span> <span class="qualifier">const</span> *name, <span class="qualifier">double</span> dflt)
{
  <span class="qualifier">char</span> *env = ::<span class="small_keyword">std</span>::getenv(name);
  <span class="qualifier">double</span> val = env?::<span class="small_keyword">std</span>::atof(env):dflt;
  <span class="small_keyword">return</span> val;
}

<span class="big_keyword">namespace</span> flx { <span class="big_keyword">namespace</span> run {

<span class="comment">// =================================================================
</span><span class="comment">// flx_config: Constructor
</span><span class="comment">// =================================================================
</span>flx_config::flx_config 
(
  link_library_t link_library_arg,
  init_ptr_create_async_hooker_t init_ptr_create_async_hooker_arg,
  get_flx_args_config_t get_flx_args_config_arg
) :
  link_library(link_library_arg),
  init_ptr_create_async_hooker(init_ptr_create_async_hooker_arg),
  get_flx_args_config(get_flx_args_config_arg)
{
  <span class="comment">//fprintf(stderr,"flx_config constrfuctor\n");
</span>}

<span class="comment">// =================================================================
</span><span class="comment">// flx_config: Initialiser
</span><span class="comment">// =================================================================
</span>
<span class="qualifier">int</span>
flx_config::init(<span class="qualifier">int</span> argc, <span class="qualifier">char</span> **argv) {
  <span class="small_keyword">if</span>(get_flx_args_config(argc, argv, this)) <span class="small_keyword">return</span> 1;

  debug = (bool)egetv(<span class="fstring">"FLX_DEBUG"</span>, debug);
  <span class="small_keyword">if</span> (debug) {
    fprintf(stderr,
      <span class="fstring">"[FLX_DEBUG] Debug enabled for %s link program\n"</span>,
      <span class="qualifier">static</span>_link ? <span class="fstring">"static"</span> : <span class="fstring">"dynamic"</span>);
  }

  debug_threads = (bool)egetv(<span class="fstring">"FLX_DEBUG_THREADS"</span>, debug);
  <span class="small_keyword">if</span> (debug_threads) {
    fprintf(stderr, <span class="fstring">"[FLX_DEBUG_THREADS] Threads debug enabled\n"</span>);
  }

  debug_allocations = (bool)egetv(<span class="fstring">"FLX_DEBUG_ALLOCATIONS"</span>, debug);
  <span class="small_keyword">if</span> (debug_allocations) {
    fprintf(stderr, <span class="fstring">"[FLX_DEBUG_ALLOCATIONS] Allocation debug enabled\n"</span>);
  }

  debug_collections = (bool)egetv(<span class="fstring">"FLX_DEBUG_COLLECTIONS"</span>, debug);
  <span class="small_keyword">if</span> (debug_collections)
  {
    fprintf(stderr, <span class="fstring">"[FLX_DEBUG_COLLECTIONS] Collection debug enabled\n"</span>);
  }

  report_collections = (bool)egetv(<span class="fstring">"FLX_REPORT_COLLECTIONS"</span>, debug);
  <span class="small_keyword">if</span> (report_collections)
  {
    fprintf(stderr, <span class="fstring">"[FLX_REPORT_COLLECTIONS] Collection report enabled\n"</span>);
  }

  report_gcstats = (bool)egetv(<span class="fstring">"FLX_REPORT_GCSTATS"</span>, report_collections);
  <span class="small_keyword">if</span> (report_collections)
  {
    fprintf(stderr, <span class="fstring">"[FLX_REPORT_GCSTATS] GC statistics report enabled\n"</span>);
  }


  debug_driver = (bool)egetv(<span class="fstring">"FLX_DEBUG_DRIVER"</span>, debug);
  <span class="small_keyword">if</span> (debug_driver)
  {
    fprintf(stderr, <span class="fstring">"[FLX_DEBUG_DRIVER] Driver debug enabled\n"</span>);
  }

  finalise = (bool)egetv(<span class="fstring">"FLX_FINALISE"</span>, 0);
  <span class="small_keyword">if</span> (debug)
    fprintf(stderr,
      <span class="fstring">"[FLX_FINALISE] Finalisation %s\n"</span>, finalise ? <span class="fstring">"Enabled"</span> : <span class="fstring">"Disabled"</span>);

  <span class="comment">// default collection frequency is 1000 interations
</span>  gc_freq = (size_t)egetv(<span class="fstring">"FLX_GC_FREQ"</span>, 1000);
  <span class="small_keyword">if</span> (gc_freq &lt; 1) gc_freq = 1;
  <span class="small_keyword">if</span> (debug)
    fprintf(stderr, <span class="fstring">"[FLX_GC_FREQ] call gc every %zu iterations\n"</span>, gc_freq);

  <span class="comment">// default min mem is 10 Meg
</span>  min_mem = (size_t)(egetv(<span class="fstring">"FLX_MIN_MEM"</span>, 10) * 1000000.0);
  <span class="small_keyword">if</span> (debug)
    fprintf(stderr, <span class="fstring">"[FLX_MIN_MEM] call gc only if more than %zu Meg heap used\n"</span>, min_mem/1000000);

  <span class="comment">// default max mem is unlimited
</span>  max_mem = (size_t)(egetv(<span class="fstring">"FLX_MAX_MEM"</span>, 0) * 1000000.0);
  <span class="small_keyword">if</span> (max_mem == 0) max_mem = (size_t)-1;
  <span class="small_keyword">if</span> (debug)
    fprintf(stderr, <span class="fstring">"[FLX_MAX_MEM] terminate if more than %zu Meg heap used\n"</span>, max_mem/1000000);

  <span class="comment">// default free factor is 10%, this is also the minimum allowed
</span>  free_factor = egetv(<span class="fstring">"FLX_FREE_FACTOR"</span>, 1.1);
  <span class="small_keyword">if</span> (free_factor &lt; 1.1) free_factor = 1.1;
  <span class="small_keyword">if</span> (debug)
    fprintf(stderr, <span class="fstring">"[FLX_FREE_FACTOR] reset gc trigger %4.2f times heap used after collection\n"</span>, free_factor);

  <span class="comment">// experimental flag to allow collection anywhere
</span>  <span class="comment">// later, we default this one to true if we can
</span>  <span class="comment">// find all the thread stacks, which should be possible
</span>  <span class="comment">// with gcc and probably msvc++
</span>
  allow_collection_anywhere = (bool)egetv(<span class="fstring">"FLX_ALLOW_COLLECTION_ANYWHERE"</span>, 1);
  <span class="small_keyword">if</span> (debug)
    fprintf(stderr, <span class="fstring">"[FLX_ALLOW_COLLECTION_ANYWHERE] %s\n"</span>, allow_collection_anywhere ? <span class="fstring">"True"</span> : <span class="fstring">"False"</span>);

  gcthreads = (<span class="qualifier">int</span>)egetv(<span class="fstring">"FLX_GCTHREADS"</span>,0);
  <span class="small_keyword">if</span> (debug)
    fprintf(stderr, <span class="fstring">"[FLX_GCTHREADS] %d\n"</span>,gcthreads);

  <span class="small_keyword">if</span> (debug) {
    <span class="small_keyword">for</span> (<span class="qualifier">int</span> i=0; i&lt;flx_argc; ++i)
      fprintf(stderr, <span class="fstring">"flx_argv[%d]-&gt;%s\n"</span>, i, flx_argv[i]);
  }
  <span class="small_keyword">return</span> 0;
}

}} <span class="comment">// namespaces
</span>
</pre></p></div><h2 id='The_<code>flx_world</code>_class._h'><img src='/share/src/web/images/minus.gif' id='The <code>flx_world</code> class.' onclick='toggle(this,"The_<code>flx_world</code>_class._d")' alt='+'/> 1.2 The <code>flx_world</code> class.</h2><div id='The_<code>flx_world</code>_class._d' style='display:block'>
<p>Objects of the <code>flx_world</code> class are used to represent
a Felix world.
</p><pre class='inclusion'>
share/lib/rtl/flx_world.hpp</pre>
<p><pre class='cppbg'>
#<span class="preproc">ifndef</span> __flx_world_H_
#<span class="preproc">define</span> __flx_world_H_
#<span class="preproc">include</span> <span class="fstring">"flx_rtl_config.hpp"</span>

#<span class="preproc">include</span> <span class="fstring">"flx_gc.hpp"</span>
#<span class="preproc">include</span> <span class="fstring">"flx_collector.hpp"</span>
#<span class="preproc">include</span> <span class="fstring">"flx_dynlink.hpp"</span>

<span class="comment">// for async_sched
</span>#<span class="preproc">include</span> <span class="fstring">&lt;list&gt;</span>
#<span class="preproc">include</span> <span class="fstring">"flx_async.hpp"</span>
#<span class="preproc">include</span> <span class="fstring">"flx_sync.hpp"</span>
#<span class="preproc">include</span> <span class="fstring">"flx_world_config.hpp"</span>
#<span class="preproc">include</span> <span class="fstring">"flx_async_world.hpp"</span>

<span class="big_keyword">namespace</span> flx { <span class="big_keyword">namespace</span> run {

<span class="big_keyword">class</span> RTL_EXTERN flx_world {
  bool debug;
  bool debug_driver;

  ::flx::gc::generic::allocator_t *allocator;

  ::flx::gc::collector::flx_collector_t *collector;

  ::flx::gc::generic::gc_profile_t *gcp;

  ::flx::dynlink::flx_dynlink_t *library;
  ::flx::dynlink::flx_libinst_t *instance;

  <span class="big_keyword">struct</span> async_sched *async_scheduler;

  <span class="qualifier">int</span> explicit_dtor();
<span class="qualifier">public</span>:
  flx_config *c;
  flx_world(flx_config *); 
  <span class="qualifier">int</span> setup(<span class="qualifier">int</span> argc, <span class="qualifier">char</span> **argv);

  <span class="qualifier">int</span> teardown();

  <span class="comment">// add/remove (current pthread, stack pointer) for garbage collection
</span>  <span class="qualifier">void</span> begin_flx_code();
  <span class="qualifier">void</span> end_flx_code();

  <span class="comment">// returns number of pending operations scheduled by svc_general
</span>  <span class="comment">// return error code < 0 otherwise
</span>  <span class="comment">// catches all known exceptions
</span>  <span class="qualifier">int</span> run();

  <span class="qualifier">void</span>* ptf()<span class="qualifier">const</span> { <span class="small_keyword">return</span> instance-&gt;thread_frame; }	<span class="comment">// for creating con_t
</span>
  async_hooker *create_demux();

  <span class="qualifier">void</span> spawn_fthread(::flx::rtl::con_t *top);

  <span class="qualifier">void</span> external_multi_swrite (::flx::rtl::schannel_t *chan, <span class="qualifier">void</span> *data);

  async_sched *get_async_scheduler()<span class="qualifier">const</span> { <span class="small_keyword">return</span> async_scheduler; }
  sync_sched *get_sync_scheduler()<span class="qualifier">const</span> { <span class="small_keyword">return</span> async_scheduler-&gt;ss; }
};

<span class="big_keyword">struct</span> base_thread_frame_t {
  <span class="qualifier">int</span> argc;
  <span class="qualifier">char</span> **argv;
  FILE *flx_stdin;
  FILE *flx_stdout;
  FILE *flx_stderr;
  ::flx::gc::generic::gc_profile_t *gcp;
  flx_world *world;
};


}} <span class="comment">// namespaces
</span>#<span class="preproc">endif</span> <span class="comment">//__flx_world_H_
</span></pre></p><pre class='inclusion'>
share/src/rtl/flx_world.cpp</pre>
<p><pre class='cppbg'>
#<span class="preproc">include</span> <span class="fstring">"flx_world.hpp"</span>
#<span class="preproc">include</span> <span class="fstring">"flx_eh.hpp"</span>
#<span class="preproc">include</span> <span class="fstring">"flx_ts_collector.hpp"</span>
#<span class="preproc">include</span> <span class="fstring">"flx_rtl.hpp"</span>

using <span class="big_keyword">namespace</span> ::<span class="small_keyword">std</span>;
using <span class="big_keyword">namespace</span> ::flx::rtl;
using <span class="big_keyword">namespace</span> ::flx::pthread;
using <span class="big_keyword">namespace</span> ::flx::run;

<span class="big_keyword">namespace</span> flx { <span class="big_keyword">namespace</span> run {

<span class="comment">// =================================================================
</span><span class="comment">// flx_world : final cleanup
</span><span class="comment">// =================================================================
</span>
<span class="comment">// terminates process!
</span><span class="comment">// Not called by default (let the OS clean up)
</span>
<span class="qualifier">static</span> <span class="qualifier">int</span> <span class="small_keyword">do</span>_final_cleanup(
  bool debug_driver,
  flx::gc::generic::gc_profile_t *gcp,
  ::flx::dynlink::flx_dynlink_t *library,
  ::flx::dynlink::flx_libinst_t *instance
)
{
  flx::gc::generic::collector_t *collector = gcp-&gt;collector;

  <span class="comment">// garbage collect application objects
</span>  {
    <span class="small_keyword">if</span> (debug_driver || gcp-&gt;debug_collections)
      fprintf(stderr, <span class="fstring">"[do_final_cleanup] Finalisation: pass 1 Data collection starts ..\n"</span>);

    size_t n = collector-&gt;collect();
    size_t a = collector-&gt;get_allocation_count();

    <span class="small_keyword">if</span> (debug_driver || gcp-&gt;debug_collections)
      fprintf(stderr, <span class="fstring">"[do_final_cleanup] flx_run collected %zu objects, %zu left\n"</span>, n, a);
  }

  <span class="comment">// garbage collect system objects
</span>  {
    <span class="small_keyword">if</span> (debug_driver || gcp-&gt;debug_collections)
      fprintf(stderr, <span class="fstring">"[do_final_cleanup] Finalisation: pass 2 Final collection starts ..\n"</span>);

    collector-&gt;free_all_mem();
    size_t a = collector-&gt;get_allocation_count();

    <span class="small_keyword">if</span> (debug_driver || gcp-&gt;debug_collections)
      fprintf(stderr, <span class="fstring">"[do_final_cleanup] Remaining %zu objects (should be 0)\n"</span>, a);

    <span class="small_keyword">if</span> (a != 0){
      fprintf(stderr, <span class="fstring">"[do_final_cleanup] flx_run %zu uncollected objects, should be zero!! return code 5\n"</span>, a);
      <span class="small_keyword">return</span> 5;
    }
  }

  <span class="small_keyword">if</span> (debug_driver)
    fprintf(stderr, <span class="fstring">"[do_final_cleanup] exit 0\n"</span>);

  <span class="small_keyword">return</span> 0;
}

<span class="qualifier">static</span> <span class="qualifier">void</span> *get_stack_pointer() { <span class="qualifier">void</span> *x=(<span class="qualifier">void</span>*)&amp;x; <span class="small_keyword">return</span> x; }

<span class="comment">// =================================================================
</span><span class="comment">// flx_world : run mainline pthread constructor
</span><span class="comment">// =================================================================
</span><span class="comment">// RUN A FELIX INSTANCE IN THE CURRENT PTHREAD
</span><span class="comment">//
</span><span class="comment">// CURRENTLY ONLY CALLED ONCE IN MAIN THREAD
</span><span class="comment">// RETURNS A LIST OF FTHREADS
</span><span class="comment">// 
</span>
<span class="qualifier">static</span> fthread_list*
run_felix_pthread_ctor(
  flx::gc::generic::gc_profile_t *gcp,
  ::flx::dynlink::flx_libinst_t *instance)
{
  <span class="comment">//fprintf(stderr, "run_felix_pthread_ctor -- the MAIN THREAD: library instance: %p\n", instance);
</span>  flx::gc::generic::collector_t *collector = gcp-&gt;collector;
  fthread_list *active = new(*gcp, ::flx::run::fthread_list_ptr_map,false)  fthread_list(gcp);

  {
    con_t *top = instance-&gt;main_proc;
    <span class="comment">//fprintf(stderr, "  ** MAIN THREAD: flx_main entry point : %p\n", top);
</span>    <span class="small_keyword">if</span> (top)
    {
      fthread_t *flx_main = new (*gcp, _fthread_ptr_map, false) fthread_t(top, active);
      active-&gt;push_front(flx_main);
    }
  }

  {
    con_t *top = instance-&gt;start_proc;
    <span class="comment">//fprintf(stderr, "  ** MAIN THREAD: flx_start (initialisation) entry point : %p\n", top);
</span>    <span class="small_keyword">if</span> (top)
    {
      fthread_t *ft = new (*gcp, _fthread_ptr_map, false) fthread_t(top, active);
      active-&gt;push_front(ft);
    }
  }
  <span class="small_keyword">return</span> active;
}

<span class="comment">// =================================================================
</span><span class="comment">// flx_world : run mainline pthread destructor
</span><span class="comment">// Joins all threads to main thread
</span><span class="comment">// Detaches Felix instance by unrooting it
</span><span class="comment">// Collects all garbage if finalisation set
</span><span class="comment">// =================================================================
</span><span class="qualifier">static</span> <span class="qualifier">void</span> run_felix_pthread_dtor(
  bool debug_driver,
  flx::gc::generic::gc_profile_t *gcp,
  ::flx::dynlink::flx_dynlink_t *library,
  ::flx::dynlink::flx_libinst_t *instance
)
{
  <span class="small_keyword">if</span> (debug_driver)
    fprintf(stderr, <span class="fstring">"[run_felix_pthread_dtor] MAIN THREAD FINISHED: waiting for other threads\n"</span>);

  gcp-&gt;collector-&gt;get_thread_control()-&gt;join_all();

  <span class="small_keyword">if</span> (debug_driver) 
    fprintf(stderr, <span class="fstring">"[run_felix_pthread_dtor] ALL THREADS DEAD: mainline cleanup!\n"</span>);

  <span class="small_keyword">if</span> (debug_driver) {
    flx::gc::generic::collector_t *collector = gcp-&gt;collector;

    size_t uncollected = collector-&gt;get_allocation_count();
    size_t roots = collector-&gt;get_root_count();
    fprintf(stderr,
      <span class="fstring">"[run_felix_pthread_dtor] program finished, %zu collections, %zu uncollected objects, roots %zu\n"</span>,
      gcp-&gt;collections, uncollected, roots);
  }
  gcp-&gt;collector-&gt;remove_root(instance);

  <span class="small_keyword">if</span> (gcp-&gt;finalise)
    (<span class="qualifier">void</span>)<span class="small_keyword">do</span>_final_cleanup(debug_driver, gcp, library, instance);

  <span class="small_keyword">if</span> (debug_driver) 
    fprintf(stderr, <span class="fstring">"[run_felix_pthread_dtor] mainline cleanup complete, exit\n"</span>);
   
}

<span class="comment">// =================================================================
</span><span class="comment">// flx_world : Constructor
</span><span class="comment">// attach flx_config and exit
</span><span class="comment">// =================================================================
</span>flx_world::flx_world(flx_config *c_arg) : c(c_arg) {}

<span class="comment">// =================================================================
</span><span class="comment">// flx_world : setup
</span><span class="comment">// 
</span><span class="comment">// This is the actual world constructor. It is separated from
</span><span class="comment">// the C++ constructor to allow a pointer to the world to be stashed
</span><span class="comment">// by the user somewhere, prior to actually initialising Felix
</span><span class="comment">//
</span><span class="comment">// =================================================================
</span><span class="comment">//
</span><span class="comment">// attach flx_config and exit
</span><span class="comment">// calls init passing command line arguments
</span><span class="comment">// exits if init returns non-zero
</span><span class="comment">// otherwise, sets up flx_world data based on flx_config attached by constructor
</span><span class="comment">// creates allocator
</span><span class="comment">// creates thread control object 
</span><span class="comment">// creates garbage collector
</span><span class="comment">// creates collector profile object
</span><span class="comment">// links to the main library control object and makes it a root
</span><span class="comment">// adds current thread to thread control object 
</span><span class="comment">// creates instance of library and makes it a root:
</span><span class="comment">//   *  loads the dll (if using dynamic loading)
</span><span class="comment">//   *  finds the thread frame constructor in the library
</span><span class="comment">//   *  invokes the thread frame constructor to create the thread frame
</span><span class="comment">//   *  initialises the common part of the thread frame (with command line args etc)
</span><span class="comment">// removes thread from thread control object
</span><span class="comment">// sets up synchronous scheduler (by calling run_felix_pthread_ctor):
</span><span class="comment">//   * finds primary entry point
</span><span class="comment">//   * creates initial continuation (in a suspended state)
</span><span class="comment">//   * create initial fibre from that continuation
</span><span class="comment">//   * creates sync scheduler list and initialises it with initial fibre 
</span><span class="comment">// creates async scheduler
</span><span class="comment">// NOTE: does not run scheduler(s)
</span><span class="comment">// =================================================================
</span>
<span class="qualifier">int</span> flx_world::setup(<span class="qualifier">int</span> argc, <span class="qualifier">char</span> **argv) {
  <span class="qualifier">int</span> res;
  <span class="small_keyword">if</span>((res = c-&gt;init(argc, argv) != 0)) <span class="small_keyword">return</span> res;

  debug = c-&gt;debug;
  debug_driver = c-&gt;debug_driver;

  <span class="small_keyword">if</span>(debug_driver)
    fprintf(stderr, <span class="fstring">"[flx_world %p: setup]\n"</span>, this);

  allocator = new flx::gc::collector::malloc_free();
  <span class="small_keyword">if</span>(debug_driver)
    fprintf(stderr, <span class="fstring">"[flx_world: setup] Created allocator %p\n"</span>, allocator);
  allocator-&gt;set_debug(c-&gt;debug_allocations);

  <span class="qualifier">char</span> *tracecmd = getenv(<span class="fstring">"FLX_TRACE_ALLOCATIONS"</span>);
  <span class="small_keyword">if</span>(tracecmd &amp;&amp; strlen(tracecmd)&gt;0) {
     FILE *f = fopen(tracecmd,<span class="fstring">"w"</span>);
     <span class="small_keyword">if</span>(f) {
       fprintf(stderr, <span class="fstring">"Allocation tracing active, file = %s\n"</span>,tracecmd);
       allocator = new flx::gc::collector::tracing_allocator(f,allocator);
     }
     else 
       fprintf(stderr, <span class="fstring">"Unable to open allocation trace file %s for output (ignored)\n"</span>,tracecmd);
  }

  <span class="comment">// previous direct ctor scope ended at closing brace of FLX_MAIN
</span>  <span class="comment">// but delete can probably be moved up after collector delete (also used by explicit_dtor)
</span>  ::flx::pthread::thread_control_t *thread_control = new ::flx::pthread::thread_control_t(c-&gt;debug_threads);
  <span class="small_keyword">if</span>(debug_driver)
    fprintf(stderr, <span class="fstring">"[flx_world: setup] Created thread control object  %p\n"</span>, thread_control);

  <span class="comment">// NB: !FLX_SUPPORT_ASYNC refers to async IO, hence ts still needed thanks to flx pthreads
</span>  FILE *tracefile = NULL;
  {
    <span class="qualifier">char</span> *tracecmd = getenv(<span class="fstring">"FLX_TRACE_GC"</span>);
    <span class="small_keyword">if</span>(tracecmd &amp;&amp; strlen(tracecmd)&gt;0) {
      tracefile = fopen(tracecmd,<span class="fstring">"w"</span>);
      <span class="small_keyword">if</span>(tracefile) 
        fprintf(stderr, <span class="fstring">"GC tracing active, file = %s\n"</span>,tracecmd);
    }
  }

  <span class="comment">// Create Garbage Collector
</span>  collector = new flx::gc::collector::flx_ts_collector_t(
    allocator, 
    thread_control, 
    c-&gt;gcthreads, tracefile
  );
  collector-&gt;set_debug(c-&gt;debug_collections, c-&gt;report_gcstats);
  <span class="small_keyword">if</span>(debug_driver)
    fprintf(stderr, <span class="fstring">"[flx_world: setup] Created ts collector %p\n"</span>, collector);

  <span class="comment">// Create Collector Profile
</span>  gcp = new flx::gc::generic::gc_profile_t(
    c-&gt;debug_driver,
    c-&gt;debug_allocations,
    c-&gt;debug_collections,
    c-&gt;report_collections,
    c-&gt;report_gcstats,
    c-&gt;allow_collection_anywhere,
    c-&gt;gc_freq,
    c-&gt;min_mem,
    c-&gt;max_mem,
    c-&gt;free_factor,
    c-&gt;finalise,
    collector
  );

  <span class="small_keyword">if</span>(debug_driver)
    fprintf(stderr, <span class="fstring">"[flx_world: setup] Created gc profile object gcp=%p\n"</span>,gcp);

  library = c-&gt;link_library(c,gcp);
  collector-&gt;add_root (library);

  <span class="small_keyword">if</span>(debug_driver)
    fprintf(stderr, <span class="fstring">"[flx_world: setup] Created library object %p\n"</span>, library);

  <span class="small_keyword">if</span> (debug_driver)
  {
    fprintf(stderr, <span class="fstring">"[flx_world:setup] flx_run driver begins argv[0]=%s\n"</span>, c-&gt;flx_argv[0]);
    <span class="small_keyword">for</span> (<span class="qualifier">int</span> i=1; i&lt;argc-1; ++i)
      fprintf(stderr, <span class="fstring">"[flx_world:setup]                       argv[%d]=%s\n"</span>, i,c-&gt;flx_argv[i]);
  }

  <span class="comment">// flx_libinst_t::create can run code, so add thread to avoid world_stop abort
</span>  thread_control-&gt;add_thread(get_stack_pointer(), ::flx::pthread::mainline);

  <span class="comment">// Create the usercode driver instance
</span>  <span class="comment">// NB: seems to destroy()ed in do_final_cleanup
</span>  instance = new (*gcp, ::flx::dynlink::flx_libinst_ptr_map, false) ::flx::dynlink::flx_libinst_t(debug_driver);
  collector-&gt;add_root(instance);
  instance-&gt;create(
    library,
    gcp,
    this,
    c-&gt;flx_argc,
    c-&gt;flx_argv,
    stdin,
    stdout,
    stderr,
    debug_driver);

  thread_control-&gt;remove_thread();

  <span class="small_keyword">if</span> (debug_driver) {
    fprintf(stderr, <span class="fstring">"[flx_world:setup] loaded library %s at %p\n"</span>, c-&gt;filename, library-&gt;library);
    fprintf(stderr, <span class="fstring">"[flx_world:setup] thread frame at %p\n"</span>, instance-&gt;thread_frame);
    fprintf(stderr, <span class="fstring">"[flx_world:setup] initial continuation at %p\n"</span>, instance-&gt;start_proc);
    fprintf(stderr, <span class="fstring">"[flx_world:setup] main continuation at %p\n"</span>, instance-&gt;main_proc);
    fprintf(stderr, <span class="fstring">"[flx_world:setup] creating async scheduler\n"</span>);
  }

  <span class="comment">// FIXME: this doesn't belong in this subroutine
</span>  <span class="comment">// The above stuff sets universal variables
</span>  <span class="comment">// the below stuff sets variables that ONLY apply
</span>  <span class="comment">// to the mainline thread
</span>  auto schedlist = run_felix_pthread_ctor(gcp, instance);

  async_scheduler = new (*gcp,async_sched_ptr_map,false) async_sched(
    this,
    debug_driver,
    gcp, schedlist
    ); <span class="comment">// deletes active for us!
</span>
  <span class="small_keyword">return</span> 0;
}

<span class="comment">// =================================================================
</span><span class="comment">// flx_world : Explicit Destructor
</span><span class="comment">// Destroys current Felix world.
</span><span class="comment">// However the Allocator and GC are retained.
</span>
<span class="comment">// Calls run_felix_pthread_dtor:
</span><span class="comment">//   *  Joins all threads to main thread
</span><span class="comment">//   *  Detaches Felix instance by unrooting it
</span><span class="comment">//   *  Collects all garbage if finalisation set
</span><span class="comment">//
</span><span class="comment">// Finalises system, running GC if required (AGAIN!)
</span><span class="comment">// =================================================================
</span><span class="qualifier">int</span> flx_world::explicit_dtor()
{
  <span class="small_keyword">if</span> (debug_driver)
    fprintf(stderr, <span class="fstring">"[explicit_dtor] entry\n"</span>);

  run_felix_pthread_dtor(debug_driver, gcp, library, instance);

  <span class="small_keyword">if</span> (gcp-&gt;finalise)
  {
    <span class="small_keyword">if</span> (debug_driver)
      fprintf(stderr, <span class="fstring">"[explicit_dtor] flx_run driver ends with finalisation complete\n"</span>);
  }
  else
  {
    <span class="small_keyword">if</span> (debug_driver || gcp-&gt;debug_collections)
    {
      size_t a = gcp-&gt;collector-&gt;get_allocation_count();
      fprintf(stderr,
        <span class="fstring">"[explicit_dtor] flx_run driver ends with finalisation skipped, %zu uncollected "</span>
          <span class="fstring">"objects\n"</span>, a);
    }
  }

  <span class="small_keyword">if</span> (debug_driver)
    fprintf(stderr, <span class="fstring">"[explicit_dtor] exit 0\n"</span>);

  <span class="small_keyword">return</span> 0;
}

<span class="comment">// =================================================================
</span><span class="comment">// flx_world : Teardown
</span><span class="comment">//
</span><span class="comment">// IRREVERSIBLY DESTROYS THE WORLD. Kills the allocator, collector,
</span><span class="comment">// collector profile and thread control object.
</span><span class="comment">//
</span><span class="comment">// This routine is a proxy for the destructor, it should be called
</span><span class="comment">// explicitly before deleting the world object.
</span><span class="comment">// it returns 0 if the explicit destructor succeeded, non-zero otherwise.
</span><span class="comment">// =================================================================
</span><span class="qualifier">int</span> flx_world::teardown() {
  <span class="small_keyword">if</span> (debug_driver)
    fprintf(stderr, <span class="fstring">"[teardown] entry\n"</span>);

  thread_control_base_t *thread_control = collector-&gt;get_thread_control();
  thread_control-&gt;add_thread(get_stack_pointer(), ::flx::pthread::mainline);

  <span class="comment">// could this override error_exit_code if something throws?
</span>  <span class="qualifier">int</span> error_exit_code = explicit_dtor();
  <span class="small_keyword">if</span> (debug_driver)
    fprintf(stderr,<span class="fstring">"[teardown] explicit dtor run code %d\n"</span>, error_exit_code);

  instance=0;
  library=0;
  <span class="small_keyword">if</span> (debug_driver)
    fprintf(stderr,<span class="fstring">"[teardown] library &amp; instance NULLED\n"</span>);

  <span class="comment">// And we're done, so start cleaning up.
</span>  delete gcp;

  delete collector;
  <span class="small_keyword">if</span> (debug_driver) 
    fprintf(stderr,<span class="fstring">"[teardown] collector deleted\n"</span>);

  delete allocator;
  <span class="small_keyword">if</span> (debug_driver) 
    fprintf(stderr,<span class="fstring">"[teardown] allocator deleted\n"</span>);

  <span class="small_keyword">if</span> (debug_driver) 
    fprintf(stderr, <span class="fstring">"[teardown] flx_run driver ends code=%d\n"</span>, error_exit_code);

  delete thread_control;  <span class="comment">// RF: cautiously delete here
</span>  <span class="small_keyword">if</span> (debug_driver) 
    fprintf(stderr,<span class="fstring">"[teardown] thread control deleted\n"</span>);
  <span class="small_keyword">return</span> error_exit_code;
}


<span class="comment">// =================================================================
</span><span class="comment">// Suspension control.
</span><span class="comment">//
</span><span class="comment">// In a user event loop, when Felix main thread returns,
</span><span class="comment">// the thread must be removed from the thread control object.
</span><span class="comment">// Prior to resuming the suspended system, the current thread
</span><span class="comment">// must be registered with the thread control object again.
</span><span class="comment">//
</span><span class="comment">// The reason is that there may be other threads running, even
</span><span class="comment">// though the main thread has exited to allow the user event
</span><span class="comment">// loop to check for and service events.
</span><span class="comment">//
</span><span class="comment">// Should one of these threads trigger a garbage collection,
</span><span class="comment">// the thread control object is used to signal all the other threads 
</span><span class="comment">// that they muist stop, and then waits until they do so.
</span><span class="comment">//
</span><span class="comment">// Waiting for the main thread would cause a lockup, since it is 
</span><span class="comment">// running the user event loop, not Felix code, and therefore 
</span><span class="comment">// cannot yield. In fact it has already yielded to the user
</span><span class="comment">// event loop .. so these two routines are used to ensure that
</span><span class="comment">// the thread is only registered when it can actually respond
</span><span class="comment">// to a world stop request.
</span><span class="comment">//
</span><span class="comment">// =================================================================
</span><span class="comment">// flx_world : Resume Felix
</span><span class="comment">// =================================================================
</span><span class="qualifier">void</span> flx_world::begin_flx_code() {
  collector-&gt;get_thread_control() -&gt; add_thread(get_stack_pointer(), ::flx::pthread::mainline);
}

<span class="comment">// =================================================================
</span><span class="comment">// flx_world :  Suspend Felix
</span><span class="comment">// =================================================================
</span><span class="qualifier">void</span> flx_world::end_flx_code() {
  collector-&gt;get_thread_control()-&gt;remove_thread();
}


<span class="comment">// =================================================================
</span><span class="comment">// flx_world :  Run Felix Mainline
</span><span class="comment">// =================================================================
</span><span class="qualifier">int</span> flx_world::run() {
  <span class="comment">// this may not be called on the same thread, so let thread control know
</span>  <span class="comment">// when we exit, main thread is not running so pthreads can garbage collect without waiting for us
</span>
  try {
    <span class="small_keyword">return</span> async_scheduler-&gt;prun();
  }
  catch (flx_exception_t &amp;x) { <span class="small_keyword">return</span> - flx_exception_handler (&amp;x); }
  catch (<span class="small_keyword">std</span>::exception &amp;x) { <span class="small_keyword">return</span> - <span class="small_keyword">std</span>_exception_handler (&amp;x); }
  catch (<span class="qualifier">int</span> &amp;x) { fprintf (stderr, <span class="fstring">"Exception type int: %d\n"</span>, x); <span class="small_keyword">return</span> -x; }
  catch (::<span class="small_keyword">std</span>::string &amp;x) { fprintf (stderr, <span class="fstring">"Exception type string : %s\n"</span>, x.c_str()); <span class="small_keyword">return</span> -1; }
  catch (::flx::rtl::con_t &amp;x) { fprintf (stderr, <span class="fstring">"Rogue continuatiuon caught\n"</span>); <span class="small_keyword">return</span> -6; }
  catch (...) { fprintf(stderr, <span class="fstring">"[flx_world:run_until_complete] Unknown exception in thread!\n"</span>); <span class="small_keyword">return</span> -5; }
}


<span class="comment">// =================================================================
</span><span class="comment">// flx_world :  Spawn fibre hook
</span><span class="comment">// =================================================================
</span><span class="comment">// TODO: factor into async_sched. run_felix_pthread_ctor does this twice
</span><span class="qualifier">void</span> flx_world::spawn_fthread(con_t *top) {
  auto ss = get_sync_scheduler();
	fthread_t *ft = new (*gcp, _fthread_ptr_map, false) fthread_t(top, ss-&gt;active);
  ss-&gt;push_front(ft);
}

<span class="comment">// =================================================================
</span><span class="comment">// flx_world :  External multiwrite hook
</span><span class="comment">// =================================================================
</span><span class="qualifier">void</span> flx_world::external_multi_swrite (schannel_t *chan, <span class="qualifier">void</span> *data) 
{
  async_scheduler-&gt;external_multi_swrite (chan,data);
} 

<span class="comment">// =================================================================
</span><span class="comment">// flx_world :  Create Demux event polling system and thread
</span><span class="comment">// =================================================================
</span>async_hooker *flx_world::create_demux() 
{
  <span class="small_keyword">if</span>(debug_driver)
    fprintf(stderr,<span class="fstring">"[create_demux]: svc_general] trying to create async system..\n"</span>);

  <span class="small_keyword">if</span> (c-&gt;ptr_create_async_hooker == NULL) {
    <span class="small_keyword">if</span>(debug_driver)
      fprintf(stderr,<span class="fstring">"[create_demux: svc_general] trying to create async hooker..\n"</span>);
    c-&gt;init_ptr_create_async_hooker(c,debug_driver);
  }
  <span class="comment">// Error out if we don't have the hooker function.
</span>  <span class="small_keyword">if</span> (c-&gt;ptr_create_async_hooker == NULL) {
    fprintf(stderr,
      <span class="fstring">"[create_demux: svc_general] Unable to initialise async I/O system: terminating\n"</span>);
    exit(1);
  }

  <span class="comment">// CREATE A NEW ASYNCHRONOUS EVENT MANAGER
</span>  <span class="comment">// DONE ON DEMAND ONLY
</span>  auto demux_hook = (*c-&gt;ptr_create_async_hooker)(
    gcp-&gt;collector-&gt;get_thread_control(), <span class="comment">// thread_control object
</span>    20000, <span class="comment">// bound on resumable thread queue
</span>    50,    <span class="comment">// bound on general input job queue
</span>    2,     <span class="comment">// number of threads in job pool
</span>    50,    <span class="comment">// bound on async fileio job queue
</span>    1      <span class="comment">// number of threads doing async fileio
</span>  );
  <span class="small_keyword">return</span> demux_hook;
}


}} <span class="comment">// namespaces
</span>


</pre></p></div></div><!--Main Content Body End-->

          </div> <!-- rightpanel contents end -->
          <hr>
        </span> <!-- rightpanel end -->

        <span id="panemover" style="cursor:col-resize;"
         onmousedown="dragStart(event, 'left', 'right'); return false;"
         onmousemove="drag(event, 'left', 'right');"
         onmouseout="dragRelease();"
         onmouseup="dragRelease();"
        >
        </span> <!-- panemover end -->
      </div> <!-- bottom panel end -->
    </div> <!-- container end -->
</body></html>

