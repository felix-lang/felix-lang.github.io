<html><head>
<style type="text/css">
body {margin:3%; }
h1 {color:gray; font-size:120%;}
h2 {color:gray; font-size:105%;}
h3 {font-size:100%;}
h4 {font-size:95%;}
h5 {font-size:95%;}
span.fstring {color:darkblue; font-style:italic; }
span.comment {font-family:arial; color:blue; font-style:italic; }
span.doccomment {font-family:arial; color:green; font-style:italic; }
span.big_keyword {color:#FF1010; }
span.small_keyword {color:#802040; }
span.qualifier {color:#A02020; }
span.library {color:#A02000; }
span.ctor {color:#406020; }
span.hack {color:#66DD00; }
span.preproc {color:#005500; }
span.embedded_c{background-color:#DDDDDD; }
span.fpc_fieldname {color:#DD0000; }
span.lineno {color:#101010; background-color:#E0E0E0; font-size:80%; font-family:"courier",monospace; font-style:normal; }
pre.flxbg {background-color:#A0FFA0; color:black; padding:2px; box-shadow:5px 5px 2px #807080; }
pre.uncheckedflxbg {background-color:#D0D0D0; color:black; padding:2px; box-shadow:5px 5px 2px #807080; }
pre.cppbg {background-color:#80FF80; color:black; }
pre.prefmtbg {background-color:#D0D0D0; color:black; }
pre.expected {background-color:#E0FF80; color:black; }
pre.input {background-color:#E08080; color:black; }
pre.inclusion {background-color:#D070D0; color:black; }
code.inclusion {background-color:#D070D0; color:black; }
.obsolete { background-color:#FFEFEF; font-size: small; color:black; }
.future { background-color:#FF8080; font-size: small; color:black; }
.implementation_detail { background-color:#E0E0E0; font-size: small; color:black;  }
.bug { background-color:#FFE0E0; font-size: small; color:black; }
.fixed{ background-color:#FFE0E0; font-size: small; color:black; }
.done { background-color:#FFE0E0; font-size: small; color:black; }
.caveat { background-color:#FF8080; color:black; }
</style>
<title>views</title></head><body>
<style>
body {margin:3%; font-family: sans-serif; }
h1 {color:black; font-size:120%; border-bottom: 2px solid #ddd; padding: 0 0 3px 0;}
h2 {color:#202020; font-size:105%;}
h3 {font-size:100%;}
h4 {font-size:95%;}
h5 {font-size:95%;}
span.fstring {color:darkblue; font-style:italic; }
span.comment {font-family:arial; color:blue; font-style:italic; }
span.doccomment {font-family:arial; color:green; font-style:italic; }
span.big_keyword {color:#FF1010; }
span.small_keyword {color:#802040; }
span.qualifier {color:#A02020; }
span.library {color:#A02000; }
span.ctor {color:#406020; }
span.hack {color:#66DD00; }
span.preproc {color:#005500; }
span.embedded_c{background-color:#DDDDDD; }
span.fpc_fieldname {color:#DD0000; }
span.lineno {color:#101010; background-color:#E0E0E0; font-size:80%; font-family:"courier",monospace; font-style:normal; }
pre { border: 1px solid #ccc; color: black; box-shadow:3px 3px 2px rgba(0,0,0,0.1); padding:2px; }
pre.flxbg {background-color:#C2FDC2; box-shadow:3px 3px 2px rgba(0,0,0,0.1) }
pre.uncheckedflxbg {background-color:#eee; box-shadow:3px 3px 2px rgba(0,0,0,0.1); }
pre.cppbg {background-color:#C2FDC2; }
pre.prefmtbg {background-color:#F1F1F1; }
pre.expected {background-color:hsla(74,94%,88%,1); }
pre.input {background-color:hsla(20,94%,88%,1); }
pre.inclusion {
    font-family: Arial;
    font-weight: normal;
    font-size: 0.9em;
    color: #555;
    border: none;
    box-shadow: none;
    text-align: right;
    margin: -7px 11px -12px 0;
    padding: 0;
    background-color:#fafafa;
}
code.inclusion {background-color:#D070D0; color:black; }
.obsolete { background-color:#FFEFEF; font-size: small; color:black; }
.future { background-color:#FF8080; font-size: small; color:black; }
.implementation_detail { background-color:#E0E0E0; font-size: small; color:black;  }
.bug { background-color:#FFE0E0; font-size: small; color:black; }
.fixed{ background-color:#FFE0E0; font-size: small; color:black; }
.done { background-color:#FFE0E0; font-size: small; color:black; }
.caveat { background-color:hsla(0,100%,91%,1); color:black; padding: 0.6em; }
.container {
  position: fixed;
  top:0px;
  left:0px;
  height : 100%;
  width: 100%;
  background-color: grey;
  margin: 0px;
  padding: 0px;
  border-width: 0px;
  color: #404040;
}
.maincontent {
  padding:4px;
  padding-left:8px;
  line-height:1.3em;
  color:#404040; background-color:#fafafa;
}
.maincontent h1 { margin-left:-8px; position: relative; font-family: georgia, serif; font-size: 1.8em; font-weight: normal; }
.maincontent h2 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent h3 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent h4 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent code { color:#902030; }
.toppanel {
  position:absolute; left:0px; top:0px; height:20px; right:0px;
  background-color: #e0e0e0;
}
.bottompanel {
  position:absolute; left:0px; top:22px; bottom:0px; right:0px;
  background-color: #fafafa;
  font-size:14px;
}
.leftpanel {
  position:absolute; left:0px; top:0px; bottom:0px; width: 150px;
  background-color: #eaeaea; overflow: auto;
}
.rightpanel {
  position:absolute; right: 0px; left:160px; top:0px; bottom: 0px;
  background-color: #fafafa; overflow: auto;
}
.divider {
  position:absolute; left: 150px; top:0px; bottom:0px;
  background-color: black; width:2px;
  box-shadow: 0 0 8px #000;
}

#panemover {
    position:absolute;
    left: 150px;
    width : 10px;
    top: 0px;
    bottom: 0px;
    opacity: 0.3;
    cursor:col-resize;
}

div.m {
    margin: 0px;
    padding:0px;
    border-width:2px;
    border-color: green;
}

div.m1 {
    background-color: #86E870;
    border-style:outset;
    border-color:#ccc;
    border-width:2px 0;
    font-size:90%;
    padding: 1px 0 2px 10px;
}

div.m2 {
    background-color: #70C070;
    padding-left:15px;
    padding-top:2px;
    border-style:outset;
    border-color:green;
    border-width:0 0 1px 0;
    font-size:80%;
}

div.m1:hover, div.m2:hover {
    background-color: white;
}

#leftmargintoc a {
    text-decoration: none;
    color: #404040;
}
</style>

<style>
div.m {
    margin: 0px;
    padding:0px;
    border-width:2px;
    border-color: green;
}

div.m1 {
    background-color: #86E870;
    border-style:outset;
    border-color:#ccc;
    border-width:2px 0;
    font-size:90%;
    padding: 1px 0 2px 10px;
}

div.m2 {
    background-color: #70C070;
    padding-left:15px;
    padding-top:2px;
    border-style:outset;
    border-color:green;
    border-width:0 0 1px 0;
    font-size:80%;
}

div.m1:hover, div.m2:hover {
    background-color: white;
}

#leftmargintoc a {
    text-decoration: none;
    color: #404040;
}


</style>

    <script async="true">
      function dragStart(e, left, right){
        document.getElementById("panemover").style.width="70%";
        document.getElementById("panemover").style.left="50px";
        mousedown = true;
        x = e.clientX
        dragOffsetLeft =
          document.getElementById(left).getBoundingClientRect().right -
          document.getElementById(left).getBoundingClientRect().left -
          x
        ;
        dragOffsetDivider= document.getElementById("divider").getBoundingClientRect().left - x;
        dragOffsetRight = document.getElementById(right).getBoundingClientRect().left - x;
      }
      function dragRelease(){
        document.getElementById('panemover').style.width = '10px';
        document.getElementById('panemover').style.left = document.getElementById('divider').offsetLeft + 'px';
        mousedown = false;
      }
      function drag(e, left, right){
        if(!mousedown){return}
        x = e.clientX
        tmpLeft = dragOffsetLeft + x
        tmpDivider= dragOffsetDivider + x
        tmpRight = dragOffsetRight + x
        document.getElementById(left).style.width= tmpLeft + 'px';
        document.getElementById("divider").style.left= tmpDivider + 'px';
        document.getElementById(right).style.left = tmpRight + 'px';
      };
    </script>

<script type="text/javascript">

  function mexpand(id)
  {
    var n = document.getElementById(id).style;
    n.display = "block";
  }

  function mcollapse(id)
  {
    var n = document.getElementById(id).style;
    n.display = "none";
  }

  var counter_max = 0;
  function mshow(id,loc)
  {
    var i;
    for(i=1; i<=counter_max; ++i)
      mcollapse("menu"+String(i));
    mexpand(id);
    window.location.replace(loc);
  }
</script>

<script type="text/javascript">

function expand(but,id)
{
  var n = document.getElementById(id).style;
  var button = document.getElementById(but);
  button.src = "/share/src/web/images/minus.gif";
  button.alt = "-";
  n.display = "block";
}
function collapse(but,id)
{
  var n = document.getElementById(id).style;
  var button = document.getElementById(but);
  button.src = "/share/src/web/images/plus.gif";
  button.alt = "+";
  n.display = "none";
}
function toggle(button,id)
{
  var n = document.getElementById(id).style;
  if (n.display == "none")
  {
    button.src = "/share/src/web/images/minus.gif";
    button.alt = "-";
    n.display = "block";
  }
  else
  {
    button.src = "/share/src/web/images/plus.gif";
    button.alt = "+";
    n.display = "none";
  }
}
var allbuttons = [
"Pointer modes",
"Views",
"Viewification",
"Viewifying a pointer type",
"Viewifying a primitive type",
"Viewifying a structural type",
"Viewifying a type variable",
"Viewifying a structured nominal type",
"An realistic example",
"Application to C++",
"A need for mode polymorphism"
];
function expand_all(dummy)
{
  for (i in allbuttons)
  {
    expand(allbuttons[i], allbuttons[i]+"_d");
  }
}
function collapse_all(dummy)
{
  for (i in allbuttons)
  {
    collapse(allbuttons[i], allbuttons[i]+"_d");
  }
}
</script>

<script>
function mouseover(id)
{
  var elt = document.getElementById(id);
  elt.style.display="none";
  var elt2 = document.getElementById(id+"_mo");
  elt2.style.display="inline";
}

function mouseout(id)
{
  var elt = document.getElementById(id+"_mo");
  elt.style.display="none";
  var elt2 = document.getElementById(id);
  elt2.style.display="inline";
}

</script>
<script> function nop(dummy) {} </script>
    <div class="container">
      <div class="toppanel">
    <!--Main Content top navbar-->
<span style="position:relative; bottom:6px"
  onmouseover="mouseover('expand')"
  onmouseout="mouseout('expand')"
  onclick="expand_all('expand')"
  ><span id="expand"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:blue;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Expand</text></svg></span><span id="expand_mo" style="display:none"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:red;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Expand</text></svg></span></span><span style="position:relative; bottom:6px"
  onmouseover="mouseover('collapse')"
  onmouseout="mouseout('collapse')"
  onclick="collapse_all('collapse')"
  ><span id="collapse"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:blue;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Collapse</text></svg></span><span id="collapse_mo" style="display:none"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:red;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Collapse</text></svg></span></span>    <!--Main Content top navbar End-->

      </div> <!-- toppanel end -->
      <div class="bottompanel">
        <span id="divider" class="divider"></span>

        <span id="left" class="leftpanel" >
          <div class="menucontent">
  <!--Left Margin Toc-->
  <div id="leftmargintoc">
    <!--Left Margin Toc Main Contents-->
      <div class=m1 onclick="mshow('menu1','#Pointer modes_h')"> <a href="#Pointer_modes_h">Pointer modes</a></div>
      <div class=sm id=menu1>
      </div>
      <div class=m1 onclick="mshow('menu2','#Views_h')"> <a href="#Views_h">Views</a></div>
      <div class=sm id=menu2>
      </div>
      <div class=m1 onclick="mshow('menu3','#Viewification_h')"> <a href="#Viewification_h">Viewification</a></div>
      <div class=sm id=menu3>
      <div class=m2><a href="#Viewifying_a_pointer_type_h">Viewifying a pointer type</a></div>
      <div class=m2><a href="#Viewifying_a_primitive_type_h">Viewifying a primitive type</a></div>
      <div class=m2><a href="#Viewifying_a_structural_type_h">Viewifying a structural type</a></div>
      <div class=m2><a href="#Viewifying_a_type_variable_h">Viewifying a type variable</a></div>
      <div class=m2><a href="#Viewifying_a_structured_nominal_type_h">Viewifying a structured nominal type</a></div>
      </div>
      <div class=m1 onclick="mshow('menu4','#An realistic example_h')"> <a href="#An_realistic_example_h">An realistic example</a></div>
      <div class=sm id=menu4>
      </div>
      <div class=m1 onclick="mshow('menu5','#Application to C++_h')"> <a href="#Application_to_C++_h">Application to C++</a></div>
      <div class=sm id=menu5>
      </div>
      <div class=m1 onclick="mshow('menu6','#A need for mode polymorphism_h')"> <a href="#A_need_for_mode_polymorphism_h">A need for mode polymorphism</a></div>
      <div class=sm id=menu6>
      </div>
    <script>counter_max=6;</script>
  </div>
  <!--End Left Margin Toc-->

          </div> <!-- leftpanel contents end -->
        </span> <!-- leftpanel end -->

        <span id="right" class="rightpanel">
          <div class="maincontent">
<!--Main Content Body-->
<h1 id='Pointer_modes_h'><img src='/share/src/web/images/minus.gif' id='Pointer modes' onclick='toggle(this,"Pointer_modes_d")' alt='+'/> 1 Pointer modes</h1><div id='Pointer_modes_d' style='display:block'>
<p>In Felix, pointers have an associated access mode, these are
called <em>cv-qualifiers</em> in C++. The original modes are shown in the 
diagram below:
</p><p><pre class="prefmtbg">    N
   / \
  R   W
  \  /
   RW
</pre></p><p>The lower modes are submodes of the higher modes, and pointers to the same
type are subtypes if their modes are submodes. The abbreviations mean:
<table>
<tr><td>N</tf><td>No access</td></tr>
<tr><td>R</td><td>Read only</td></tr>
<tr><td>W</td><td>Write only</td></tr>
<tr><td>RW</td><td>Read and write<td></tr>
</table>
</p><p>The type and expression annotations are illustrated below:
</p><p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Define a mutable variable">var</span> x : <span class="library" title="binding of C int type">int</span> = 1;
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Define a mutable variable">var</span> rwp : &amp;<span class="library" title="binding of C int type">int</span> = &amp;x; <span class="comment">// read write pointer</span>
<span class="lineno" id=line3></span>  <span class="big_keyword" title="Define a mutable variable">var</span> rp : &amp;&lt;<span class="library" title="binding of C int type">int</span> = &amp;&lt;x; <span class="comment">// read only pointer</span>
<span class="lineno" id=line4></span>  <span class="big_keyword" title="Define a mutable variable">var</span> wp : &amp;&gt;nt = &amp;&gt;x; <span class="comment">// write only pointer</span>
<span class="lineno" id=line5></span>  <span class="comment">// currently N mode has no syntax</span>
</pre></p><p>We need to recall for pointers:
</p><p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Define a mutable variable">var</span> x = 1;
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Define a mutable variable">var</span> p = &amp;x;
<span class="lineno" id=line3></span>  <span class="big_keyword" title="Define a mutable variable">var</span> q = *p;  <span class="comment">// fetch operation</span>
<span class="lineno" id=line4></span>  p &lt;- 2;      <span class="comment">// store operation</span>
</pre></p><p>The <code>*</code> operator is called <em>dereference</em> from C, however
in Felix it does not create a reference or lvalue, it just fetches
a value. The only references in Felix are variables.
</p><p>Although in principle <code>R</code> pointers are covariant in their target,
and <code>W</code> pointers contravariant (making <code>RW</code> pointers invariant),
Felix current only supports invariant targets.
</p><p>There is a well known problem with read-only pointers: the read
only attribute only applies to the pointed at object. If you consider
a list in which nodes contain a value and a pointer to the next node,
a read only pointer to a node does not prevent writing to the next node
if the next pointer is read-write. That is, the read-only property
only has a <em>shallow</em> effect when we really wanted a <em>deep</em>
impact. Here's an example:
</p><p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Define a mutable variable">var</span> x   : <span class="library" title="binding of C int type">int</span>      = 1;
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Define a mutable variable">var</span> p   : &amp;<span class="library" title="binding of C int type">int</span>     = &amp;x;   <span class="comment">// read write pointer to int</span>
<span class="lineno" id=line3></span>  <span class="big_keyword" title="Define a mutable variable">var</span> rpp : &amp;&lt;(&amp;<span class="library" title="binding of C int type">int</span>) = &amp;&lt;p;  <span class="comment">// read only pointer to read-write pointer to int</span>
<span class="lineno" id=line4></span>  <span class="big_keyword" title="Define a mutable variable">var</span> rwp : &amp;<span class="library" title="binding of C int type">int</span>     = *rpp; <span class="comment">// read write pointer to int</span>
<span class="lineno" id=line5></span>  rwp &lt;- 2;                  <span class="comment">// write to x</span>
<span class="lineno" id=line6></span>  <span class="library" title="Print a string to standard output with newline appended">println</span>$ x;                <span class="comment">// x is 2 now</span>
</pre></p></div><h1 id='Views_h'><img src='/share/src/web/images/minus.gif' id='Views' onclick='toggle(this,"Views_d")' alt='+'/> 2 Views</h1><div id='Views_d' style='display:block'>
<p>Given a pointer <code>p</code>. we define the <em>data structure</em> associated 
with <code>p</code> as the set of all the objects reachable from <code>p</code>.
</p><p>A <em>functional view</em> of a data structure is a read only view
of the whole data structure. A <em>view</em> pointer mode, abbreviated <code>V</code>, 
also called <em>propagating const</em> in C++, is a pointer mode with the semantics
that ensure that no object of the data structure is writable (via that pointer), and thus
provides the required <em>deep</em> effect.
</p><p>We use the following annotation for view mode pointers:
</p><p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Define a mutable variable">var</span> x : T;
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Define a mutable variable">var</span> vp : &amp;&lt;&lt;T = &amp;&lt;&lt;x;
</pre></p><p>To see how these work, we repeat the previous example but using a view:
</p><p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Define a mutable variable">var</span> x   : <span class="library" title="binding of C int type">int</span>        = 1;
<span class="lineno" id=line2></span>  <span class="big_keyword" title="Define a mutable variable">var</span> p   : &amp;<span class="library" title="binding of C int type">int</span>       = &amp;x;    <span class="comment">// read write pointer to int</span>
<span class="lineno" id=line3></span>  <span class="big_keyword" title="Define a mutable variable">var</span> vpp : &amp;&lt;&lt;(&amp;<span class="library" title="binding of C int type">int</span>)  = &amp;&lt;&lt;p;  <span class="comment">// view pointer to read-write pointer to int</span>
<span class="lineno" id=line4></span>  <span class="big_keyword" title="Define a mutable variable">var</span> vp  : &amp;&lt;&lt;<span class="library" title="binding of C int type">int</span>     = *vpp;  <span class="comment">// view pointer to int</span>
<span class="lineno" id=line5></span>  <span class="comment">// rwp &lt;- 2;                  // TYPE ERROR</span>
</pre></p><p>In this example, the propagation of the view mode occurs when the view
pointer is dereferenced: type usual fetched type <code>&int</code> is hacked
with a reinterpret cast, in effect, to have type <code>&amp;&lt;&lt;int</code>
instead, this preventing any write derived from the view pointer by
fetch operation.
</p></div><h1 id='Viewification_h'><img src='/share/src/web/images/minus.gif' id='Viewification' onclick='toggle(this,"Viewification_d")' alt='+'/> 3 Viewification</h1><div id='Viewification_d' style='display:block'>
<p>The implementation is not entirely straight forward.
The coercion is entirely at the type level and does not impact
values: it is called  <em>viewification</em>.
</p><h2 id='Viewifying_a_pointer_type_h'><img src='/share/src/web/images/minus.gif' id='Viewifying a pointer type' onclick='toggle(this,"Viewifying_a_pointer_type_d")' alt='+'/> 3.1 Viewifying a pointer type</h2><div id='Viewifying_a_pointer_type_d' style='display:block'>
<p>Clearly, when we have a view pointer whose target is a pointer,
fetching the target must discard write ability, so the following
conversions are used on the mode of the target pointer:
</p><p><pre class="prefmtbg">V -&gt; V
R -&gt; V
RW -&gt; V
W -&gt; N
N -&gt; N
</pre></p><p>Indeed we consider V a submode of N, and R a submode or V,
and thus the corresponding pointer subtyping relations.
Think of subtyping coercions as "throwing out capability".
</p></div><h2 id='Viewifying_a_primitive_type_h'><img src='/share/src/web/images/minus.gif' id='Viewifying a primitive type' onclick='toggle(this,"Viewifying_a_primitive_type_d")' alt='+'/> 3.2 Viewifying a primitive type</h2><div id='Viewifying_a_primitive_type_d' style='display:block'>
<p>However the target of a pointer need not be a pointer.
If the target is a primitive type such as <code>int</code> the coercion
is the identity and the target is unchanged. Felix currently
applies this rule to all types lifted from C/C++ (even though
it is clearly inadequate) because to do more would require
additional annotations on the type (in particular a view mode
version of the type would have to be cited at the point of definition).
</p></div><h2 id='Viewifying_a_structural_type_h'><img src='/share/src/web/images/minus.gif' id='Viewifying a structural type' onclick='toggle(this,"Viewifying_a_structural_type_d")' alt='+'/> 3.3 Viewifying a structural type</h2><div id='Viewifying_a_structural_type_d' style='display:block'>
<p>If the target is a structural type such as a product (tuple or record)
or sum type (sum or polymorphic variant) then the coercion is applied
to each component (recursively).
</p></div><h2 id='Viewifying_a_type_variable_h'><img src='/share/src/web/images/minus.gif' id='Viewifying a type variable' onclick='toggle(this,"Viewifying_a_type_variable_d")' alt='+'/> 3.4 Viewifying a type variable</h2><div id='Viewifying_a_type_variable_d' style='display:block'>
<p>If the target is a type variable, then the type variable is <em>marked</em>
as being a view. Subsequently when the type variable is replaced, 
the replacement is first viewified. 
</p><p>Note that if the target is a pointer to a type variable, the type
variables is <em>not</em> viewified. There is no need, because the pointer
mode has been viewified.
</p></div><h2 id='Viewifying_a_structured_nominal_type_h'><img src='/share/src/web/images/minus.gif' id='Viewifying a structured nominal type' onclick='toggle(this,"Viewifying_a_structured_nominal_type_d")' alt='+'/> 3.5 Viewifying a structured nominal type</h2><div id='Viewifying_a_structured_nominal_type_d' style='display:block'>
<p>There is one final case: the target is a <code>struct</code>, <code>cstruct</code> or <code>variant</code>; that is,
a nominally typed product or sum type. In this case, actually coercing
the type would require introducing a viewified version of it which would
be a supertype of the original. This would require a notation, and 
we would also need to add a subtyping coercion to the symbol table:
and we'd need to do this even if the viewified version was never used.
</p><p>Even worse, it would no longer be possible to just change a routine
which currently visits a data structure without modifying it 
to take a view pointer, so as to actually prove this fact, because
the nominal types involved would also change. This would have
a cascading effect on the standard library and create a serious
maintenance problem. I would note this has indeed happened
historically when <code>const</code> was introduced to C: and a lot
of code was broken.
</p><p>Instead, we simply mark <em>references</em> to nominal types
as views, and convert the components "on the fly" when they're
accessed.
</p></div></div><h1 id='An_realistic_example_h'><img src='/share/src/web/images/minus.gif' id='An realistic example' onclick='toggle(this,"An_realistic_example_d")' alt='+'/> 4 An realistic example</h1><div id='An_realistic_example_d' style='display:block'>
<p>Here is an example:
</p><p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="small_keyword" title="end of extension">begin</span>
<span class="lineno" id=line2></span>    <span class="comment">// option type</span>
<span class="lineno" id=line3></span>    variant <span class="library" title="option type: Some x or None">opt</span>[T] = | None | Some of T ;
<span class="lineno" id=line4></span>  
<span class="lineno" id=line5></span>    <span class="comment">// list node type</span>
<span class="lineno" id=line6></span>    <span class="big_keyword" title="Define a structure">struct</span> Node { a:<span class="library" title="binding of C int type">int</span>; next: <span class="library" title="option type: Some x or None">opt</span>[&amp;Node]; }
<span class="lineno" id=line7></span>  
<span class="lineno" id=line8></span>    <span class="comment">// construct a sample list</span>
<span class="lineno" id=line9></span>    <span class="big_keyword" title="Define a mutable variable">var</span> px = unbox (new Node (1, None[&amp;Node] ));
<span class="lineno" id=line10></span>    px = unbox (new Node (2, Some (px)));
<span class="lineno" id=line11></span>    px = unbox (new Node (3, Some (px)));
<span class="lineno" id=line12></span>  
<span class="lineno" id=line13></span>    <span class="comment">// a pretty printer for the list</span>
<span class="lineno" id=line14></span>    <span class="comment">// which proves the list is not changed</span>
<span class="lineno" id=line15></span>    <span class="big_keyword" title="Define a function with no side-effects">fun</span> pNode (<span class="big_keyword" title="Define a mutable variable">var</span> px:&amp;&lt;&lt;Node) =&gt;
<span class="lineno" id=line16></span>      (px*.a).<span class="library" title="Convert a value to a string">str</span> + <span class="fstring">", "</span> +
<span class="lineno" id=line17></span>      <span class="small_keyword" title="match statement or expression">match</span>  px*.next <span class="small_keyword" title="type-class constraint">with</span>
<span class="lineno" id=line18></span>      | None =&gt; <span class="fstring">";"</span>
<span class="lineno" id=line19></span>      | Some px =&gt; pNode px
<span class="lineno" id=line20></span>      <span class="small_keyword" title="end a match statement or expression">endmatch</span>
<span class="lineno" id=line21></span>    ;
<span class="lineno" id=line22></span>  
<span class="lineno" id=line23></span>    <span class="library" title="Print a string to standard output with newline appended">println</span>$ px.pNode;
<span class="lineno" id=line24></span>  <span class="small_keyword" title="end of extension">end</span>
</pre></p><p>Notice the node type uses a RW pointer, but the
print routine uses a V pointer. The routine is recursive,
and the view mode propagates through the recursion.
</p><p>The node type is a nominal product, and the option type
is a nominal variant, the same as the one in the standard library,
and involves a type variable.
</p><p>The critical point is that <code>*px</code> is a viewified version 
of <code>Node</code>, and so the projection <code>next</code> applied to it
is a viewified version of <code>opt[&Node]</code> which if populated
has the <code>Some</code> constructor with argument of type 
viewified <code>&Node</code> which is type <code>&amp;&lt;&lt;Node</code> as required for the
recursion to go through.
</p></div><h1 id='Application_to_C++_h'><img src='/share/src/web/images/minus.gif' id='Application to C++' onclick='toggle(this,"Application_to_C++_d")' alt='+'/> 5 Application to C++</h1><div id='Application_to_C++_d' style='display:block'>
<p>I note finally that these rules could easily be applied in C++
by adding a "propagating const" cv-qualifier, in fact the implementation
would actually be simpler because C++ does not support type checked
polymorphism, so there is no need to mark type variables (that is;
none of the rules are needed until after template instantiation).
C++ also has no write only mode, and no proper no-access mode:
a <code>void*</code> may suffice, however in Felix N mode pointers, whilst
not supporting access to the target, do support address calculations.
</p></div><h1 id='A_need_for_mode_polymorphism_h'><img src='/share/src/web/images/minus.gif' id='A need for mode polymorphism' onclick='toggle(this,"A_need_for_mode_polymorphism_d")' alt='+'/> 6 A need for mode polymorphism</h1><div id='A_need_for_mode_polymorphism_d' style='display:block'>
<p>As a final note, the existence of these 5 modes in Felix would mean
that generalised pointer projections would be impossible to express;
for example given a pointer into one data structure, you might
want to find a corresponding pointer into another, with the same mode.
To do that you'd actually need to write the algorithm out 5 times.
To fix that, we'd need mode polymorphism!
</p></div><!--Main Content Body End-->

          </div> <!-- rightpanel contents end -->
          <hr>
        </span> <!-- rightpanel end -->

        <span id="panemover" style="cursor:col-resize;"
         onmousedown="dragStart(event, 'left', 'right'); return false;"
         onmousemove="drag(event, 'left', 'right');"
         onmouseout="dragRelease();"
         onmouseup="dragRelease();"
        >
        </span> <!-- panemover end -->
      </div> <!-- bottom panel end -->
    </div> <!-- container end -->
</body></html>

