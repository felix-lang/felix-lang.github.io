<html><head>
<style type="text/css">
body {margin:3%; }
h1 {color:gray; font-size:120%;}
h2 {color:gray; font-size:105%;}
h3 {font-size:100%;}
h4 {font-size:95%;}
h5 {font-size:95%;}
span.fstring {color:darkblue; font-style:italic; }
span.comment {font-family:arial; color:blue; font-style:italic; }
span.doccomment {font-family:arial; color:green; font-style:italic; }
span.big_keyword {color:#FF1010; }
span.small_keyword {color:#802040; }
span.qualifier {color:#A02020; }
span.library {color:#A02000; }
span.ctor {color:#406020; }
span.hack {color:#66DD00; }
span.preproc {color:#005500; }
span.embedded_c{background-color:#DDDDDD; }
span.fpc_fieldname {color:#DD0000; }
span.lineno {color:#101010; background-color:#E0E0E0; font-size:80%; font-family:"courier",monospace; font-style:normal; }
pre.flxbg {background-color:#A0FFA0; color:black; padding:2px; box-shadow:5px 5px 2px #807080; }
pre.uncheckedflxbg {background-color:#D0D0D0; color:black; padding:2px; box-shadow:5px 5px 2px #807080; }
pre.cppbg {background-color:#80FF80; color:black; }
pre.prefmtbg {background-color:#D0D0D0; color:black; }
pre.expected {background-color:#E0FF80; color:black; }
pre.input {background-color:#E08080; color:black; }
pre.inclusion {background-color:#D070D0; color:black; }
code.inclusion {background-color:#D070D0; color:black; }
.obsolete { background-color:#FFEFEF; font-size: small; color:black; }
.future { background-color:#FF8080; font-size: small; color:black; }
.implementation_detail { background-color:#E0E0E0; font-size: small; color:black;  }
.bug { background-color:#FFE0E0; font-size: small; color:black; }
.fixed{ background-color:#FFE0E0; font-size: small; color:black; }
.done { background-color:#FFE0E0; font-size: small; color:black; }
.caveat { background-color:#FF8080; color:black; }
</style>
<title>coroutines</title></head><body>
<style>
body {margin:3%; font-family: sans-serif; }
h1 {color:black; font-size:120%; border-bottom: 2px solid #ddd; padding: 0 0 3px 0;}
h2 {color:#202020; font-size:105%;}
h3 {font-size:100%;}
h4 {font-size:95%;}
h5 {font-size:95%;}
span.fstring {color:darkblue; font-style:italic; }
span.comment {font-family:arial; color:blue; font-style:italic; }
span.doccomment {font-family:arial; color:green; font-style:italic; }
span.big_keyword {color:#FF1010; }
span.small_keyword {color:#802040; }
span.qualifier {color:#A02020; }
span.library {color:#A02000; }
span.ctor {color:#406020; }
span.hack {color:#66DD00; }
span.preproc {color:#005500; }
span.embedded_c{background-color:#DDDDDD; }
span.fpc_fieldname {color:#DD0000; }
span.lineno {color:#101010; background-color:#E0E0E0; font-size:80%; font-family:"courier",monospace; font-style:normal; }
pre { border: 1px solid #ccc; color: black; box-shadow:3px 3px 2px rgba(0,0,0,0.1); padding:2px; }
pre.flxbg {background-color:#C2FDC2; box-shadow:3px 3px 2px rgba(0,0,0,0.1) }
pre.uncheckedflxbg {background-color:#eee; box-shadow:3px 3px 2px rgba(0,0,0,0.1); }
pre.cppbg {background-color:#C2FDC2; }
pre.prefmtbg {background-color:#F1F1F1; }
pre.expected {background-color:hsla(74,94%,88%,1); }
pre.input {background-color:hsla(20,94%,88%,1); }
pre.inclusion {
    font-family: Arial;
    font-weight: normal;
    font-size: 0.9em;
    color: #555;
    border: none;
    box-shadow: none;
    text-align: right;
    margin: -7px 11px -12px 0;
    padding: 0;
    background-color:#fafafa;
}
code.inclusion {background-color:#D070D0; color:black; }
.obsolete { background-color:#FFEFEF; font-size: small; color:black; }
.future { background-color:#FF8080; font-size: small; color:black; }
.implementation_detail { background-color:#E0E0E0; font-size: small; color:black;  }
.bug { background-color:#FFE0E0; font-size: small; color:black; }
.fixed{ background-color:#FFE0E0; font-size: small; color:black; }
.done { background-color:#FFE0E0; font-size: small; color:black; }
.caveat { background-color:hsla(0,100%,91%,1); color:black; padding: 0.6em; }
.container {
  position: fixed;
  top:0px;
  left:0px;
  height : 100%;
  width: 100%;
  background-color: grey;
  margin: 0px;
  padding: 0px;
  border-width: 0px;
  color: #404040;
}
.maincontent {
  padding:4px;
  padding-left:8px;
  line-height:1.3em;
  color:#404040; background-color:#fafafa;
}
.maincontent h1 { margin-left:-8px; position: relative; font-family: georgia, serif; font-size: 1.8em; font-weight: normal; }
.maincontent h2 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent h3 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent h4 { margin-left:-8px; position: relative; margin-bottom:-5px; }
.maincontent code { color:#902030; }
.toppanel {
  position:absolute; left:0px; top:0px; height:20px; right:0px;
  background-color: #e0e0e0;
}
.bottompanel {
  position:absolute; left:0px; top:22px; bottom:0px; right:0px;
  background-color: #fafafa;
  font-size:14px;
}
.leftpanel {
  position:absolute; left:0px; top:0px; bottom:0px; width: 150px;
  background-color: #eaeaea; overflow: auto;
}
.rightpanel {
  position:absolute; right: 0px; left:160px; top:0px; bottom: 0px;
  background-color: #fafafa; overflow: auto;
}
.divider {
  position:absolute; left: 150px; top:0px; bottom:0px;
  background-color: black; width:2px;
  box-shadow: 0 0 8px #000;
}

#panemover {
    position:absolute;
    left: 150px;
    width : 10px;
    top: 0px;
    bottom: 0px;
    opacity: 0.3;
    cursor:col-resize;
}

div.m {
    margin: 0px;
    padding:0px;
    border-width:2px;
    border-color: green;
}

div.m1 {
    background-color: #86E870;
    border-style:outset;
    border-color:#ccc;
    border-width:2px 0;
    font-size:90%;
    padding: 1px 0 2px 10px;
}

div.m2 {
    background-color: #70C070;
    padding-left:15px;
    padding-top:2px;
    border-style:outset;
    border-color:green;
    border-width:0 0 1px 0;
    font-size:80%;
}

div.m1:hover, div.m2:hover {
    background-color: white;
}

#leftmargintoc a {
    text-decoration: none;
    color: #404040;
}
</style>

<style>
div.m {
    margin: 0px;
    padding:0px;
    border-width:2px;
    border-color: green;
}

div.m1 {
    background-color: #86E870;
    border-style:outset;
    border-color:#ccc;
    border-width:2px 0;
    font-size:90%;
    padding: 1px 0 2px 10px;
}

div.m2 {
    background-color: #70C070;
    padding-left:15px;
    padding-top:2px;
    border-style:outset;
    border-color:green;
    border-width:0 0 1px 0;
    font-size:80%;
}

div.m1:hover, div.m2:hover {
    background-color: white;
}

#leftmargintoc a {
    text-decoration: none;
    color: #404040;
}


</style>

    <script async="true">
      function dragStart(e, left, right){
        document.getElementById("panemover").style.width="70%";
        document.getElementById("panemover").style.left="50px";
        mousedown = true;
        x = e.clientX
        dragOffsetLeft =
          document.getElementById(left).getBoundingClientRect().right -
          document.getElementById(left).getBoundingClientRect().left -
          x
        ;
        dragOffsetDivider= document.getElementById("divider").getBoundingClientRect().left - x;
        dragOffsetRight = document.getElementById(right).getBoundingClientRect().left - x;
      }
      function dragRelease(){
        document.getElementById('panemover').style.width = '10px';
        document.getElementById('panemover').style.left = document.getElementById('divider').offsetLeft + 'px';
        mousedown = false;
      }
      function drag(e, left, right){
        if(!mousedown){return}
        x = e.clientX
        tmpLeft = dragOffsetLeft + x
        tmpDivider= dragOffsetDivider + x
        tmpRight = dragOffsetRight + x
        document.getElementById(left).style.width= tmpLeft + 'px';
        document.getElementById("divider").style.left= tmpDivider + 'px';
        document.getElementById(right).style.left = tmpRight + 'px';
      };
    </script>

<script type="text/javascript">

  function mexpand(id)
  {
    var n = document.getElementById(id).style;
    n.display = "block";
  }

  function mcollapse(id)
  {
    var n = document.getElementById(id).style;
    n.display = "none";
  }

  var counter_max = 0;
  function mshow(id,loc)
  {
    var i;
    for(i=1; i<=counter_max; ++i)
      mcollapse("menu"+String(i));
    mexpand(id);
    window.location.replace(loc);
  }
</script>

<script type="text/javascript">

function expand(but,id)
{
  var n = document.getElementById(id).style;
  var button = document.getElementById(but);
  button.src = "/share/src/web/images/minus.gif";
  button.alt = "-";
  n.display = "block";
}
function collapse(but,id)
{
  var n = document.getElementById(id).style;
  var button = document.getElementById(but);
  button.src = "/share/src/web/images/plus.gif";
  button.alt = "+";
  n.display = "none";
}
function toggle(button,id)
{
  var n = document.getElementById(id).style;
  if (n.display == "none")
  {
    button.src = "/share/src/web/images/minus.gif";
    button.alt = "-";
    n.display = "block";
  }
  else
  {
    button.src = "/share/src/web/images/plus.gif";
    button.alt = "+";
    n.display = "none";
  }
}
var allbuttons = [
"A low level example.",
"The source",
"The sink",
"The transducer",
"The limiter",
"The runner",
"Using the chip DSSL",
"How does it stop?",
"Asynchronous I/O",
"Felix is a coroutine",
"Running subsystems",
"The concept of fibration",
"Operations",
"write",
"read",
"suicide",
"spawn",
"Scheduler operation",
"Communication Sequential Coroutines",
"No Deadlocks"
];
function expand_all(dummy)
{
  for (i in allbuttons)
  {
    expand(allbuttons[i], allbuttons[i]+"_d");
  }
}
function collapse_all(dummy)
{
  for (i in allbuttons)
  {
    collapse(allbuttons[i], allbuttons[i]+"_d");
  }
}
</script>

<script>
function mouseover(id)
{
  var elt = document.getElementById(id);
  elt.style.display="none";
  var elt2 = document.getElementById(id+"_mo");
  elt2.style.display="inline";
}

function mouseout(id)
{
  var elt = document.getElementById(id+"_mo");
  elt.style.display="none";
  var elt2 = document.getElementById(id);
  elt2.style.display="inline";
}

</script>
<script> function nop(dummy) {} </script>
    <div class="container">
      <div class="toppanel">
    <!--Main Content top navbar-->
<span style="position:relative; bottom:6px"
  onmouseover="mouseover('expand')"
  onmouseout="mouseout('expand')"
  onclick="expand_all('expand')"
  ><span id="expand"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:blue;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Expand</text></svg></span><span id="expand_mo" style="display:none"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:red;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Expand</text></svg></span></span><span style="position:relative; bottom:6px"
  onmouseover="mouseover('collapse')"
  onmouseout="mouseout('collapse')"
  onclick="collapse_all('collapse')"
  ><span id="collapse"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:blue;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Collapse</text></svg></span><span id="collapse_mo" style="display:none"><svg height="30px" width="65px"><rect x="4px" y="6px" rx="4px" ry="40px" width="60px" height="20px" style="fill:red;opacity:0.2;stroke:black;stroke-width:2"/><text x="13px" y="21px" fill="black" style="font-size:12px;">Collapse</text></svg></span></span>    <!--Main Content top navbar End-->

      </div> <!-- toppanel end -->
      <div class="bottompanel">
        <span id="divider" class="divider"></span>

        <span id="left" class="leftpanel" >
          <div class="menucontent">
  <!--Left Margin Toc-->
  <div id="leftmargintoc">
    <!--Left Margin Toc Main Contents-->
      <div class=m1 onclick="mshow('menu1','#A low level example._h')"> <a href="#A_low_level_example._h">A low level example.</a></div>
      <div class=sm id=menu1>
      <div class=m2><a href="#The_source_h">The source</a></div>
      <div class=m2><a href="#The_sink_h">The sink</a></div>
      <div class=m2><a href="#The_transducer_h">The transducer</a></div>
      <div class=m2><a href="#The_limiter_h">The limiter</a></div>
      <div class=m2><a href="#The_runner_h">The runner</a></div>
      </div>
      <div class=m1 onclick="mshow('menu2','#Using the chip DSSL_h')"> <a href="#Using_the_chip_DSSL_h">Using the chip DSSL</a></div>
      <div class=sm id=menu2>
      <div class=m2><a href="#How_does_it_stop?_h">How does it stop?</a></div>
      </div>
      <div class=m1 onclick="mshow('menu3','#Asynchronous I/O_h')"> <a href="#Asynchronous_I/O_h">Asynchronous I/O</a></div>
      <div class=sm id=menu3>
      <div class=m2><a href="#Felix_is_a_coroutine_h">Felix is a coroutine</a></div>
      <div class=m2><a href="#Running_subsystems_h">Running subsystems</a></div>
      </div>
      <div class=m1 onclick="mshow('menu4','#The concept of fibration_h')"> <a href="#The_concept_of_fibration_h">The concept of fibration</a></div>
      <div class=sm id=menu4>
      <div class=m2><a href="#Operations_h">Operations</a></div>
      <div class=m2><a href="#Communication_Sequential_Coroutines_h">Communication Sequential Coroutines</a></div>
      </div>
      <div class=m1 onclick="mshow('menu5','#No Deadlocks_h')"> <a href="#No_Deadlocks_h">No Deadlocks</a></div>
      <div class=sm id=menu5>
      </div>
    <script>counter_max=5;</script>
  </div>
  <!--End Left Margin Toc-->

          </div> <!-- leftpanel contents end -->
        </span> <!-- leftpanel end -->

        <span id="right" class="rightpanel">
          <div class="maincontent">
<!--Main Content Body-->
<h1 id='A_low_level_example._h'><img src='/share/src/web/images/minus.gif' id='A low level example.' onclick='toggle(this,"A_low_level_example._d")' alt='+'/> 1 A low level example.</h1><div id='A_low_level_example._d' style='display:block'>
<p>I will show a simple low level example of coroutines, it will be a 
simple pipeline consisting of a source, a transducer, a limiter, and a sink.
</p><h2 id='The_source_h'><img src='/share/src/web/images/minus.gif' id='The source' onclick='toggle(this,"The_source_d")' alt='+'/> 1.1 The source</h2><div id='The_source_d' style='display:block'>
<p>First we have our source, which just write all the integers starting from 0
down the channel <code>out</code>. The type <code>%>int</code> is an output channel endpoint
for <code>int</code>.
</p><pre class='inclusion'>
examples/ex1.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> source (out: %&gt;<span class="library" title="binding of C int type">int</span>) () {
<span class="lineno" id=line2></span>    <span class="big_keyword" title="Define a mutable variable">var</span> i = 0;
<span class="lineno" id=line3></span>    <span class="small_keyword" title="while loop">while</span> <span class="library" title="truth value">true</span> <span class="small_keyword" title="imperative code begins">do</span> 
<span class="lineno" id=line4></span>      <span class="library" title="Print a string to a stream">write</span> (out,i); 
<span class="lineno" id=line5></span>      ++i; 
<span class="lineno" id=line6></span>    <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line7></span>  }
</pre></p></div><h2 id='The_sink_h'><img src='/share/src/web/images/minus.gif' id='The sink' onclick='toggle(this,"The_sink_d")' alt='+'/> 1.2 The sink</h2><div id='The_sink_d' style='display:block'>
<p>Now we have a simple sink, which just prints everything it reads:
</p><pre class='inclusion'>
examples/ex1.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> sink (inp: %&lt;<span class="library" title="binding of C int type">int</span>) () {
<span class="lineno" id=line2></span>    <span class="small_keyword" title="while loop">while</span> <span class="library" title="truth value">true</span> <span class="small_keyword" title="imperative code begins">do</span> 
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Define a mutable variable">var</span> i = read inp;
<span class="lineno" id=line4></span>      <span class="library" title="Print a string to standard output with newline appended">println</span>$ i;
<span class="lineno" id=line5></span>    <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line6></span>  }
</pre></p><p>You should note the extra unit parameter <code>()</code>. After the input is bound, the resulting
procedure will have type
</p><p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="library" title="Type with one values (), the empty tuple">unit</span> -&gt; <span class="library" title="Type with one values (), the empty tuple">unit</span>
</pre></p><p>which is the type required to spawn fibre from a coroutine.
</p></div><h2 id='The_transducer_h'><img src='/share/src/web/images/minus.gif' id='The transducer' onclick='toggle(this,"The_transducer_d")' alt='+'/> 1.3 The transducer</h2><div id='The_transducer_d' style='display:block'>
<p>Now we have a transducer which writes the square of every integer it reads.
</p><pre class='inclusion'>
examples/ex1.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> squarer (inp: %&lt;<span class="library" title="binding of C int type">int</span>, out: %&gt;<span class="library" title="binding of C int type">int</span>) () {
<span class="lineno" id=line2></span>    <span class="small_keyword" title="while loop">while</span> <span class="library" title="truth value">true</span> <span class="small_keyword" title="imperative code begins">do</span> 
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Define a mutable variable">var</span> i = read inp;
<span class="lineno" id=line4></span>      <span class="library" title="Print a string to a stream">write</span> (out, i * i);
<span class="lineno" id=line5></span>    <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line6></span>  }
</pre></p></div><h2 id='The_limiter_h'><img src='/share/src/web/images/minus.gif' id='The limiter' onclick='toggle(this,"The_limiter_d")' alt='+'/> 1.4 The limiter</h2><div id='The_limiter_d' style='display:block'>
<p>You should notice the previous three components were all infinite loops.
Since we don't want our demo to run forever we will throw in a limiter chip:
</p><pre class='inclusion'>
examples/ex1.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> limiter (<span class="big_keyword" title="Define a mutable variable">var</span> limit: <span class="library" title="binding of C int type">int</span>) (inp: %&lt;<span class="library" title="binding of C int type">int</span>, out: %&gt;<span class="library" title="binding of C int type">int</span>) () {
<span class="lineno" id=line2></span>    <span class="small_keyword" title="while loop">while</span> limit &gt; 0 <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line3></span>      <span class="big_keyword" title="Define a mutable variable">var</span> i = read inp;
<span class="lineno" id=line4></span>      <span class="library" title="Print a string to a stream">write</span> (out, i);
<span class="lineno" id=line5></span>      --limit;
<span class="lineno" id=line6></span>    <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line7></span>  }
</pre></p><p>This procedure drops through, but it cannot return control, because
there is nowhere to return it to, so it has, in effect, committed
suicide implicitly.
</p></div><h2 id='The_runner_h'><img src='/share/src/web/images/minus.gif' id='The runner' onclick='toggle(this,"The_runner_d")' alt='+'/> 1.5 The runner</h2><div id='The_runner_d' style='display:block'>
<p>Now we need have four components so we need three channels to connect them:
</p><pre class='inclusion'>
examples/ex1.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> run_pipeline() {
<span class="lineno" id=line2></span>    <span class="comment">// make channels</span>
<span class="lineno" id=line3></span>    <span class="big_keyword" title="Define a mutable variable">var</span> i1,o1 = mk_ioschannel_pair[<span class="library" title="binding of C int type">int</span>](); 
<span class="lineno" id=line4></span>    <span class="big_keyword" title="Define a mutable variable">var</span> i2,o2 = mk_ioschannel_pair[<span class="library" title="binding of C int type">int</span>](); 
<span class="lineno" id=line5></span>    <span class="big_keyword" title="Define a mutable variable">var</span> i3,o3 = mk_ioschannel_pair[<span class="library" title="binding of C int type">int</span>](); 
<span class="lineno" id=line6></span>  
<span class="lineno" id=line7></span>    <span class="comment">// make coroutines by binding the channels</span>
<span class="lineno" id=line8></span>    <span class="big_keyword" title="Define a mutable variable">var</span> d1 = source(o1);
<span class="lineno" id=line9></span>    <span class="big_keyword" title="Define a mutable variable">var</span> d2 = squarer(i1,o2);
<span class="lineno" id=line10></span>    <span class="big_keyword" title="Define a mutable variable">var</span> d3 = limiter 8 (i2,o3);
<span class="lineno" id=line11></span>    <span class="big_keyword" title="Define a mutable variable">var</span> d4 = sink (i3);
<span class="lineno" id=line12></span>  
<span class="lineno" id=line13></span>    <span class="comment">// spawn coroutines as fibres</span>
<span class="lineno" id=line14></span>    <span class="big_keyword" title="Spawn a cooperative fibre">spawn_fthread</span> d1;
<span class="lineno" id=line15></span>    <span class="big_keyword" title="Spawn a cooperative fibre">spawn_fthread</span> d2;
<span class="lineno" id=line16></span>    <span class="big_keyword" title="Spawn a cooperative fibre">spawn_fthread</span> d3;
<span class="lineno" id=line17></span>    <span class="big_keyword" title="Spawn a cooperative fibre">spawn_fthread</span> d4;
<span class="lineno" id=line18></span>   
<span class="lineno" id=line19></span>    <span class="comment">// exit</span>
<span class="lineno" id=line20></span>  }
<span class="lineno" id=line21></span>  run_pipeline();
</pre></p><p>Here is the complete program: <a href="https://github.com/felix-lang/felix-lang.github.io/blob/main/examples/ex1.flx">ex1.flx</a>
</p></div></div><h1 id='Using_the_chip_DSSL_h'><img src='/share/src/web/images/minus.gif' id='Using the chip DSSL' onclick='toggle(this,"Using_the_chip_DSSL_d")' alt='+'/> 2 Using the chip DSSL</h1><div id='Using_the_chip_DSSL_d' style='display:block'>
<p>The code above involves a bit of boilerplate so I'm going to show you how to do the
same job using the <em>chip</em> DSSL. A DSSL is a unique feature of Felix which allows
the <em>user</em> to define an extension to the existing language, which has an application
in a specific domain. Unlike DSLs or domain specific languages, Felix has DSSLs or domain
specific <em>sub-</em>languages.
</p><p>Let me show you: first our source:
</p><pre class='inclusion'>
examples/ex2.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="defines a coroutine using chip idiom">chip</span> source
<span class="lineno" id=line2></span>    <span class="small_keyword" title="the parameter of a chip">connector</span> io
<span class="lineno" id=line3></span>     <span class="small_keyword" title="a field of the chip parameter">pin</span> out: %&gt;<span class="library" title="binding of C int type">int</span>
<span class="lineno" id=line4></span>  {
<span class="lineno" id=line5></span>    <span class="big_keyword" title="Define a mutable variable">var</span> i = 0;
<span class="lineno" id=line6></span>    <span class="small_keyword" title="while loop">while</span> <span class="library" title="truth value">true</span> <span class="small_keyword" title="imperative code begins">do</span> 
<span class="lineno" id=line7></span>      <span class="library" title="Print a string to a stream">write</span> (io.out,i); 
<span class="lineno" id=line8></span>      ++i; 
<span class="lineno" id=line9></span>    <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line10></span>  }
</pre></p><p>This is the same as before except that the channel name now has the form <code>connector.pin</code> 
and so we put <code>io.out</code> as the channel name. There is no magic here, the connector name
is the name of the parameter, and the pin names are fields of a record, so the parameter
actually has a record type.
</p><p>Now here is the sink:
</p><pre class='inclusion'>
examples/ex2.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="defines a coroutine using chip idiom">chip</span> sink 
<span class="lineno" id=line2></span>    <span class="small_keyword" title="the parameter of a chip">connector</span> io
<span class="lineno" id=line3></span>      <span class="small_keyword" title="a field of the chip parameter">pin</span> inp: %&lt;<span class="library" title="binding of C int type">int</span>
<span class="lineno" id=line4></span>  {
<span class="lineno" id=line5></span>    <span class="small_keyword" title="while loop">while</span> <span class="library" title="truth value">true</span> <span class="small_keyword" title="imperative code begins">do</span> 
<span class="lineno" id=line6></span>      <span class="big_keyword" title="Define a mutable variable">var</span> i = read io.inp;
<span class="lineno" id=line7></span>      <span class="library" title="Print a string to standard output with newline appended">println</span>$ i;
<span class="lineno" id=line8></span>    <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line9></span>  }
</pre></p><p>Now here is the transducer and limiter
</p><pre class='inclusion'>
examples/ex2.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="defines a coroutine using chip idiom">chip</span> squarer 
<span class="lineno" id=line2></span>    <span class="small_keyword" title="the parameter of a chip">connector</span> io
<span class="lineno" id=line3></span>      <span class="small_keyword" title="a field of the chip parameter">pin</span> inp: %&lt;<span class="library" title="binding of C int type">int</span>
<span class="lineno" id=line4></span>      <span class="small_keyword" title="a field of the chip parameter">pin</span> out: %&gt;<span class="library" title="binding of C int type">int</span>
<span class="lineno" id=line5></span>  {
<span class="lineno" id=line6></span>    <span class="small_keyword" title="while loop">while</span> <span class="library" title="truth value">true</span> <span class="small_keyword" title="imperative code begins">do</span> 
<span class="lineno" id=line7></span>      <span class="big_keyword" title="Define a mutable variable">var</span> i = read io.inp;
<span class="lineno" id=line8></span>      <span class="library" title="Print a string to a stream">write</span> (io.out, i * i);
<span class="lineno" id=line9></span>    <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line10></span>  }
<span class="lineno" id=line11></span>  <span class="big_keyword" title="defines a coroutine using chip idiom">chip</span> limiter (<span class="big_keyword" title="Define a mutable variable">var</span> limit: <span class="library" title="binding of C int type">int</span>) 
<span class="lineno" id=line12></span>    <span class="small_keyword" title="the parameter of a chip">connector</span> io
<span class="lineno" id=line13></span>      <span class="small_keyword" title="a field of the chip parameter">pin</span> inp: %&lt;<span class="library" title="binding of C int type">int</span>
<span class="lineno" id=line14></span>      <span class="small_keyword" title="a field of the chip parameter">pin</span> out: %&gt;<span class="library" title="binding of C int type">int</span>
<span class="lineno" id=line15></span>  {
<span class="lineno" id=line16></span>    <span class="small_keyword" title="while loop">while</span> limit &gt; 0 <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line17></span>      <span class="big_keyword" title="Define a mutable variable">var</span> i = read io.inp;
<span class="lineno" id=line18></span>      <span class="library" title="Print a string to a stream">write</span> (io.out, i);
<span class="lineno" id=line19></span>      --limit;
<span class="lineno" id=line20></span>    <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line21></span>  };
</pre></p><p>Now to connect these things we say this:
</p><pre class='inclusion'>
examples/ex2.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> run_pipeline1() {
<span class="lineno" id=line2></span>    <span class="small_keyword" title="a synonym for var to suit the chip idiom">device</span> limit8  = limiter 8;
<span class="lineno" id=line3></span>    <span class="small_keyword" title="defines the topology of chip connections">circuit</span>
<span class="lineno" id=line4></span>      <span class="small_keyword" title="connects two pins with a channel">connect</span> source.out, squarer.inp
<span class="lineno" id=line5></span>      <span class="small_keyword" title="connects two pins with a channel">connect</span> squarer.out, limit8.inp
<span class="lineno" id=line6></span>      <span class="small_keyword" title="connects two pins with a channel">connect</span> limit8.out, sink.inp
<span class="lineno" id=line7></span>    <span class="small_keyword" title="defines the topology of chip connections">endcircuit</span>
<span class="lineno" id=line8></span>  }
<span class="lineno" id=line9></span>  run_pipeline1();
</pre></p><p>The <code>circuit</code> statement connects all the chips into a circuit and runs it.
The most important feature here is that the chips are <em>anonymous</em>.
Note the <code>connect</code> clause does not need to use the connector name,
it uses the first connector. This particular feature is implemented in the
compiler itself to allow I/O direction checking and exhaustion checking.
You cannot leave any pin disconnected.
</p><p>The <code>circuit</code> feature is very general. For pipelines there is an even easer
syntax:
</p><pre class='inclusion'>
examples/ex2.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="Define a procedure, a function with side-effects not returning a value">proc</span> run_pipeline2() { 
<span class="lineno" id=line2></span>    (source |-&gt; squarer |-&gt; limiter 8 |-&gt; sink)();
<span class="lineno" id=line3></span>  }
<span class="lineno" id=line4></span>  run_pipeline2();
</pre></p><p>For any functional programmers around, a pipeline is semantically identical
to a Monad.
</p><h2 id='How_does_it_stop?_h'><img src='/share/src/web/images/minus.gif' id='How does it stop?' onclick='toggle(this,"How_does_it_stop?_d")' alt='+'/> 2.1 How does it stop?</h2><div id='How_does_it_stop?_d' style='display:block'>
<p>It is clear, because I told you, that we put the <code>limiter</code> into the pipeline so it terminates.
So the <code>limiter</code> commits suicide by dropping off the end after a certain number of data transfers.
But the other three components are infinite loops, so how does the system terminate?
</p><p>First consider the transducer <code>squarer</code> tries to write to the limiter, but alas, it is dead?
The write stalls, and we say the fibre is <em>blocked</em> or being vulgar, <em>constipated</em>.
And now, since it is blocked, it cannot read the input from the <code>source</code>, so it too is blocked.
</p><p>The <code>sink</code> on the other hand has a different problem: it is trying to read from the <code>limiter</code>
but the limiter is dead, so there is no input coming: the sink is said to be <code>starved</code>.
</p><p>There are therefore <em>no active fibres</em> so the system terminates.
I will emphasise this point heavily because these are the correct termination semantics.
There is another language with processes and channels, namely <code>golang</code>. 
Unfortunately <code>golang</code> got the termination semantics completely wrong.
in addition, <code>golang</code> channel semantics are also wrong because channels can be closed
and a reader can detect if a writer closed the channel. 
</p><p>Although this is not possible in Felix, you can write the option type <code>opt</code> and use
the <code>None</code> case to signal end of data. In fact, in Felix you can write <em>any</em>
type down a channel, even channels!
</p></div></div><h1 id='Asynchronous_I/O_h'><img src='/share/src/web/images/minus.gif' id='Asynchronous I/O' onclick='toggle(this,"Asynchronous_I/O_d")' alt='+'/> 3 Asynchronous I/O</h1><div id='Asynchronous_I/O_d' style='display:block'>
<p>Although coroutines are <em>synchronous</em> Felix supports an extension
which allows two kinds of <em>asynchronous</em> I/O.
</p><p>First, the library contains routines which can perform operations on sockets
including <code>read</code>, <code>write</code>, <code>bind</code>, and <code>connect</code>. That subsystem was used
to construct <code>flx_web</code> which is the fastest web server in existence and can handle
enormous loads. It outperforms other webservers because it associates a fibre,
rather than a thread, with each connection, so context switching is lightning fast
and occurs in user space.
</p><p>The socket system also uses advanced socket state notificantion services such
as <code>kqueue</code> on MacOS and <code>epoll</code> on Linux.
</p><p>However we will demonstrate a simpler service, namely the system alarm closk
because it has a really simply API.
</p><pre class='inclusion'>
examples/ex3.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="library" title="Print a string to standard output with newline appended">println</span>$ <span class="fstring">"Begin Spawning"</span>;
<span class="lineno" id=line2></span>  
<span class="lineno" id=line3></span>  <span class="big_keyword" title="Spawn a cooperative fibre">spawn_fthread</span> {
<span class="lineno" id=line4></span>    <span class="library" title="Print a string to standard output with newline appended">println</span> <span class="fstring">"Start1"</span>; sleep (2.0); <span class="library" title="Print a string to standard output with newline appended">println</span>$ <span class="fstring">"End1"</span>;
<span class="lineno" id=line5></span>  };
<span class="lineno" id=line6></span>  
<span class="lineno" id=line7></span>  <span class="big_keyword" title="Spawn a cooperative fibre">spawn_fthread</span> {
<span class="lineno" id=line8></span>    <span class="library" title="Print a string to standard output with newline appended">println</span> <span class="fstring">"Start2"</span>; sleep (1.0); <span class="library" title="Print a string to standard output with newline appended">println</span>$ <span class="fstring">"End2"</span>;
<span class="lineno" id=line9></span>  };
<span class="lineno" id=line10></span>  
<span class="lineno" id=line11></span>  sleep (0.25);
<span class="lineno" id=line12></span>  <span class="library" title="Print a string to standard output with newline appended">println</span>$ <span class="fstring">"Mainline terminates"</span>;
</pre></p><p>And here's the output:
</p><p><pre class="prefmtbg">Begin Spawning
Start1
Start2
Mainline terminates
End2
End1
</pre></p><p>The <code>sleep</code> procedure <em>suspends</em> the coroutine, it does not block
the pthread running the coroutine system. So aftedr the first coroutine
goes to sleep, the mainline continues and spawns the second coroutine.
But then, the mainline itself completes and suicides by fall through.
</p><h2 id='Felix_is_a_coroutine_h'><img src='/share/src/web/images/minus.gif' id='Felix is a coroutine' onclick='toggle(this,"Felix_is_a_coroutine_d")' alt='+'/> 3.1 Felix is a coroutine</h2><div id='Felix_is_a_coroutine_d' style='display:block'>
<p>Most programming language generate programs which consist of single top level procedure,
for example <code>main()</code> in C. It is a subroutine called by the startup code which in turn
was invoked by the operating system.
</p><p>Felix, as usual, is different. For a start, Felix generates libraries, in fact the
default is a shared library. So in fact, what you think is mainline code running
is in fact just the initialisation code for the library. You can also  
add a procedure <code>flx_main()</code> to your code and that will also be run after
the initialisation of the library.
</p><p>However there is something else different: the Felix mainline code is not
a subroutine, it is a coroutine! The mainline can happily terminate and
leave other fibres running: there's really nothing special about your
main program code, it's just another coroutine.
</p><p>The Felix startup code creates a scheduler to run coroutines, and your
program code is just the initial coroutine. So your program terminates
when there is nothing left to do precisely because it's just another
coroutine.
</p></div><h2 id='Running_subsystems_h'><img src='/share/src/web/images/minus.gif' id='Running subsystems' onclick='toggle(this,"Running_subsystems_d")' alt='+'/> 3.2 Running subsystems</h2><div id='Running_subsystems_d' style='display:block'>
<p>There is a constraint on Felix coroutines: they have to be procedures.
Functions cannot read and write channels. However there is a way around
this problem: you can use the <code>run</code> subroutine to create an run a new,
nested, scheduler. 
</p><p>The <code>run</code> subroutine, being a subroutine, returns when it is finished.
</p><p>Unfortunately there is another constraint on nested schedulers: they cannot
do asynchronous I/O.
</p></div></div><h1 id='The_concept_of_fibration_h'><img src='/share/src/web/images/minus.gif' id='The concept of fibration' onclick='toggle(this,"The_concept_of_fibration_d")' alt='+'/> 4 The concept of fibration</h1><div id='The_concept_of_fibration_d' style='display:block'>
<p>A <em>coroutine system</em> is a collection of processes called <em>fibres</em>
with these properties:
<ul>
<li>Exactly one process can be <em>running</em> at once, the others are said to be <em>suspended</em></li>
<li>Control cannot be pre-empted, but is yielded voluntarily</li>
</ul>
In our system, there are four principle operations which yield control:
<ol>
<li><em>spawn</em> a new fibre</li>
<li><em>read</em> from a channel</li>
<li><em>write</em> to a channel</li>
<li>Commit <em>suicide</em>
</ol>
A fibre of control can be in one of five states:
<ol>
<li>Running</em>
<li>Active (but not running)</li>
<li>Waiting on read</li>
<li>Waiting on write</ii>
<li>Dead</li>
</ol>
In our system, all the resources associated by an <em>unreachable</em> dead
fibre are automatically reaped by the garbage collector so that in fact
the fibre is not technically dead because it no longer exists.
</p><p>A <em>channel</em> is an object associated with which 
set of fibres all waiting to read or all waiting to write.
</p><h2 id='Operations_h'><img src='/share/src/web/images/minus.gif' id='Operations' onclick='toggle(this,"Operations_d")' alt='+'/> 4.1 Operations</h2><div id='Operations_d' style='display:block'>
<h3 id='write_h'><img src='/share/src/web/images/minus.gif' id='write' onclick='toggle(this,"write_d")' alt='+'/> 4.1.1 write</h3><div id='write_d' style='display:block'>
<p>When a write operation is performed on a channel by the running fibre,
if there are fibres on the channel which are waiting to read
then one is selected, the data to be written is tranfered from the writer to the reader,
the fibre is removed from association with the channel,
and both the running and reader fibre are made active.
Otherwise if there is no readers waiting on the channel, the writer is 
suspended and put on the channel.
</p></div><h3 id='read_h'><img src='/share/src/web/images/minus.gif' id='read' onclick='toggle(this,"read_d")' alt='+'/> 4.1.2 read</h3><div id='read_d' style='display:block'>
<p>When a read operation is performed on a channel by the running fibre,
if there are fibres on the channel which are waiting to write
then one is selected, the data to be written is transfered from the writer to the reader, 
fibre, the fibre is removed from association with the channel,
and both the running and reader fibre are made active.
Otherwise if there is no writers waiting on the channel, the writer is 
suspended and put on the channel.
</p></div><h3 id='suicide_h'><img src='/share/src/web/images/minus.gif' id='suicide' onclick='toggle(this,"suicide_d")' alt='+'/> 4.1.3 suicide</h3><div id='suicide_d' style='display:block'>
<p>When a fibre commits suicide, it is removed as the running fibre.
</p></div><h3 id='spawn_h'><img src='/share/src/web/images/minus.gif' id='spawn' onclick='toggle(this,"spawn_d")' alt='+'/> 4.1.4 spawn</h3><div id='spawn_d' style='display:block'>
<p>When a new fibre is spawned, both the spawner and spawnee are made active.
</p></div><h3 id='Scheduler_operation_h'><img src='/share/src/web/images/minus.gif' id='Scheduler operation' onclick='toggle(this,"Scheduler_operation_d")' alt='+'/> 4.1.5 Scheduler operation</h3><div id='Scheduler_operation_d' style='display:block'>
<p>When there is no running fibre, then if an active fibre exists,
an active fibre is selected and promoted to running state
and the thread of control begins executing it.
</p><p>When there is no running fibre, and no active fibres,
the whole system terminates. Any fibres waiting on I/O become dead
</p></div></div><h2 id='Communication_Sequential_Coroutines_h'><img src='/share/src/web/images/minus.gif' id='Communication Sequential Coroutines' onclick='toggle(this,"Communication_Sequential_Coroutines_d")' alt='+'/> 4.2 Communication Sequential Coroutines</h2><div id='Communication_Sequential_Coroutines_d' style='display:block'>
<p>The description above is a complete account of the abstract semantics
known as <em>Communicating Sequential Coroutines</em> or CSC, it is a
sub system obtain from Tony Hoare's <em>Communicating Sequenmtial Processes</em>
or CSP, in which concurrency is replaced by an indeterminate total ordering.
</p><p>To be precise in CSC all events are totally ordered, however the exact ordering
is not determinate. This is because a scheduler running the system is free
to pick any active fibre to run when one is needed; similarly
a read or write operation can match with any dual operation on a channel.
</p><p>In the Felix implementation, a spawned fibre runs immediately
if the <code>spawn_fthread</code> procedure is used to launch it, or the
running fibre continues instead, of <code>schedule_fthread</code> is used instead.
</p><p>In addition, I/O transfers always result in the reader proceeding,
to give it a chance to actually fetch the data before the write
might modify it.
</p></div></div><h1 id='No_Deadlocks_h'><img src='/share/src/web/images/minus.gif' id='No Deadlocks' onclick='toggle(this,"No_Deadlocks_d")' alt='+'/> 5 No Deadlocks</h1><div id='No_Deadlocks_d' style='display:block'>
<p>Most threading systems can deadlock. Here is the classical situation:
</p><pre class='inclusion'>
examples/ex5.flx</pre>
<p><pre class='flxbg'><span class="lineno" id=line1></span>  <span class="big_keyword" title="defines a coroutine using chip idiom">chip</span> D <span class="small_keyword" title="the parameter of a chip">connector</span> io <span class="small_keyword" title="a field of the chip parameter">pin</span> inp: %&lt;<span class="library" title="binding of C int type">int</span> <span class="small_keyword" title="a field of the chip parameter">pin</span> out: %&gt;<span class="library" title="binding of C int type">int</span> 
<span class="lineno" id=line2></span>  {
<span class="lineno" id=line3></span>     <span class="small_keyword" title="while loop">while</span> <span class="library" title="truth value">true</span> <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id=line4></span>       <span class="big_keyword" title="Define a mutable variable">var</span> x = read io.inp;
<span class="lineno" id=line5></span>       <span class="library" title="Print a string to a stream">write</span> (io.out, x);
<span class="lineno" id=line6></span>     <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id=line7></span>  }
<span class="lineno" id=line8></span>  <span class="small_keyword" title="a synonym for var to suit the chip idiom">device</span> A = D;
<span class="lineno" id=line9></span>  <span class="small_keyword" title="a synonym for var to suit the chip idiom">device</span> B = D;
<span class="lineno" id=line10></span>  <span class="small_keyword" title="defines the topology of chip connections">circuit</span> 
<span class="lineno" id=line11></span>    <span class="small_keyword" title="connects two pins with a channel">connect</span> A.out, B.inp
<span class="lineno" id=line12></span>    <span class="small_keyword" title="connects two pins with a channel">connect</span> B.out, A.inp
<span class="lineno" id=line13></span>  <span class="small_keyword" title="defines the topology of chip connections">endcircuit</span>
<span class="lineno" id=line14></span>  <span class="library" title="Print a string to standard output with newline appended">println</span>$ <span class="fstring">"Done"</span>;
</pre></p><p>Both devices start by reading, so there's nothing to read because
neither can proceed to writing. So the system hangs, right!
</p><p>Er .. NO! Both chips are suspended, the mainline completes,
and the scheduler terminates the program because there is no work to do.
</p><p>Let me repeat in bold letters:
</p><p><bf style="color:red">FELIX COROUTINES CANNOT DEADLOCK</bf>
</p><p>However they can <em>livelock</em>, but only if you mismanage
manual circuit construction. Here's an example:
</p><p><pre class="prefmtbg">var inp,out = mk_ioschannel_pair[int]();
spawn_fthread { write (out, 42); };
</pre></p><p>This is a livelock because the mainline <em>could</em> read
the written data on the channel endpoint <code>inp</code> but doesn't.
</p></div><!--Main Content Body End-->

          </div> <!-- rightpanel contents end -->
          <hr>
        </span> <!-- rightpanel end -->

        <span id="panemover" style="cursor:col-resize;"
         onmousedown="dragStart(event, 'left', 'right'); return false;"
         onmousemove="drag(event, 'left', 'right');"
         onmouseout="dragRelease();"
         onmouseup="dragRelease();"
        >
        </span> <!-- panemover end -->
      </div> <!-- bottom panel end -->
    </div> <!-- container end -->
</body></html>

